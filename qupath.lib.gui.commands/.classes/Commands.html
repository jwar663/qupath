


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Commands</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">qupath.lib.gui.commands</a> ]
</div>

<h1>Coverage Summary for Class: Commands (qupath.lib.gui.commands)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Commands</td>
<td class="coverageStat">
  <span class="percent">
    4.3%
  </span>
  <span class="absValue">
    (3/ 69)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.1%
  </span>
  <span class="absValue">
    (9/ 823)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Commands$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Commands$SingleStageCommand</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (3/ 9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    5.6%
  </span>
  <span class="absValue">
    (4/ 72)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.4%
  </span>
  <span class="absValue">
    (12/ 833)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*-
<i>2</i>&nbsp; * #%L
<i>3</i>&nbsp; * This file is part of QuPath.
<i>4</i>&nbsp; * %%
<i>5</i>&nbsp; * Copyright (C) 2018 - 2020 QuPath developers, The University of Edinburgh
<i>6</i>&nbsp; * %%
<i>7</i>&nbsp; * QuPath is free software: you can redistribute it and/or modify
<i>8</i>&nbsp; * it under the terms of the GNU General Public License as
<i>9</i>&nbsp; * published by the Free Software Foundation, either version 3 of the
<i>10</i>&nbsp; * License, or (at your option) any later version.
<i>11</i>&nbsp; * 
<i>12</i>&nbsp; * QuPath is distributed in the hope that it will be useful,
<i>13</i>&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
<i>14</i>&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<i>15</i>&nbsp; * GNU General Public License for more details.
<i>16</i>&nbsp; * 
<i>17</i>&nbsp; * You should have received a copy of the GNU General Public License 
<i>18</i>&nbsp; * along with QuPath.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
<i>19</i>&nbsp; * #L%
<i>20</i>&nbsp; */
<i>21</i>&nbsp;
<i>22</i>&nbsp;package qupath.lib.gui.commands;
<i>23</i>&nbsp;
<i>24</i>&nbsp;import java.awt.Window;
<i>25</i>&nbsp;import java.awt.image.BufferedImage;
<i>26</i>&nbsp;import java.io.File;
<i>27</i>&nbsp;import java.io.IOException;
<i>28</i>&nbsp;import java.nio.file.Files;
<i>29</i>&nbsp;import java.util.ArrayList;
<i>30</i>&nbsp;import java.util.Arrays;
<i>31</i>&nbsp;import java.util.Collection;
<i>32</i>&nbsp;import java.util.Collections;
<i>33</i>&nbsp;import java.util.Iterator;
<i>34</i>&nbsp;import java.util.List;
<i>35</i>&nbsp;import java.util.Map;
<i>36</i>&nbsp;import java.util.WeakHashMap;
<i>37</i>&nbsp;import java.util.function.Function;
<i>38</i>&nbsp;import java.util.function.Supplier;
<i>39</i>&nbsp;import java.util.stream.Collectors;
<i>40</i>&nbsp;
<i>41</i>&nbsp;import org.controlsfx.control.CheckListView;
<i>42</i>&nbsp;import org.controlsfx.control.action.Action;
<i>43</i>&nbsp;import org.slf4j.Logger;
<i>44</i>&nbsp;import org.slf4j.LoggerFactory;
<i>45</i>&nbsp;
<i>46</i>&nbsp;import javafx.beans.binding.Bindings;
<i>47</i>&nbsp;import javafx.beans.property.DoubleProperty;
<i>48</i>&nbsp;import javafx.beans.property.StringProperty;
<i>49</i>&nbsp;import javafx.beans.value.ObservableDoubleValue;
<i>50</i>&nbsp;import javafx.geometry.Insets;
<i>51</i>&nbsp;import javafx.geometry.Pos;
<i>52</i>&nbsp;import javafx.scene.Scene;
<i>53</i>&nbsp;import javafx.scene.control.Button;
<i>54</i>&nbsp;import javafx.scene.control.ButtonType;
<i>55</i>&nbsp;import javafx.scene.control.ComboBox;
<i>56</i>&nbsp;import javafx.scene.control.ContentDisplay;
<i>57</i>&nbsp;import javafx.scene.control.Label;
<i>58</i>&nbsp;import javafx.scene.control.Slider;
<i>59</i>&nbsp;import javafx.scene.control.TextArea;
<i>60</i>&nbsp;import javafx.scene.control.TextField;
<i>61</i>&nbsp;import javafx.scene.control.Tooltip;
<i>62</i>&nbsp;import javafx.scene.control.cell.CheckBoxListCell;
<i>63</i>&nbsp;import javafx.scene.layout.BorderPane;
<i>64</i>&nbsp;import javafx.scene.layout.GridPane;
<i>65</i>&nbsp;import javafx.scene.layout.Pane;
<i>66</i>&nbsp;import javafx.scene.layout.Priority;
<i>67</i>&nbsp;import javafx.scene.layout.StackPane;
<i>68</i>&nbsp;import javafx.scene.text.TextAlignment;
<i>69</i>&nbsp;import javafx.stage.Modality;
<i>70</i>&nbsp;import javafx.stage.Screen;
<i>71</i>&nbsp;import javafx.stage.Stage;
<i>72</i>&nbsp;import qupath.lib.analysis.DistanceTools;
<i>73</i>&nbsp;import qupath.lib.analysis.features.ObjectMeasurements.ShapeFeatures;
<i>74</i>&nbsp;import qupath.lib.common.GeneralTools;
<i>75</i>&nbsp;import qupath.lib.gui.ActionTools;
<i>76</i>&nbsp;import qupath.lib.gui.QuPathGUI;
<i>77</i>&nbsp;import qupath.lib.gui.dialogs.Dialogs;
<i>78</i>&nbsp;import qupath.lib.gui.dialogs.Dialogs.DialogButton;
<i>79</i>&nbsp;import qupath.lib.gui.images.servers.RenderedImageServer;
<i>80</i>&nbsp;import qupath.lib.gui.panes.MeasurementMapPane;
<i>81</i>&nbsp;import qupath.lib.gui.panes.PathClassPane;
<i>82</i>&nbsp;import qupath.lib.gui.panes.WorkflowCommandLogView;
<i>83</i>&nbsp;import qupath.lib.gui.prefs.PathPrefs;
<i>84</i>&nbsp;import qupath.lib.gui.tma.TMASummaryViewer;
<i>85</i>&nbsp;import qupath.lib.gui.tools.GuiTools;
<i>86</i>&nbsp;import qupath.lib.gui.tools.PaneTools;
<i>87</i>&nbsp;import qupath.lib.gui.viewer.GridLines;
<i>88</i>&nbsp;import qupath.lib.gui.viewer.OverlayOptions;
<i>89</i>&nbsp;import qupath.lib.gui.viewer.QuPathViewer;
<i>90</i>&nbsp;import qupath.lib.gui.viewer.recording.ViewTrackerControlPane;
<i>91</i>&nbsp;import qupath.lib.images.ImageData;
<i>92</i>&nbsp;import qupath.lib.images.servers.ImageServer;
<i>93</i>&nbsp;import qupath.lib.images.servers.ImageServers;
<i>94</i>&nbsp;import qupath.lib.images.servers.ServerTools;
<i>95</i>&nbsp;import qupath.lib.images.writers.ImageWriter;
<i>96</i>&nbsp;import qupath.lib.images.writers.ImageWriterTools;
<i>97</i>&nbsp;import qupath.lib.io.PathIO;
<i>98</i>&nbsp;import qupath.lib.objects.PathAnnotationObject;
<i>99</i>&nbsp;import qupath.lib.objects.PathCellObject;
<i>100</i>&nbsp;import qupath.lib.objects.PathDetectionObject;
<i>101</i>&nbsp;import qupath.lib.objects.PathObject;
<i>102</i>&nbsp;import qupath.lib.objects.PathObjectTools;
<i>103</i>&nbsp;import qupath.lib.objects.PathObjects;
<i>104</i>&nbsp;import qupath.lib.objects.PathTileObject;
<i>105</i>&nbsp;import qupath.lib.objects.TMACoreObject;
<i>106</i>&nbsp;import qupath.lib.objects.hierarchy.PathObjectHierarchy;
<i>107</i>&nbsp;import qupath.lib.objects.hierarchy.TMAGrid;
<i>108</i>&nbsp;import qupath.lib.plugins.parameters.ParameterList;
<i>109</i>&nbsp;import qupath.lib.plugins.workflow.DefaultScriptableWorkflowStep;
<i>110</i>&nbsp;import qupath.lib.plugins.workflow.WorkflowStep;
<i>111</i>&nbsp;import qupath.lib.projects.Project;
<i>112</i>&nbsp;import qupath.lib.projects.ProjectIO;
<i>113</i>&nbsp;import qupath.lib.projects.Projects;
<i>114</i>&nbsp;import qupath.lib.regions.ImagePlane;
<i>115</i>&nbsp;import qupath.lib.regions.ImageRegion;
<i>116</i>&nbsp;import qupath.lib.regions.RegionRequest;
<i>117</i>&nbsp;import qupath.lib.roi.PolygonROI;
<i>118</i>&nbsp;import qupath.lib.roi.ROIs;
<i>119</i>&nbsp;import qupath.lib.roi.RectangleROI;
<i>120</i>&nbsp;import qupath.lib.roi.RoiTools;
<i>121</i>&nbsp;import qupath.lib.roi.RoiTools.CombineOp;
<i>122</i>&nbsp;import qupath.lib.roi.ShapeSimplifier;
<i>123</i>&nbsp;import qupath.lib.roi.interfaces.ROI;
<i>124</i>&nbsp;import qupath.lib.scripting.QP;
<i>125</i>&nbsp;
<i>126</i>&nbsp;/**
<i>127</i>&nbsp; * Helper class implementing simple &#39;single-method&#39; commands for easy inclusion in the GUI.
<i>128</i>&nbsp; * 
<i>129</i>&nbsp; * @author Pete Bankhead
<i>130</i>&nbsp; *
<i>131</i>&nbsp; */
<b class="nc"><i>132</i>&nbsp;public class Commands {</b>
<i>133</i>&nbsp;	
<b class="fc"><i>134</i>&nbsp;	private static Logger logger = LoggerFactory.getLogger(Commands.class);</b>
<i>135</i>&nbsp;	
<i>136</i>&nbsp;	/**
<i>137</i>&nbsp;	 * Insert the selected objects in the hierarchy, resolving positions accordingly.
<i>138</i>&nbsp;	 * &lt;p&gt;
<i>139</i>&nbsp;	 * This causes smaller &#39;completely-contained&#39; annotations to be positioned below larger containing annotations, 
<i>140</i>&nbsp;	 * and detections to be assigned to other annotations based on centroid location.
<i>141</i>&nbsp;	 * @param imageData the image data containing the hierarchy
<i>142</i>&nbsp;	 */
<i>143</i>&nbsp;	public static void insertSelectedObjectsInHierarchy(ImageData&lt;?&gt; imageData) {
<b class="nc"><i>144</i>&nbsp;		if (imageData == null)</b>
<b class="nc"><i>145</i>&nbsp;			return;</b>
<b class="nc"><i>146</i>&nbsp;		var hierarchy = imageData.getHierarchy();</b>
<b class="nc"><i>147</i>&nbsp;		hierarchy.insertPathObjects(hierarchy.getSelectionModel().getSelectedObjects());</b>
<b class="nc"><i>148</i>&nbsp;	}</b>
<i>149</i>&nbsp;	
<i>150</i>&nbsp;	/**
<i>151</i>&nbsp;	 * Resolve parent-child relationships within the object hierarchy.
<i>152</i>&nbsp;	 * This means that objects will be arranged hierarchically, rather than as a flat list.
<i>153</i>&nbsp;	 * @param imageData the image data to process
<i>154</i>&nbsp;	 */
<i>155</i>&nbsp;	public static void promptToResolveHierarchy(ImageData&lt;?&gt; imageData) {
<b class="nc"><i>156</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>157</i>&nbsp;			Dialogs.showNoImageError(&quot;Resolve hierarchy&quot;);</b>
<b class="nc"><i>158</i>&nbsp;			return;</b>
<i>159</i>&nbsp;		}
<b class="nc"><i>160</i>&nbsp;		var hierarchy = imageData == null ? null : imageData.getHierarchy();</b>
<b class="nc"><i>161</i>&nbsp;		if (hierarchy == null)</b>
<b class="nc"><i>162</i>&nbsp;			return;</b>
<i>163</i>&nbsp;		
<b class="nc"><i>164</i>&nbsp;		if (!Dialogs.showConfirmDialog(&quot;Resolve hierarchy&quot;,</b>
<i>165</i>&nbsp;				&quot;Are you sure you want to resolve object relationships?\n&quot; +
<i>166</i>&nbsp;				&quot;For large object hierarchies this can take a long time.&quot;)) {
<b class="nc"><i>167</i>&nbsp;			return;</b>
<i>168</i>&nbsp;		}
<b class="nc"><i>169</i>&nbsp;		hierarchy.resolveHierarchy();</b>
<i>170</i>&nbsp;		
<b class="nc"><i>171</i>&nbsp;		imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(</b>
<i>172</i>&nbsp;				&quot;Resolve hierarchy&quot;,
<i>173</i>&nbsp;				&quot;resolveHierarchy()&quot;));
<b class="nc"><i>174</i>&nbsp;	}</b>
<i>175</i>&nbsp;	
<i>176</i>&nbsp;	
<i>177</i>&nbsp;	/**
<i>178</i>&nbsp;	 * Create a full image annotation for the image in the specified viewer.
<i>179</i>&nbsp;	 * The z and t positions of the viewer will be used.
<i>180</i>&nbsp;	 * @param viewer the viewer containing the image to be processed
<i>181</i>&nbsp;	 */
<i>182</i>&nbsp;	public static void createFullImageAnnotation(QuPathViewer viewer) {
<b class="nc"><i>183</i>&nbsp;		if (viewer == null)</b>
<b class="nc"><i>184</i>&nbsp;			return;</b>
<b class="nc"><i>185</i>&nbsp;		ImageData&lt;?&gt; imageData = viewer.getImageData();</b>
<b class="nc"><i>186</i>&nbsp;		if (imageData == null)</b>
<b class="nc"><i>187</i>&nbsp;			return;</b>
<b class="nc"><i>188</i>&nbsp;		PathObjectHierarchy hierarchy = imageData.getHierarchy();</b>
<i>189</i>&nbsp;		
<i>190</i>&nbsp;		// Check if we already have a comparable annotation
<b class="nc"><i>191</i>&nbsp;		int z = viewer.getZPosition();</b>
<b class="nc"><i>192</i>&nbsp;		int t = viewer.getTPosition();</b>
<b class="nc"><i>193</i>&nbsp;		ImageRegion bounds = viewer.getServerBounds();</b>
<b class="nc"><i>194</i>&nbsp;		ROI roi = ROIs.createRectangleROI(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight(), ImagePlane.getPlane(z, t));</b>
<b class="nc"><i>195</i>&nbsp;		for (PathObject pathObject : hierarchy.getAnnotationObjects()) {</b>
<b class="nc"><i>196</i>&nbsp;			ROI r2 = pathObject.getROI();</b>
<b class="nc"><i>197</i>&nbsp;			if (r2 instanceof RectangleROI &amp;&amp; </b>
<b class="nc"><i>198</i>&nbsp;					roi.getBoundsX() == r2.getBoundsX() &amp;&amp; </b>
<b class="nc"><i>199</i>&nbsp;					roi.getBoundsY() == r2.getBoundsY() &amp;&amp; </b>
<b class="nc"><i>200</i>&nbsp;					roi.getBoundsWidth() == r2.getBoundsWidth() &amp;&amp; </b>
<b class="nc"><i>201</i>&nbsp;					roi.getBoundsHeight() == r2.getBoundsHeight() &amp;&amp;</b>
<b class="nc"><i>202</i>&nbsp;					roi.getImagePlane().equals(r2.getImagePlane())) {</b>
<b class="nc"><i>203</i>&nbsp;				logger.info(&quot;Full image annotation already exists! {}&quot;, pathObject);</b>
<b class="nc"><i>204</i>&nbsp;				viewer.setSelectedObject(pathObject);</b>
<b class="nc"><i>205</i>&nbsp;				return;</b>
<i>206</i>&nbsp;			}
<b class="nc"><i>207</i>&nbsp;		}</b>
<i>208</i>&nbsp;		
<b class="nc"><i>209</i>&nbsp;		PathObject pathObject = PathObjects.createAnnotationObject(roi);</b>
<b class="nc"><i>210</i>&nbsp;		hierarchy.addPathObject(pathObject);</b>
<b class="nc"><i>211</i>&nbsp;		viewer.setSelectedObject(pathObject);</b>
<i>212</i>&nbsp;		
<i>213</i>&nbsp;		// Log in the history
<b class="nc"><i>214</i>&nbsp;		if (z == 0 &amp;&amp; t == 0)</b>
<b class="nc"><i>215</i>&nbsp;			imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Create full image annotation&quot;, &quot;createSelectAllObject(true);&quot;));</b>
<i>216</i>&nbsp;		else
<b class="nc"><i>217</i>&nbsp;			imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Create full image annotation&quot;, String.format(&quot;createSelectAllObject(true, %d, %d);&quot;, z, t)));</b>
<b class="nc"><i>218</i>&nbsp;	}</b>
<i>219</i>&nbsp;	
<i>220</i>&nbsp;	
<i>221</i>&nbsp;	
<b class="fc"><i>222</i>&nbsp;	private static Map&lt;QuPathGUI, RigidObjectEditorCommand&gt; rigidObjectEditorMap = new WeakHashMap&lt;&gt;();</b>
<i>223</i>&nbsp;	
<i>224</i>&nbsp;	/**
<i>225</i>&nbsp;	 * Prompt to edit the selected annotation by translation and rotation.
<i>226</i>&nbsp;	 * &lt;p&gt;
<i>227</i>&nbsp;	 * Note that this method may change in future versions to be tied to a specified image data, 
<i>228</i>&nbsp;	 * rather than a specific QuPath instance.
<i>229</i>&nbsp;	 * @param qupath the QuPath instance for which the object should be edited
<i>230</i>&nbsp;	 */
<i>231</i>&nbsp;	public static void editSelectedAnnotation(QuPathGUI qupath) {		
<b class="nc"><i>232</i>&nbsp;		var editor = rigidObjectEditorMap.computeIfAbsent(qupath, q -&gt; new RigidObjectEditorCommand(q));</b>
<b class="nc"><i>233</i>&nbsp;		editor.run();</b>
<b class="nc"><i>234</i>&nbsp;	}</b>
<i>235</i>&nbsp;	
<i>236</i>&nbsp;	/**
<i>237</i>&nbsp;	 * Show a measurement table for all detection objects.
<i>238</i>&nbsp;	 * @param qupath the QuPath instance
<i>239</i>&nbsp;	 * @param imageData the image data for which to show measurements
<i>240</i>&nbsp;	 */
<i>241</i>&nbsp;	public static void showDetectionMeasurementTable(QuPathGUI qupath, ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>242</i>&nbsp;		new SummaryMeasurementTableCommand(qupath).showTable(imageData, PathDetectionObject.class);</b>
<b class="nc"><i>243</i>&nbsp;	}</b>
<i>244</i>&nbsp;	
<i>245</i>&nbsp;	/**
<i>246</i>&nbsp;	 * Show a measurement table for all cell objects.
<i>247</i>&nbsp;	 * @param qupath the QuPath instance
<i>248</i>&nbsp;	 * @param imageData the image data for which to show measurements
<i>249</i>&nbsp;	 */
<i>250</i>&nbsp;	public static void showCellMeasurementTable(QuPathGUI qupath, ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>251</i>&nbsp;		new SummaryMeasurementTableCommand(qupath).showTable(imageData, PathCellObject.class);</b>
<b class="nc"><i>252</i>&nbsp;	}</b>
<i>253</i>&nbsp;	
<i>254</i>&nbsp;	/**
<i>255</i>&nbsp;	 * Show a measurement table for all annotation objects.
<i>256</i>&nbsp;	 * @param qupath the QuPath instance
<i>257</i>&nbsp;	 * @param imageData the image data for which to show measurements
<i>258</i>&nbsp;	 */
<i>259</i>&nbsp;	public static void showAnnotationMeasurementTable(QuPathGUI qupath, ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>260</i>&nbsp;		new SummaryMeasurementTableCommand(qupath).showTable(imageData, PathAnnotationObject.class);</b>
<b class="nc"><i>261</i>&nbsp;	}</b>
<i>262</i>&nbsp;	
<i>263</i>&nbsp;	/**
<i>264</i>&nbsp;	 * Show a measurement table for all TMA core objects.
<i>265</i>&nbsp;	 * @param qupath the QuPath instance
<i>266</i>&nbsp;	 * @param imageData the image data for which to show measurements
<i>267</i>&nbsp;	 */
<i>268</i>&nbsp;	public static void showTMAMeasurementTable(QuPathGUI qupath, ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>269</i>&nbsp;		new SummaryMeasurementTableCommand(qupath).showTable(imageData, TMACoreObject.class);</b>
<b class="nc"><i>270</i>&nbsp;	}</b>
<i>271</i>&nbsp;	
<i>272</i>&nbsp;	
<i>273</i>&nbsp;	/**
<i>274</i>&nbsp;	 * Prompt to estimate stain vectors for the specified image, using any current region of interest.
<i>275</i>&nbsp;	 * @param imageData the image data for which stain vectors should be estimated
<i>276</i>&nbsp;	 */
<i>277</i>&nbsp;	public static void promptToEstimateStainVectors(ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>278</i>&nbsp;		EstimateStainVectorsCommand.promptToEstimateStainVectors(imageData);</b>
<b class="nc"><i>279</i>&nbsp;	}</b>
<i>280</i>&nbsp;	
<i>281</i>&nbsp;	
<b class="fc"><i>282</i>&nbsp;	private static DoubleProperty exportDownsample = PathPrefs.createPersistentPreference(&quot;exportRegionDownsample&quot;, 1.0);</b>
<i>283</i>&nbsp;	
<b class="fc"><i>284</i>&nbsp;	private static ImageWriter&lt;BufferedImage&gt; lastWriter = null;</b>
<i>285</i>&nbsp;
<i>286</i>&nbsp;	/**
<i>287</i>&nbsp;	 * Prompt to export the current image region selected in the viewer.
<i>288</i>&nbsp;	 * @param viewer the viewer containing the image to export
<i>289</i>&nbsp;	 * @param renderedImage if true, export the rendered (RGB) image rather than original pixel values
<i>290</i>&nbsp;	 */
<i>291</i>&nbsp;	public static void promptToExportImageRegion(QuPathViewer viewer, boolean renderedImage) {
<b class="nc"><i>292</i>&nbsp;		if (viewer == null || viewer.getServer() == null) {</b>
<b class="nc"><i>293</i>&nbsp;			Dialogs.showErrorMessage(&quot;Export image region&quot;, &quot;No viewer &amp; image selected!&quot;);</b>
<b class="nc"><i>294</i>&nbsp;			return;</b>
<i>295</i>&nbsp;		}
<i>296</i>&nbsp;		
<b class="nc"><i>297</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = viewer.getServer();</b>
<b class="nc"><i>298</i>&nbsp;		if (renderedImage)</b>
<b class="nc"><i>299</i>&nbsp;			server = RenderedImageServer.createRenderedServer(viewer);</b>
<b class="nc"><i>300</i>&nbsp;		PathObject pathObject = viewer.getSelectedObject();</b>
<b class="nc"><i>301</i>&nbsp;		ROI roi = pathObject == null ? null : pathObject.getROI();</b>
<i>302</i>&nbsp;		
<b class="nc"><i>303</i>&nbsp;		double regionWidth = roi == null ? server.getWidth() : roi.getBoundsWidth();</b>
<b class="nc"><i>304</i>&nbsp;		double regionHeight = roi == null ? server.getHeight() : roi.getBoundsHeight();</b>
<i>305</i>&nbsp;		
<i>306</i>&nbsp;		// Create a dialog
<b class="nc"><i>307</i>&nbsp;		GridPane pane = new GridPane();</b>
<b class="nc"><i>308</i>&nbsp;		int row = 0;</b>
<b class="nc"><i>309</i>&nbsp;		pane.add(new Label(&quot;Export format&quot;), 0, row);</b>
<b class="nc"><i>310</i>&nbsp;		ComboBox&lt;ImageWriter&lt;BufferedImage&gt;&gt; comboImageType = new ComboBox&lt;&gt;();</b>
<i>311</i>&nbsp;		
<b class="nc"><i>312</i>&nbsp;		Function&lt;ImageWriter&lt;BufferedImage&gt;, String&gt; fun = (ImageWriter&lt;BufferedImage&gt; writer) -&gt; writer.getName();</b>
<b class="nc"><i>313</i>&nbsp;		comboImageType.setCellFactory(p -&gt; GuiTools.createCustomListCell(fun));</b>
<b class="nc"><i>314</i>&nbsp;		comboImageType.setButtonCell(GuiTools.createCustomListCell(fun));</b>
<i>315</i>&nbsp;		
<b class="nc"><i>316</i>&nbsp;		var writers = ImageWriterTools.getCompatibleWriters(server, null);</b>
<b class="nc"><i>317</i>&nbsp;		comboImageType.getItems().setAll(writers);</b>
<b class="nc"><i>318</i>&nbsp;		comboImageType.setTooltip(new Tooltip(&quot;Choose export image format&quot;));</b>
<b class="nc"><i>319</i>&nbsp;		if (writers.contains(lastWriter))</b>
<b class="nc"><i>320</i>&nbsp;			comboImageType.getSelectionModel().select(lastWriter);</b>
<i>321</i>&nbsp;		else
<b class="nc"><i>322</i>&nbsp;			comboImageType.getSelectionModel().selectFirst();</b>
<b class="nc"><i>323</i>&nbsp;		comboImageType.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>324</i>&nbsp;		GridPane.setHgrow(comboImageType, Priority.ALWAYS);</b>
<b class="nc"><i>325</i>&nbsp;		pane.add(comboImageType, 1, row++);</b>
<i>326</i>&nbsp;		
<b class="nc"><i>327</i>&nbsp;		TextArea textArea = new TextArea();</b>
<b class="nc"><i>328</i>&nbsp;		textArea.setPrefRowCount(2);</b>
<b class="nc"><i>329</i>&nbsp;		textArea.setEditable(false);</b>
<b class="nc"><i>330</i>&nbsp;		textArea.setWrapText(true);</b>
<i>331</i>&nbsp;//		textArea.setPadding(new Insets(15, 0, 0, 0));
<b class="nc"><i>332</i>&nbsp;		comboImageType.setOnAction(e -&gt; textArea.setText(((ImageWriter&lt;BufferedImage&gt;)comboImageType.getValue()).getDetails()));			</b>
<b class="nc"><i>333</i>&nbsp;		textArea.setText(((ImageWriter&lt;BufferedImage&gt;)comboImageType.getValue()).getDetails());</b>
<b class="nc"><i>334</i>&nbsp;		pane.add(textArea, 0, row++, 2, 1);</b>
<i>335</i>&nbsp;		
<b class="nc"><i>336</i>&nbsp;		var label = new Label(&quot;Downsample factor&quot;);</b>
<b class="nc"><i>337</i>&nbsp;		pane.add(label, 0, row);</b>
<b class="nc"><i>338</i>&nbsp;		TextField tfDownsample = new TextField();</b>
<b class="nc"><i>339</i>&nbsp;		label.setLabelFor(tfDownsample);</b>
<b class="nc"><i>340</i>&nbsp;		pane.add(tfDownsample, 1, row++);</b>
<b class="nc"><i>341</i>&nbsp;		tfDownsample.setTooltip(new Tooltip(&quot;Amount to scale down image - choose 1 to export at full resolution (note: for large images this may not succeed for memory reasons)&quot;));</b>
<b class="nc"><i>342</i>&nbsp;		ObservableDoubleValue downsample = Bindings.createDoubleBinding(() -&gt; {</b>
<i>343</i>&nbsp;			try {
<b class="nc"><i>344</i>&nbsp;				return Double.parseDouble(tfDownsample.getText());</b>
<b class="nc"><i>345</i>&nbsp;			} catch (NumberFormatException e) {</b>
<b class="nc"><i>346</i>&nbsp;				return Double.NaN;</b>
<i>347</i>&nbsp;			}
<b class="nc"><i>348</i>&nbsp;		}, tfDownsample.textProperty());</b>
<i>349</i>&nbsp;		
<i>350</i>&nbsp;		// Define a sensible limit for non-pyramidal images
<b class="nc"><i>351</i>&nbsp;		long maxPixels = 10000*10000;</b>
<i>352</i>&nbsp;		
<b class="nc"><i>353</i>&nbsp;		Label labelSize = new Label();</b>
<b class="nc"><i>354</i>&nbsp;		labelSize.setMinWidth(400);</b>
<b class="nc"><i>355</i>&nbsp;		labelSize.setTextAlignment(TextAlignment.CENTER);</b>
<b class="nc"><i>356</i>&nbsp;		labelSize.setContentDisplay(ContentDisplay.CENTER);</b>
<b class="nc"><i>357</i>&nbsp;		labelSize.setAlignment(Pos.CENTER);</b>
<b class="nc"><i>358</i>&nbsp;		labelSize.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>359</i>&nbsp;		labelSize.setTooltip(new Tooltip(&quot;Estimated size of exported image&quot;));</b>
<b class="nc"><i>360</i>&nbsp;		pane.add(labelSize, 0, row++, 2, 1);</b>
<b class="nc"><i>361</i>&nbsp;		labelSize.textProperty().bind(Bindings.createStringBinding(() -&gt; {</b>
<b class="nc"><i>362</i>&nbsp;			if (!Double.isFinite(downsample.get())) {</b>
<b class="nc"><i>363</i>&nbsp;				labelSize.setStyle(&quot;-fx-text-fill: red;&quot;);</b>
<b class="nc"><i>364</i>&nbsp;				return &quot;Invalid downsample value!  Must be &gt;= 1&quot;;</b>
<i>365</i>&nbsp;			}
<i>366</i>&nbsp;			else {
<b class="nc"><i>367</i>&nbsp;				long w = (long)(regionWidth / downsample.get() + 0.5);</b>
<b class="nc"><i>368</i>&nbsp;				long h = (long)(regionHeight / downsample.get() + 0.5);</b>
<b class="nc"><i>369</i>&nbsp;				String warning = &quot;&quot;;</b>
<b class="nc"><i>370</i>&nbsp;				var writer = comboImageType.getSelectionModel().getSelectedItem();</b>
<b class="nc"><i>371</i>&nbsp;				boolean supportsPyramid = writer == null ? false : writer.supportsPyramidal();</b>
<b class="nc"><i>372</i>&nbsp;				if (!supportsPyramid &amp;&amp; w * h &gt; maxPixels) {</b>
<b class="nc"><i>373</i>&nbsp;					labelSize.setStyle(&quot;-fx-text-fill: red;&quot;);</b>
<b class="nc"><i>374</i>&nbsp;					warning = &quot; (too big!)&quot;;</b>
<b class="nc"><i>375</i>&nbsp;				} else if (w &lt; 5 || h &lt; 5) {</b>
<b class="nc"><i>376</i>&nbsp;					labelSize.setStyle(&quot;-fx-text-fill: red;&quot;);</b>
<b class="nc"><i>377</i>&nbsp;					warning = &quot; (too small!)&quot;;					</b>
<i>378</i>&nbsp;				} else
<b class="nc"><i>379</i>&nbsp;					labelSize.setStyle(null);</b>
<b class="nc"><i>380</i>&nbsp;				return String.format(&quot;Output image size: %d x %d pixels%s&quot;,</b>
<b class="nc"><i>381</i>&nbsp;						w, h, warning</b>
<i>382</i>&nbsp;						);
<i>383</i>&nbsp;			}
<b class="nc"><i>384</i>&nbsp;		}, downsample, comboImageType.getSelectionModel().selectedIndexProperty()));</b>
<i>385</i>&nbsp;		
<b class="nc"><i>386</i>&nbsp;		tfDownsample.setText(Double.toString(exportDownsample.get()));</b>
<i>387</i>&nbsp;		
<b class="nc"><i>388</i>&nbsp;		PaneTools.setMaxWidth(Double.MAX_VALUE, labelSize, textArea, tfDownsample, comboImageType);</b>
<b class="nc"><i>389</i>&nbsp;		PaneTools.setHGrowPriority(Priority.ALWAYS, labelSize, textArea, tfDownsample, comboImageType);</b>
<i>390</i>&nbsp;		
<b class="nc"><i>391</i>&nbsp;		pane.setVgap(5);</b>
<b class="nc"><i>392</i>&nbsp;		pane.setHgap(5);</b>
<i>393</i>&nbsp;		
<b class="nc"><i>394</i>&nbsp;		if (!Dialogs.showConfirmDialog(&quot;Export image region&quot;, pane))</b>
<b class="nc"><i>395</i>&nbsp;			return;</b>
<i>396</i>&nbsp;		
<b class="nc"><i>397</i>&nbsp;		var writer = comboImageType.getSelectionModel().getSelectedItem();</b>
<b class="nc"><i>398</i>&nbsp;		boolean supportsPyramid = writer == null ? false : writer.supportsPyramidal();</b>
<b class="nc"><i>399</i>&nbsp;		int w = (int)(regionWidth / downsample.get() + 0.5);</b>
<b class="nc"><i>400</i>&nbsp;		int h = (int)(regionHeight / downsample.get() + 0.5);</b>
<b class="nc"><i>401</i>&nbsp;		if (!supportsPyramid &amp;&amp; w * h &gt; maxPixels) {</b>
<b class="nc"><i>402</i>&nbsp;			Dialogs.showErrorNotification(&quot;Export image region&quot;, &quot;Requested export region too large - try selecting a smaller region, or applying a higher downsample factor&quot;);</b>
<b class="nc"><i>403</i>&nbsp;			return;</b>
<i>404</i>&nbsp;		}
<i>405</i>&nbsp;		
<b class="nc"><i>406</i>&nbsp;		if (downsample.get() &lt; 1 || !Double.isFinite(downsample.get())) {</b>
<b class="nc"><i>407</i>&nbsp;			Dialogs.showErrorMessage(&quot;Export image region&quot;, &quot;Downsample factor must be &gt;= 1!&quot;);</b>
<b class="nc"><i>408</i>&nbsp;			return;</b>
<i>409</i>&nbsp;		}
<i>410</i>&nbsp;				
<b class="nc"><i>411</i>&nbsp;		exportDownsample.set(downsample.get());</b>
<i>412</i>&nbsp;		
<i>413</i>&nbsp;		// Now that we know the output, we can create a new server to ensure it is downsampled as the necessary resolution
<b class="nc"><i>414</i>&nbsp;		if (renderedImage &amp;&amp; downsample.get() != server.getDownsampleForResolution(0))</b>
<b class="nc"><i>415</i>&nbsp;			server = new RenderedImageServer.Builder(viewer).downsamples(downsample.get()).build();</b>
<i>416</i>&nbsp;		
<i>417</i>&nbsp;//		selectedImageType.set(comboImageType.getSelectionModel().getSelectedItem());
<i>418</i>&nbsp;		
<i>419</i>&nbsp;		// Create RegionRequest
<b class="nc"><i>420</i>&nbsp;		RegionRequest request = null;</b>
<b class="nc"><i>421</i>&nbsp;		if (pathObject != null &amp;&amp; pathObject.hasROI())</b>
<b class="nc"><i>422</i>&nbsp;			request = RegionRequest.createInstance(server.getPath(), exportDownsample.get(), roi);				</b>
<i>423</i>&nbsp;
<i>424</i>&nbsp;		// Create a sensible default file name, and prompt for the actual name
<b class="nc"><i>425</i>&nbsp;		String ext = writer.getDefaultExtension();</b>
<b class="nc"><i>426</i>&nbsp;		String writerName = writer.getName();</b>
<b class="nc"><i>427</i>&nbsp;		String defaultName = GeneralTools.getNameWithoutExtension(new File(ServerTools.getDisplayableImageName(server)));</b>
<b class="nc"><i>428</i>&nbsp;		if (roi != null) {</b>
<b class="nc"><i>429</i>&nbsp;			defaultName = String.format(&quot;%s (%s, x=%d, y=%d, w=%d, h=%d)&quot;, defaultName,</b>
<b class="nc"><i>430</i>&nbsp;					GeneralTools.formatNumber(request.getDownsample(), 2),</b>
<b class="nc"><i>431</i>&nbsp;					request.getX(), request.getY(), request.getWidth(), request.getHeight());</b>
<i>432</i>&nbsp;		}
<b class="nc"><i>433</i>&nbsp;		File fileOutput = Dialogs.promptToSaveFile(&quot;Export image region&quot;, null, defaultName, writerName, ext);</b>
<b class="nc"><i>434</i>&nbsp;		if (fileOutput == null)</b>
<b class="nc"><i>435</i>&nbsp;			return;</b>
<i>436</i>&nbsp;		
<i>437</i>&nbsp;		try {
<b class="nc"><i>438</i>&nbsp;			if (request == null) {</b>
<b class="nc"><i>439</i>&nbsp;				if (exportDownsample.get() == 1.0)</b>
<b class="nc"><i>440</i>&nbsp;					writer.writeImage(server, fileOutput.getAbsolutePath());</b>
<i>441</i>&nbsp;				else
<b class="nc"><i>442</i>&nbsp;					writer.writeImage(ImageServers.pyramidalize(server, exportDownsample.get()), fileOutput.getAbsolutePath());</b>
<i>443</i>&nbsp;			} else
<b class="nc"><i>444</i>&nbsp;				writer.writeImage(server, request, fileOutput.getAbsolutePath());</b>
<b class="nc"><i>445</i>&nbsp;			lastWriter = writer;</b>
<b class="nc"><i>446</i>&nbsp;		} catch (IOException e) {</b>
<b class="nc"><i>447</i>&nbsp;			Dialogs.showErrorMessage(&quot;Export region&quot;, e);</b>
<b class="nc"><i>448</i>&nbsp;		}</b>
<b class="nc"><i>449</i>&nbsp;	}</b>
<i>450</i>&nbsp;	
<i>451</i>&nbsp;	
<i>452</i>&nbsp;	/**
<i>453</i>&nbsp;	 * Show a dialog displaying the extensions installed for a specified QuPath instance.
<i>454</i>&nbsp;	 * @param qupath the QuPath instance
<i>455</i>&nbsp;	 */
<i>456</i>&nbsp;	public static void showInstalledExtensions(final QuPathGUI qupath) {
<b class="nc"><i>457</i>&nbsp;		ShowInstalledExtensionsCommand.showInstalledExtensions(qupath);</b>
<b class="nc"><i>458</i>&nbsp;	}</b>
<i>459</i>&nbsp;	
<i>460</i>&nbsp;	
<i>461</i>&nbsp;	/**
<i>462</i>&nbsp;	 * Show a simple dialog for viewing (and optionally removing) detection measurements.
<i>463</i>&nbsp;	 * @param qupath
<i>464</i>&nbsp;	 * @param imageData
<i>465</i>&nbsp;	 */
<i>466</i>&nbsp;	public static void showDetectionMeasurementManager(QuPathGUI qupath, ImageData&lt;?&gt; imageData) {
<b class="nc"><i>467</i>&nbsp;		MeasurementManager.showDetectionMeasurementManager(qupath, imageData);</b>
<b class="nc"><i>468</i>&nbsp;	}</b>
<i>469</i>&nbsp;	
<i>470</i>&nbsp;	
<i>471</i>&nbsp;	/**
<i>472</i>&nbsp;	 * Reset TMA metadata, if available.
<i>473</i>&nbsp;	 * @param imageData
<i>474</i>&nbsp;	 * @return true if changes were made, false otherwise
<i>475</i>&nbsp;	 */
<i>476</i>&nbsp;	public static boolean resetTMAMetadata(ImageData&lt;?&gt; imageData) {
<b class="nc"><i>477</i>&nbsp;		if (imageData == null || imageData.getHierarchy().getTMAGrid() == null) {</b>
<b class="nc"><i>478</i>&nbsp;			logger.warn(&quot;No TMA grid available!&quot;);</b>
<b class="nc"><i>479</i>&nbsp;			return false;</b>
<i>480</i>&nbsp;		}
<b class="nc"><i>481</i>&nbsp;		QP.resetTMAMetadata(imageData.getHierarchy(), true);</b>
<b class="nc"><i>482</i>&nbsp;		imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Reset TMA metadata&quot;, &quot;resetTMAMetadata(true);&quot;));		</b>
<b class="nc"><i>483</i>&nbsp;		return true;</b>
<i>484</i>&nbsp;	}
<i>485</i>&nbsp;	
<i>486</i>&nbsp;	/**
<i>487</i>&nbsp;	 * Create a command that generates a persistent single dialog on demand.
<i>488</i>&nbsp;	 * A reference to the dialog can be retained, so that if the command is called again 
<i>489</i>&nbsp;	 * either the original dialog is shown and/or brought to the front.
<i>490</i>&nbsp;	 * @param supplier supplier function to generate the dialog on demand
<i>491</i>&nbsp;	 * @return the action
<i>492</i>&nbsp;	 */
<i>493</i>&nbsp;	public static Action createSingleStageAction(Supplier&lt;Stage&gt; supplier) {
<b class="fc"><i>494</i>&nbsp;		var command = new SingleStageCommand(supplier);</b>
<b class="fc"><i>495</i>&nbsp;		return new Action(e -&gt; command.show());</b>
<i>496</i>&nbsp;	}
<i>497</i>&nbsp;	
<i>498</i>&nbsp;	static class SingleStageCommand {
<i>499</i>&nbsp;		
<i>500</i>&nbsp;		private Stage stage;
<i>501</i>&nbsp;		private Supplier&lt;Stage&gt; supplier;
<i>502</i>&nbsp;		
<b class="fc"><i>503</i>&nbsp;		SingleStageCommand(Supplier&lt;Stage&gt; supplier) {</b>
<b class="fc"><i>504</i>&nbsp;			this.supplier = supplier;</b>
<b class="fc"><i>505</i>&nbsp;		}</b>
<i>506</i>&nbsp;		
<i>507</i>&nbsp;		void show() {
<b class="nc"><i>508</i>&nbsp;			if (stage == null) {</b>
<b class="nc"><i>509</i>&nbsp;				stage = supplier.get();</b>
<i>510</i>&nbsp;			}
<b class="nc"><i>511</i>&nbsp;			if (stage.isShowing())</b>
<b class="nc"><i>512</i>&nbsp;				stage.toFront();</b>
<i>513</i>&nbsp;			else
<b class="nc"><i>514</i>&nbsp;				stage.show();</b>
<b class="nc"><i>515</i>&nbsp;		}</b>
<i>516</i>&nbsp;		
<i>517</i>&nbsp;	}
<i>518</i>&nbsp;	
<i>519</i>&nbsp;	/**
<i>520</i>&nbsp;	 * Create a dialog for displaying measurement maps.
<i>521</i>&nbsp;	 * @param qupath the {@link QuPathGUI} instance to which the maps refer
<i>522</i>&nbsp;	 * @return a measurement map dialog
<i>523</i>&nbsp;	 */
<i>524</i>&nbsp;	public static Stage createMeasurementMapDialog(QuPathGUI qupath) {
<b class="nc"><i>525</i>&nbsp;		var dialog = new Stage();</b>
<b class="nc"><i>526</i>&nbsp;		if (qupath != null)</b>
<b class="nc"><i>527</i>&nbsp;			dialog.initOwner(qupath.getStage());</b>
<b class="nc"><i>528</i>&nbsp;		dialog.setTitle(&quot;Measurement maps&quot;);</b>
<i>529</i>&nbsp;		
<b class="nc"><i>530</i>&nbsp;		var panel = new MeasurementMapPane(qupath);</b>
<b class="nc"><i>531</i>&nbsp;		BorderPane pane = new BorderPane();</b>
<b class="nc"><i>532</i>&nbsp;		pane.setCenter(panel.getPane());</b>
<i>533</i>&nbsp;		
<b class="nc"><i>534</i>&nbsp;		Scene scene = new Scene(pane, 300, 400);</b>
<b class="nc"><i>535</i>&nbsp;		dialog.setScene(scene);</b>
<b class="nc"><i>536</i>&nbsp;		dialog.setMinWidth(300);</b>
<b class="nc"><i>537</i>&nbsp;		dialog.setMinHeight(400);</b>
<i>538</i>&nbsp;//		pane.setMinSize(300, 400);
<i>539</i>&nbsp;//		dialog.setResizable(false);
<i>540</i>&nbsp;		
<b class="nc"><i>541</i>&nbsp;		dialog.setOnCloseRequest(e -&gt; {</b>
<b class="nc"><i>542</i>&nbsp;			OverlayOptions overlayOptions = qupath.getOverlayOptions();</b>
<b class="nc"><i>543</i>&nbsp;			if (overlayOptions != null)</b>
<b class="nc"><i>544</i>&nbsp;				overlayOptions.resetMeasurementMapper();</b>
<b class="nc"><i>545</i>&nbsp;			dialog.hide();</b>
<b class="nc"><i>546</i>&nbsp;		});</b>
<b class="nc"><i>547</i>&nbsp;		dialog.setOnShowing(e -&gt; {</b>
<b class="nc"><i>548</i>&nbsp;			panel.updateMeasurements();</b>
<b class="nc"><i>549</i>&nbsp;		});</b>
<b class="nc"><i>550</i>&nbsp;		return dialog;</b>
<i>551</i>&nbsp;	}
<i>552</i>&nbsp;	
<i>553</i>&nbsp;	
<i>554</i>&nbsp;	/**
<i>555</i>&nbsp;	 * Show a script interpreter window for a Qupath instance.
<i>556</i>&nbsp;	 * @param qupath the QuPath instance
<i>557</i>&nbsp;	 */
<i>558</i>&nbsp;	public static void showScriptInterpreter(QuPathGUI qupath) {
<b class="nc"><i>559</i>&nbsp;		var scriptInterpreter = new ScriptInterpreter(qupath, QuPathGUI.getExtensionClassLoader());</b>
<b class="nc"><i>560</i>&nbsp;		scriptInterpreter.getStage().initOwner(qupath.getStage());</b>
<b class="nc"><i>561</i>&nbsp;		scriptInterpreter.getStage().show();</b>
<b class="nc"><i>562</i>&nbsp;	}</b>
<i>563</i>&nbsp;	
<i>564</i>&nbsp;	
<i>565</i>&nbsp;	/**
<i>566</i>&nbsp;	 * Create and show a new input display dialog.
<i>567</i>&nbsp;	 * &lt;p&gt;
<i>568</i>&nbsp;	 * This makes input such as key-presses and mouse button presses visible on screen, and is therefore
<i>569</i>&nbsp;	 *  useful for demos and tutorials where shortcut keys are used.
<i>570</i>&nbsp;	 *  
<i>571</i>&nbsp;	 * @param qupath the QuPath instance
<i>572</i>&nbsp;	 */
<i>573</i>&nbsp;	public static void showInputDisplay(QuPathGUI qupath) {
<i>574</i>&nbsp;		try {
<b class="nc"><i>575</i>&nbsp;			new InputDisplayDialog(qupath.getStage()).show();</b>
<b class="nc"><i>576</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>577</i>&nbsp;			Dialogs.showErrorMessage(&quot;Error showing input display&quot;, e);</b>
<b class="nc"><i>578</i>&nbsp;		}</b>
<b class="nc"><i>579</i>&nbsp;	}</b>
<i>580</i>&nbsp;	
<i>581</i>&nbsp;	/**
<i>582</i>&nbsp;	 * Create a window summarizing license information for QuPath and its third party dependencies.
<i>583</i>&nbsp;	 * @param qupath the current QuPath instance
<i>584</i>&nbsp;	 * @return a window to display license information
<i>585</i>&nbsp;	 */
<i>586</i>&nbsp;	public static Stage createLicensesWindow(QuPathGUI qupath) {
<b class="nc"><i>587</i>&nbsp;		return ShowLicensesCommand.createLicensesDialog(qupath);</b>
<i>588</i>&nbsp;	}
<i>589</i>&nbsp;	
<i>590</i>&nbsp;	
<i>591</i>&nbsp;	/**
<i>592</i>&nbsp;	 * Create a window summarizing key system information relevant for QuPath.
<i>593</i>&nbsp;	 * @param qupath the current QuPath instance
<i>594</i>&nbsp;	 * @return a window to display license information
<i>595</i>&nbsp;	 */
<i>596</i>&nbsp;	public static Stage createShowSystemInfoDialog(QuPathGUI qupath) {
<b class="nc"><i>597</i>&nbsp;		return ShowSystemInfoCommand.createShowSystemInfoDialog(qupath);</b>
<i>598</i>&nbsp;	}
<i>599</i>&nbsp;	
<i>600</i>&nbsp;	
<i>601</i>&nbsp;	/**
<i>602</i>&nbsp;	 * Show a dialog to adjust QuPath preferences.
<i>603</i>&nbsp;	 * @param qupath the QuPath instance
<i>604</i>&nbsp;	 * @return window to use to display preferences
<i>605</i>&nbsp;	 */
<i>606</i>&nbsp;	public static Stage createPreferencesDialog(QuPathGUI qupath) {
<i>607</i>&nbsp;		
<b class="nc"><i>608</i>&nbsp;		var panel = qupath.getPreferencePane();</b>
<i>609</i>&nbsp;		
<b class="nc"><i>610</i>&nbsp;		var dialog = new Stage();</b>
<b class="nc"><i>611</i>&nbsp;		dialog.initOwner(qupath.getStage());</b>
<i>612</i>&nbsp;//			dialog.initModality(Modality.APPLICATION_MODAL);
<b class="nc"><i>613</i>&nbsp;		dialog.setTitle(&quot;Preferences&quot;);</b>
<i>614</i>&nbsp;		
<b class="nc"><i>615</i>&nbsp;		Button btnExport = new Button(&quot;Export&quot;);</b>
<b class="nc"><i>616</i>&nbsp;		btnExport.setOnAction(e -&gt; exportPreferences(dialog));</b>
<b class="nc"><i>617</i>&nbsp;		btnExport.setMaxWidth(Double.MAX_VALUE);</b>
<i>618</i>&nbsp;
<b class="nc"><i>619</i>&nbsp;		Button btnImport = new Button(&quot;Import&quot;);</b>
<b class="nc"><i>620</i>&nbsp;		btnImport.setOnAction(e -&gt; importPreferences(dialog));</b>
<b class="nc"><i>621</i>&nbsp;		btnImport.setMaxWidth(Double.MAX_VALUE);</b>
<i>622</i>&nbsp;		
<b class="nc"><i>623</i>&nbsp;		Button btnReset = new Button(&quot;Reset&quot;);</b>
<b class="nc"><i>624</i>&nbsp;		btnReset.setOnAction(e -&gt; PathPrefs.resetPreferences());</b>
<b class="nc"><i>625</i>&nbsp;		btnReset.setMaxWidth(Double.MAX_VALUE);</b>
<i>626</i>&nbsp;		
<b class="nc"><i>627</i>&nbsp;		GridPane paneImportExport = new GridPane();</b>
<b class="nc"><i>628</i>&nbsp;		paneImportExport.addRow(0, btnImport, btnExport, btnReset);</b>
<b class="nc"><i>629</i>&nbsp;		PaneTools.setHGrowPriority(Priority.ALWAYS, btnImport, btnExport, btnReset);</b>
<b class="nc"><i>630</i>&nbsp;		paneImportExport.setMaxWidth(Double.MAX_VALUE);</b>
<i>631</i>&nbsp;
<i>632</i>&nbsp;//			Button btnClose = new Button(&quot;Close&quot;);
<i>633</i>&nbsp;//			btnClose.setOnAction(e -&gt; {
<i>634</i>&nbsp;//				dialog.hide();
<i>635</i>&nbsp;//			});
<i>636</i>&nbsp;		
<b class="nc"><i>637</i>&nbsp;		BorderPane pane = new BorderPane();</b>
<b class="nc"><i>638</i>&nbsp;		pane.setCenter(panel.getPropertySheet());</b>
<b class="nc"><i>639</i>&nbsp;		pane.setBottom(paneImportExport);</b>
<b class="nc"><i>640</i>&nbsp;		if (qupath != null &amp;&amp; qupath.getStage() != null) {</b>
<b class="nc"><i>641</i>&nbsp;			pane.setPrefHeight(Math.round(Math.max(300, qupath.getStage().getHeight()*0.75)));</b>
<i>642</i>&nbsp;		}
<b class="nc"><i>643</i>&nbsp;		paneImportExport.prefWidthProperty().bind(pane.widthProperty());</b>
<i>644</i>&nbsp;//			btnClose.prefWidthProperty().bind(pane.widthProperty());
<b class="nc"><i>645</i>&nbsp;		dialog.setScene(new Scene(pane));</b>
<b class="nc"><i>646</i>&nbsp;		dialog.setMinWidth(300);</b>
<b class="nc"><i>647</i>&nbsp;		dialog.setMinHeight(300);</b>
<i>648</i>&nbsp;		
<b class="nc"><i>649</i>&nbsp;		return dialog;</b>
<i>650</i>&nbsp;	}
<i>651</i>&nbsp;
<i>652</i>&nbsp;	private static boolean exportPreferences(Stage parent) {
<b class="nc"><i>653</i>&nbsp;		var file = Dialogs.getChooser(parent).promptToSaveFile(</b>
<i>654</i>&nbsp;				&quot;Export preferences&quot;, null, null, &quot;Preferences file&quot;, &quot;xml&quot;);
<b class="nc"><i>655</i>&nbsp;		if (file != null) {</b>
<b class="nc"><i>656</i>&nbsp;			try (var stream = Files.newOutputStream(file.toPath())) {</b>
<b class="nc"><i>657</i>&nbsp;				logger.info(&quot;Exporting preferences to {}&quot;, file.getAbsolutePath());</b>
<b class="nc"><i>658</i>&nbsp;				PathPrefs.exportPreferences(stream);</b>
<b class="nc"><i>659</i>&nbsp;				return true;</b>
<b class="nc"><i>660</i>&nbsp;			} catch (Exception e) {</b>
<b class="nc"><i>661</i>&nbsp;				Dialogs.showErrorMessage(&quot;Import preferences&quot;, e);</b>
<i>662</i>&nbsp;			}
<i>663</i>&nbsp;		}
<b class="nc"><i>664</i>&nbsp;		return false;</b>
<i>665</i>&nbsp;	}
<i>666</i>&nbsp;	
<i>667</i>&nbsp;	private static boolean importPreferences(Stage parent) {
<b class="nc"><i>668</i>&nbsp;		var file = Dialogs.getChooser(parent).promptForFile(</b>
<i>669</i>&nbsp;				&quot;Import preferences&quot;, null, &quot;Preferences file&quot;, &quot;xml&quot;);
<b class="nc"><i>670</i>&nbsp;		if (file != null) {</b>
<b class="nc"><i>671</i>&nbsp;			try (var stream = Files.newInputStream(file.toPath())) {</b>
<b class="nc"><i>672</i>&nbsp;				logger.info(&quot;Importing preferences from {}&quot;, file.getAbsolutePath());</b>
<b class="nc"><i>673</i>&nbsp;				PathPrefs.importPreferences(stream);</b>
<b class="nc"><i>674</i>&nbsp;				Dialogs.showMessageDialog(&quot;Import preferences&quot;, </b>
<i>675</i>&nbsp;						&quot;Preferences have been imported - please restart QuPath to see the changes.&quot;);
<b class="nc"><i>676</i>&nbsp;				return true;</b>
<b class="nc"><i>677</i>&nbsp;			} catch (Exception e) {</b>
<b class="nc"><i>678</i>&nbsp;				Dialogs.showErrorMessage(&quot;Import preferences&quot;, e);</b>
<i>679</i>&nbsp;			}
<i>680</i>&nbsp;		}
<b class="nc"><i>681</i>&nbsp;		return false;</b>
<i>682</i>&nbsp;	}
<i>683</i>&nbsp;	
<i>684</i>&nbsp;	
<i>685</i>&nbsp;	/**
<i>686</i>&nbsp;	 * Create a dialog for rotating the image in the current viewer (for display only.
<i>687</i>&nbsp;	 * @param qupath the {@link QuPathGUI} instance
<i>688</i>&nbsp;	 * @return a rotate image dialog
<i>689</i>&nbsp;	 */
<i>690</i>&nbsp;	public static Stage createRotateImageDialog(QuPathGUI qupath) {
<b class="nc"><i>691</i>&nbsp;		var dialog = new Stage();</b>
<b class="nc"><i>692</i>&nbsp;		dialog.initOwner(qupath.getStage());</b>
<b class="nc"><i>693</i>&nbsp;		dialog.setTitle(&quot;Rotate view&quot;);</b>
<i>694</i>&nbsp;
<b class="nc"><i>695</i>&nbsp;		BorderPane pane = new BorderPane();</b>
<i>696</i>&nbsp;
<b class="nc"><i>697</i>&nbsp;		final Label label = new Label(&quot;0 degrees&quot;);</b>
<b class="nc"><i>698</i>&nbsp;		label.setTextAlignment(TextAlignment.CENTER);</b>
<b class="nc"><i>699</i>&nbsp;		QuPathViewer viewerTemp = qupath.getViewer();</b>
<b class="nc"><i>700</i>&nbsp;		var slider = new Slider(-90, 90, viewerTemp == null ? 0 : Math.toDegrees(viewerTemp.getRotation()));</b>
<b class="nc"><i>701</i>&nbsp;		slider.setMajorTickUnit(10);</b>
<b class="nc"><i>702</i>&nbsp;		slider.setMinorTickCount(5);</b>
<b class="nc"><i>703</i>&nbsp;		slider.setShowTickMarks(true);</b>
<b class="nc"><i>704</i>&nbsp;		slider.valueProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>705</i>&nbsp;			QuPathViewer viewer = qupath.getViewer();</b>
<b class="nc"><i>706</i>&nbsp;			if (viewer == null)</b>
<b class="nc"><i>707</i>&nbsp;				return;</b>
<b class="nc"><i>708</i>&nbsp;			double rotation = slider.getValue();</b>
<b class="nc"><i>709</i>&nbsp;			label.setText(String.format(&quot;%.1f degrees&quot;, rotation));</b>
<b class="nc"><i>710</i>&nbsp;			viewer.setRotation(Math.toRadians(rotation));</b>
<b class="nc"><i>711</i>&nbsp;		});</b>
<i>712</i>&nbsp;
<b class="nc"><i>713</i>&nbsp;		Button btnReset = new Button(&quot;Reset&quot;);</b>
<b class="nc"><i>714</i>&nbsp;		btnReset.setOnAction(e -&gt; slider.setValue(0));</b>
<i>715</i>&nbsp;
<b class="nc"><i>716</i>&nbsp;		Button btnTMAAlign = new Button(&quot;Straighten TMA&quot;);</b>
<b class="nc"><i>717</i>&nbsp;		btnTMAAlign.setOnAction(e -&gt; {</b>
<i>718</i>&nbsp;
<b class="nc"><i>719</i>&nbsp;			QuPathViewer viewer = qupath.getViewer();</b>
<b class="nc"><i>720</i>&nbsp;			if (viewer == null)</b>
<b class="nc"><i>721</i>&nbsp;				return;</b>
<b class="nc"><i>722</i>&nbsp;			TMAGrid tmaGrid = viewer.getHierarchy().getTMAGrid();</b>
<b class="nc"><i>723</i>&nbsp;			if (tmaGrid == null || tmaGrid.getGridWidth() &lt; 2)</b>
<b class="nc"><i>724</i>&nbsp;				return;</b>
<i>725</i>&nbsp;			// Determine predominant angle
<b class="nc"><i>726</i>&nbsp;			List&lt;Double&gt; angles = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>727</i>&nbsp;			for (int y = 0; y &lt; tmaGrid.getGridHeight(); y++) {</b>
<b class="nc"><i>728</i>&nbsp;				for (int x = 1; x &lt; tmaGrid.getGridWidth(); x++) {</b>
<b class="nc"><i>729</i>&nbsp;					TMACoreObject core1 = tmaGrid.getTMACore(y, x-1);</b>
<b class="nc"><i>730</i>&nbsp;					TMACoreObject core2 = tmaGrid.getTMACore(y, x);</b>
<b class="nc"><i>731</i>&nbsp;					if (core1.isMissing() || core2.isMissing())</b>
<b class="nc"><i>732</i>&nbsp;						continue;</b>
<b class="nc"><i>733</i>&nbsp;					ROI roi1 = core1.getROI();</b>
<b class="nc"><i>734</i>&nbsp;					ROI roi2 = core2.getROI();</b>
<b class="nc"><i>735</i>&nbsp;					double angle = Double.NaN;</b>
<b class="nc"><i>736</i>&nbsp;					if (roi1 != null &amp;&amp; roi2 != null) {</b>
<b class="nc"><i>737</i>&nbsp;						double dx = roi2.getCentroidX() - roi1.getCentroidX();</b>
<b class="nc"><i>738</i>&nbsp;						double dy = roi2.getCentroidY() - roi1.getCentroidY();</b>
<b class="nc"><i>739</i>&nbsp;						angle = Math.atan2(dy, dx);</b>
<i>740</i>&nbsp;						//								angle = Math.atan(dy / dx);
<i>741</i>&nbsp;					}
<b class="nc"><i>742</i>&nbsp;					if (!Double.isNaN(angle)) {</b>
<b class="nc"><i>743</i>&nbsp;						logger.debug(&quot;Angle :&quot; + angle);</b>
<b class="nc"><i>744</i>&nbsp;						angles.add(angle);</b>
<i>745</i>&nbsp;					}
<i>746</i>&nbsp;				}
<i>747</i>&nbsp;			}
<i>748</i>&nbsp;			// Compute median angle
<b class="nc"><i>749</i>&nbsp;			if (angles.isEmpty())</b>
<b class="nc"><i>750</i>&nbsp;				return;</b>
<b class="nc"><i>751</i>&nbsp;			Collections.sort(angles);</b>
<b class="nc"><i>752</i>&nbsp;			double angleMedian = Math.toDegrees(angles.get(angles.size()/2));</b>
<b class="nc"><i>753</i>&nbsp;			slider.setValue(angleMedian);</b>
<i>754</i>&nbsp;
<b class="nc"><i>755</i>&nbsp;			logger.debug(&quot;Median angle: &quot; + angleMedian);</b>
<i>756</i>&nbsp;
<b class="nc"><i>757</i>&nbsp;		});</b>
<i>758</i>&nbsp;
<b class="nc"><i>759</i>&nbsp;		GridPane panelButtons = PaneTools.createColumnGridControls(</b>
<i>760</i>&nbsp;				btnReset,
<i>761</i>&nbsp;				btnTMAAlign
<i>762</i>&nbsp;				);
<b class="nc"><i>763</i>&nbsp;		panelButtons.setPrefWidth(300);</b>
<i>764</i>&nbsp;		
<b class="nc"><i>765</i>&nbsp;		slider.setPadding(new Insets(5, 0, 10, 0));</b>
<i>766</i>&nbsp;
<b class="nc"><i>767</i>&nbsp;		pane.setTop(label);</b>
<b class="nc"><i>768</i>&nbsp;		pane.setCenter(slider);</b>
<b class="nc"><i>769</i>&nbsp;		pane.setBottom(panelButtons);</b>
<b class="nc"><i>770</i>&nbsp;		pane.setPadding(new Insets(10, 10, 10, 10));</b>
<i>771</i>&nbsp;
<b class="nc"><i>772</i>&nbsp;		Scene scene = new Scene(pane);</b>
<b class="nc"><i>773</i>&nbsp;		dialog.setScene(scene);</b>
<b class="nc"><i>774</i>&nbsp;		dialog.setResizable(false);</b>
<b class="nc"><i>775</i>&nbsp;		return dialog;</b>
<i>776</i>&nbsp;	}
<i>777</i>&nbsp;	
<i>778</i>&nbsp;	
<i>779</i>&nbsp;	/**
<i>780</i>&nbsp;	 * Create a zoom in/out command action.
<i>781</i>&nbsp;	 * @param qupath QuPath instance
<i>782</i>&nbsp;	 * @param zoomAmount relative amount to zoom in (positive) or out (negative). Suggested value is +/-10.
<i>783</i>&nbsp;	 * @return
<i>784</i>&nbsp;	 */
<i>785</i>&nbsp;	public static Action createZoomCommand(QuPathGUI qupath, int zoomAmount) {
<b class="fc"><i>786</i>&nbsp;		var command = new ZoomCommand(qupath.viewerProperty(), zoomAmount);</b>
<b class="fc"><i>787</i>&nbsp;		return ActionTools.createAction(command);</b>
<i>788</i>&nbsp;	}
<i>789</i>&nbsp;	
<i>790</i>&nbsp;	
<i>791</i>&nbsp;	/**
<i>792</i>&nbsp;	 * Create a stage to prompt the user to specify an annotation to add.
<i>793</i>&nbsp;	 * @param qupath
<i>794</i>&nbsp;	 * @return 
<i>795</i>&nbsp;	 */
<i>796</i>&nbsp;	public static Stage createSpecifyAnnotationDialog(QuPathGUI qupath) {
<b class="nc"><i>797</i>&nbsp;		SpecifyAnnotationCommand pane = new SpecifyAnnotationCommand(qupath);</b>
<b class="nc"><i>798</i>&nbsp;		var stage = new Stage();</b>
<b class="nc"><i>799</i>&nbsp;		var scene = new Scene(pane.getPane());</b>
<b class="nc"><i>800</i>&nbsp;		stage.setScene(scene);</b>
<b class="nc"><i>801</i>&nbsp;		stage.setWidth(300);</b>
<b class="nc"><i>802</i>&nbsp;		stage.setTitle(&quot;Specify annotation&quot;);</b>
<b class="nc"><i>803</i>&nbsp;		stage.initOwner(qupath.getStage());</b>
<b class="nc"><i>804</i>&nbsp;		return stage;</b>
<i>805</i>&nbsp;	}
<i>806</i>&nbsp;	
<i>807</i>&nbsp;	
<i>808</i>&nbsp;	/**
<i>809</i>&nbsp;	 * Prompt to save the specified {@link ImageData}.
<i>810</i>&nbsp;	 * @param qupath
<i>811</i>&nbsp;	 * @param imageData
<i>812</i>&nbsp;	 * @param overwriteExisting
<i>813</i>&nbsp;	 * @return
<i>814</i>&nbsp;	 */
<i>815</i>&nbsp;	public static boolean promptToSaveImageData(QuPathGUI qupath, ImageData&lt;BufferedImage&gt; imageData, boolean overwriteExisting) {
<b class="nc"><i>816</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>817</i>&nbsp;			Dialogs.showNoImageError(&quot;Serialization error&quot;);</b>
<b class="nc"><i>818</i>&nbsp;			return false;</b>
<i>819</i>&nbsp;		}
<i>820</i>&nbsp;		try {
<b class="nc"><i>821</i>&nbsp;			var project = qupath.getProject();</b>
<b class="nc"><i>822</i>&nbsp;			var entry = project == null ? null : project.getEntry(imageData);</b>
<b class="nc"><i>823</i>&nbsp;			if (entry != null) {</b>
<b class="nc"><i>824</i>&nbsp;				if (overwriteExisting || Dialogs.showConfirmDialog(&quot;Save changes&quot;, &quot;Save changes to &quot; + entry.getImageName() + &quot;?&quot;)) {</b>
<b class="nc"><i>825</i>&nbsp;					entry.saveImageData(imageData);</b>
<b class="nc"><i>826</i>&nbsp;					return true;</b>
<i>827</i>&nbsp;				} else
<b class="nc"><i>828</i>&nbsp;					return false;</b>
<i>829</i>&nbsp;			} else {
<b class="nc"><i>830</i>&nbsp;				String lastSavedPath = imageData.getLastSavedPath();</b>
<b class="nc"><i>831</i>&nbsp;				File file = null;</b>
<b class="nc"><i>832</i>&nbsp;				if (lastSavedPath != null) {</b>
<i>833</i>&nbsp;					// Use the last path, if required
<b class="nc"><i>834</i>&nbsp;					if (overwriteExisting)</b>
<b class="nc"><i>835</i>&nbsp;						file = new File(lastSavedPath);</b>
<b class="nc"><i>836</i>&nbsp;					if (file == null || !file.isFile()) {</b>
<b class="nc"><i>837</i>&nbsp;						File fileDefault = new File(lastSavedPath);</b>
<b class="nc"><i>838</i>&nbsp;						file = Dialogs.promptToSaveFile(null, fileDefault.getParentFile(), fileDefault.getName(), &quot;QuPath Serialized Data&quot;, PathPrefs.getSerializationExtension());</b>
<b class="nc"><i>839</i>&nbsp;					}</b>
<i>840</i>&nbsp;				}
<i>841</i>&nbsp;				else {
<b class="nc"><i>842</i>&nbsp;					ImageServer&lt;?&gt; server = imageData.getServer();</b>
<b class="nc"><i>843</i>&nbsp;					String name = ServerTools.getDisplayableImageName(server);</b>
<b class="nc"><i>844</i>&nbsp;					if (name.contains(&quot;.&quot;)) {</b>
<i>845</i>&nbsp;						try {
<b class="nc"><i>846</i>&nbsp;							name = GeneralTools.getNameWithoutExtension(new File(name));</b>
<b class="nc"><i>847</i>&nbsp;						} catch (Exception e) {}</b>
<i>848</i>&nbsp;					}
<b class="nc"><i>849</i>&nbsp;					file = Dialogs.promptToSaveFile(null, null, name, &quot;QuPath Serialized Data&quot;, PathPrefs.getSerializationExtension());</b>
<i>850</i>&nbsp;				}
<b class="nc"><i>851</i>&nbsp;				if (file == null)</b>
<b class="nc"><i>852</i>&nbsp;					return false;</b>
<b class="nc"><i>853</i>&nbsp;				PathIO.writeImageData(file, imageData);</b>
<b class="nc"><i>854</i>&nbsp;				return true;</b>
<i>855</i>&nbsp;			}
<b class="nc"><i>856</i>&nbsp;		} catch (IOException e) {</b>
<b class="nc"><i>857</i>&nbsp;			Dialogs.showErrorMessage(&quot;Save ImageData&quot;, e);</b>
<b class="nc"><i>858</i>&nbsp;			return false;</b>
<i>859</i>&nbsp;		}
<i>860</i>&nbsp;	}
<i>861</i>&nbsp;	
<i>862</i>&nbsp;	
<i>863</i>&nbsp;	// TODO: Make the extension modifiable
<b class="fc"><i>864</i>&nbsp;	private static StringProperty defaultScreenshotExtension = PathPrefs.createPersistentPreference(&quot;defaultScreenshotExtension&quot;, &quot;png&quot;);</b>
<i>865</i>&nbsp;	
<i>866</i>&nbsp;	
<i>867</i>&nbsp;	/**
<i>868</i>&nbsp;	 * Save an image snapshot, prompting the user to select the output file.
<i>869</i>&nbsp;	 * @param qupath the {@link QuPathGUI} instance to snapshot
<i>870</i>&nbsp;	 * @param type the snapshot type
<i>871</i>&nbsp;	 * @return true if a snapshot was saved, false otherwise
<i>872</i>&nbsp;	 */
<i>873</i>&nbsp;	public static boolean saveSnapshot(QuPathGUI qupath, GuiTools.SnapshotType type) {
<b class="nc"><i>874</i>&nbsp;		BufferedImage img = GuiTools.makeSnapshot(qupath, type);			</b>
<i>875</i>&nbsp;		
<b class="nc"><i>876</i>&nbsp;		String ext = defaultScreenshotExtension.get();</b>
<b class="nc"><i>877</i>&nbsp;		List&lt;ImageWriter&lt;BufferedImage&gt;&gt; compatibleWriters = ImageWriterTools.getCompatibleWriters(BufferedImage.class, ext);</b>
<b class="nc"><i>878</i>&nbsp;		if (compatibleWriters.isEmpty()) {</b>
<b class="nc"><i>879</i>&nbsp;			logger.error(&quot;No compatible image writers found for extension: &quot; + ext);</b>
<b class="nc"><i>880</i>&nbsp;			return false;</b>
<i>881</i>&nbsp;		}
<i>882</i>&nbsp;		
<b class="nc"><i>883</i>&nbsp;		File fileOutput = Dialogs.promptToSaveFile(null, null, null, ext, ext);</b>
<b class="nc"><i>884</i>&nbsp;		if (fileOutput == null)</b>
<b class="nc"><i>885</i>&nbsp;			return false;</b>
<i>886</i>&nbsp;		
<i>887</i>&nbsp;		// Loop through the writers and stop when we are successful
<b class="nc"><i>888</i>&nbsp;		for (var writer : compatibleWriters) {</b>
<i>889</i>&nbsp;			try {
<b class="nc"><i>890</i>&nbsp;				writer.writeImage(img, fileOutput.getAbsolutePath());</b>
<b class="nc"><i>891</i>&nbsp;				return true;</b>
<b class="nc"><i>892</i>&nbsp;			} catch (Exception e) {</b>
<b class="nc"><i>893</i>&nbsp;				logger.error(&quot;Error saving snapshot &quot; + type + &quot; to &quot; + fileOutput.getAbsolutePath(), e);</b>
<i>894</i>&nbsp;			}
<b class="nc"><i>895</i>&nbsp;		}</b>
<b class="nc"><i>896</i>&nbsp;		return false;</b>
<i>897</i>&nbsp;	}
<i>898</i>&nbsp;	
<i>899</i>&nbsp;//	/**
<i>900</i>&nbsp;//	 * Merge the points ROIs of different objects to create a single object containing all points with a specific {@link PathClass}.
<i>901</i>&nbsp;//	 * @param imageData the image data containing points to merge
<i>902</i>&nbsp;//	 * @param selectedOnly if true, use only classes found within the currently selected objects
<i>903</i>&nbsp;//	 */
<i>904</i>&nbsp;//	public static void mergePointsForClasses(ImageData&lt;?&gt; imageData, boolean selectedOnly) {
<i>905</i>&nbsp;//		var hierarchy = imageData == null ? null : imageData.getHierarchy();
<i>906</i>&nbsp;//		if (hierarchy == null) {
<i>907</i>&nbsp;//			Dialogs.showNoImageError(&quot;Merge points&quot;);
<i>908</i>&nbsp;//			return;
<i>909</i>&nbsp;//		}
<i>910</i>&nbsp;//		if (selectedOnly) {
<i>911</i>&nbsp;//			PathObjectTools.mergePointsForSelectedObjectClasses(hierarchy);
<i>912</i>&nbsp;//			imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(
<i>913</i>&nbsp;//					&quot;Merge points for selected classifications&quot;,
<i>914</i>&nbsp;//					&quot;mergePointsForSelectedObjectClasses();&quot;
<i>915</i>&nbsp;//					));
<i>916</i>&nbsp;//		} else {
<i>917</i>&nbsp;//			PathObjectTools.mergePointsForAllClasses(hierarchy);
<i>918</i>&nbsp;//			imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(
<i>919</i>&nbsp;//					&quot;Merge points for all classifications&quot;,
<i>920</i>&nbsp;//					&quot;mergePointsForAllClasses();&quot;
<i>921</i>&nbsp;//					));
<i>922</i>&nbsp;//		}
<i>923</i>&nbsp;//	}
<i>924</i>&nbsp;	
<i>925</i>&nbsp;	/**
<i>926</i>&nbsp;	 * Merge the currently-selected annotations for an image, replacing them with a single new annotation.
<i>927</i>&nbsp;	 * @param imageData
<i>928</i>&nbsp;	 */
<i>929</i>&nbsp;	public static void mergeSelectedAnnotations(ImageData&lt;?&gt; imageData) {
<b class="nc"><i>930</i>&nbsp;		if (imageData == null)</b>
<b class="nc"><i>931</i>&nbsp;			return;</b>
<b class="nc"><i>932</i>&nbsp;		PathObjectHierarchy hierarchy = imageData.getHierarchy();</b>
<b class="nc"><i>933</i>&nbsp;		logger.debug(&quot;Merging selected annotations&quot;);</b>
<b class="nc"><i>934</i>&nbsp;		QP.mergeSelectedAnnotations(hierarchy);</b>
<b class="nc"><i>935</i>&nbsp;		imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Merge selected annotations&quot;,</b>
<i>936</i>&nbsp;				&quot;mergeSelectedAnnotations()&quot;));
<b class="nc"><i>937</i>&nbsp;	}</b>
<i>938</i>&nbsp;
<i>939</i>&nbsp;	
<i>940</i>&nbsp;	/**
<i>941</i>&nbsp;	 * Duplicate the selected annotations.
<i>942</i>&nbsp;	 * @param imageData
<i>943</i>&nbsp;	 */
<i>944</i>&nbsp;	public static void duplicateSelectedAnnotations(ImageData&lt;?&gt; imageData) {
<b class="nc"><i>945</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>946</i>&nbsp;			Dialogs.showNoImageError(&quot;Duplicate annotations&quot;);</b>
<b class="nc"><i>947</i>&nbsp;			return;</b>
<i>948</i>&nbsp;		}
<b class="nc"><i>949</i>&nbsp;		PathObjectHierarchy hierarchy = imageData.getHierarchy();</b>
<b class="nc"><i>950</i>&nbsp;		PathObjectTools.duplicateSelectedAnnotations(hierarchy);</b>
<b class="nc"><i>951</i>&nbsp;		imageData.getHistoryWorkflow().addStep(</b>
<i>952</i>&nbsp;				new DefaultScriptableWorkflowStep(&quot;Duplicate selected annotations&quot;,
<i>953</i>&nbsp;						&quot;duplicateSelectedAnnotations()&quot;));
<b class="nc"><i>954</i>&nbsp;	}</b>
<i>955</i>&nbsp;
<i>956</i>&nbsp;	/**
<i>957</i>&nbsp;	 * Make an inverse annotation for the selected objects, storing the command in the history workflow.
<i>958</i>&nbsp;	 * @param imageData
<i>959</i>&nbsp;	 * @see QP#makeInverseAnnotation(ImageData)
<i>960</i>&nbsp;	 */
<i>961</i>&nbsp;	public static void makeInverseAnnotation(ImageData&lt;?&gt; imageData) {
<b class="nc"><i>962</i>&nbsp;		if (imageData == null)</b>
<b class="nc"><i>963</i>&nbsp;			return;</b>
<b class="nc"><i>964</i>&nbsp;		logger.debug(&quot;Make inverse annotation&quot;);</b>
<b class="nc"><i>965</i>&nbsp;		QP.makeInverseAnnotation(imageData);</b>
<b class="nc"><i>966</i>&nbsp;		imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Invert selected annotation&quot;,</b>
<i>967</i>&nbsp;				&quot;makeInverseAnnotation()&quot;));
<b class="nc"><i>968</i>&nbsp;	}</b>
<i>969</i>&nbsp;	
<i>970</i>&nbsp;	
<i>971</i>&nbsp;	/**
<i>972</i>&nbsp;	 * Show a dialog to track the viewed region of an image.
<i>973</i>&nbsp;	 * @param qupath
<i>974</i>&nbsp;	 */
<i>975</i>&nbsp;	public static void showViewTracker(QuPathGUI qupath) {
<b class="nc"><i>976</i>&nbsp;		var dialog = new Stage();</b>
<b class="nc"><i>977</i>&nbsp;		dialog.initOwner(qupath.getStage());</b>
<b class="nc"><i>978</i>&nbsp;		dialog.setTitle(&quot;Tracking&quot;);</b>
<b class="nc"><i>979</i>&nbsp;		final ViewTrackerControlPane panel = new ViewTrackerControlPane(qupath.getViewer());</b>
<b class="nc"><i>980</i>&nbsp;		StackPane pane = new StackPane(panel.getNode());</b>
<b class="nc"><i>981</i>&nbsp;		dialog.setScene(new Scene(pane));</b>
<b class="nc"><i>982</i>&nbsp;		dialog.setResizable(false);</b>
<b class="nc"><i>983</i>&nbsp;		dialog.setAlwaysOnTop(true);</b>
<b class="nc"><i>984</i>&nbsp;		dialog.setOnHidden(e -&gt; {</b>
<b class="nc"><i>985</i>&nbsp;			if (panel != null)</b>
<b class="nc"><i>986</i>&nbsp;				panel.setRecording(false);</b>
<b class="nc"><i>987</i>&nbsp;		});</b>
<b class="nc"><i>988</i>&nbsp;		dialog.show();</b>
<b class="nc"><i>989</i>&nbsp;	}</b>
<i>990</i>&nbsp;
<i>991</i>&nbsp;	
<i>992</i>&nbsp;	
<i>993</i>&nbsp;//	/**
<i>994</i>&nbsp;//	 * Combine the selected annotations for the image open in the specified viewer.
<i>995</i>&nbsp;//	 * @param viewer viewer containing the image data
<i>996</i>&nbsp;//	 * @param op the {@link CombineOp} operation to apply
<i>997</i>&nbsp;//	 * @return true if changes were made, false otherwise
<i>998</i>&nbsp;//	 */
<i>999</i>&nbsp;//	public static boolean combineSelectedAnnotations(QuPathViewer viewer, RoiTools.CombineOp op) {
<i>1000</i>&nbsp;//		var hierarchy = viewer == null ? null : viewer.getImageData();
<i>1001</i>&nbsp;//		return combineSelectedAnnotations(hierarchy, op);
<i>1002</i>&nbsp;//	}
<i>1003</i>&nbsp;	
<i>1004</i>&nbsp;	/**
<i>1005</i>&nbsp;	 * Combine the selected annotations for the specified hierarchy.
<i>1006</i>&nbsp;	 * @param imageData the image data to process
<i>1007</i>&nbsp;	 * @param op the {@link CombineOp} operation to apply
<i>1008</i>&nbsp;	 * @return true if changes were made, false otherwise
<i>1009</i>&nbsp;	 */
<i>1010</i>&nbsp;	public static boolean combineSelectedAnnotations(ImageData&lt;?&gt; imageData, RoiTools.CombineOp op) {
<i>1011</i>&nbsp;		// TODO: CONSIDER MAKING THIS SCRIPTABLE!
<b class="nc"><i>1012</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>1013</i>&nbsp;			Dialogs.showNoImageError(&quot;Combine annotations&quot;);</b>
<b class="nc"><i>1014</i>&nbsp;			return false;</b>
<i>1015</i>&nbsp;		}
<b class="nc"><i>1016</i>&nbsp;		var hierarchy = imageData.getHierarchy();</b>
<i>1017</i>&nbsp;		// Ensure the main selected object is first in the list, if possible
<b class="nc"><i>1018</i>&nbsp;		var selected = new ArrayList&lt;&gt;(hierarchy.getSelectionModel().getSelectedObjects());</b>
<b class="nc"><i>1019</i>&nbsp;		var mainObject = hierarchy.getSelectionModel().getSelectedObject();</b>
<b class="nc"><i>1020</i>&nbsp;		if (mainObject != null &amp;&amp; !selected.isEmpty() &amp;&amp; !selected.get(0).equals(mainObject)) {</b>
<b class="nc"><i>1021</i>&nbsp;			selected.remove(mainObject);</b>
<b class="nc"><i>1022</i>&nbsp;			selected.add(0, mainObject);</b>
<i>1023</i>&nbsp;		}
<b class="nc"><i>1024</i>&nbsp;		return combineAnnotations(hierarchy, selected, op);</b>
<i>1025</i>&nbsp;	}
<i>1026</i>&nbsp;	
<i>1027</i>&nbsp;	
<i>1028</i>&nbsp;	/**
<i>1029</i>&nbsp;	 * Combine all the annotations that overlap with a selected object.
<i>1030</i>&nbsp;	 * &lt;p&gt;
<i>1031</i>&nbsp;	 * The selected object should itself be an annotation.
<i>1032</i>&nbsp;	 * 
<i>1033</i>&nbsp;	 * @param hierarchy
<i>1034</i>&nbsp;	 * @param pathObjects
<i>1035</i>&nbsp;	 * @param op
<i>1036</i>&nbsp;	 * @return true if any changes were made, false otherwise
<i>1037</i>&nbsp;	 */
<i>1038</i>&nbsp;	static boolean combineAnnotations(PathObjectHierarchy hierarchy, List&lt;PathObject&gt; pathObjects, RoiTools.CombineOp op) {
<b class="nc"><i>1039</i>&nbsp;		if (hierarchy == null || hierarchy.isEmpty() || pathObjects.isEmpty()) {</b>
<b class="nc"><i>1040</i>&nbsp;			logger.warn(&quot;Combine annotations: Cannot combine - no annotations found&quot;);</b>
<b class="nc"><i>1041</i>&nbsp;			return false;</b>
<i>1042</i>&nbsp;		}
<i>1043</i>&nbsp;		
<b class="nc"><i>1044</i>&nbsp;		pathObjects = new ArrayList&lt;&gt;(pathObjects);</b>
<b class="nc"><i>1045</i>&nbsp;		PathObject pathObject = pathObjects.get(0);</b>
<b class="nc"><i>1046</i>&nbsp;		if (!pathObject.isAnnotation()) { // || !RoiTools.isShapeROI(pathObject.getROI())) {</b>
<b class="nc"><i>1047</i>&nbsp;			logger.warn(&quot;Combine annotations: No annotation with ROI selected&quot;);				</b>
<b class="nc"><i>1048</i>&nbsp;			return false;</b>
<i>1049</i>&nbsp;		}
<b class="nc"><i>1050</i>&nbsp;		var plane = pathObject.getROI().getImagePlane();</b>
<i>1051</i>&nbsp;//		pathObjects.removeIf(p -&gt; !RoiTools.isShapeROI(p.getROI())); // Remove any null or point ROIs, TODO: Consider supporting points
<b class="nc"><i>1052</i>&nbsp;		pathObjects.removeIf(p -&gt; !p.hasROI() || !p.getROI().getImagePlane().equals(plane)); // Remove any null or point ROIs, TODO: Consider supporting points</b>
<b class="nc"><i>1053</i>&nbsp;		if (pathObjects.isEmpty()) {</b>
<b class="nc"><i>1054</i>&nbsp;			logger.warn(&quot;Cannot combine annotations - only one suitable annotation found&quot;);</b>
<b class="nc"><i>1055</i>&nbsp;			return false;</b>
<i>1056</i>&nbsp;		}
<i>1057</i>&nbsp;		
<b class="nc"><i>1058</i>&nbsp;		var allROIs = pathObjects.stream().map(p -&gt; p.getROI()).collect(Collectors.toCollection(() -&gt; new ArrayList&lt;&gt;()));</b>
<i>1059</i>&nbsp;		ROI newROI;
<i>1060</i>&nbsp;		
<b class="nc"><i>1061</i>&nbsp;		switch (op) {</b>
<i>1062</i>&nbsp;		case ADD:
<b class="nc"><i>1063</i>&nbsp;			newROI = RoiTools.union(allROIs);</b>
<b class="nc"><i>1064</i>&nbsp;			break;</b>
<i>1065</i>&nbsp;		case INTERSECT:
<b class="nc"><i>1066</i>&nbsp;			newROI = RoiTools.intersection(allROIs);</b>
<b class="nc"><i>1067</i>&nbsp;			break;</b>
<i>1068</i>&nbsp;		case SUBTRACT:
<b class="nc"><i>1069</i>&nbsp;			var first = allROIs.remove(0);</b>
<b class="nc"><i>1070</i>&nbsp;			newROI = RoiTools.combineROIs(first, RoiTools.union(allROIs), op);</b>
<b class="nc"><i>1071</i>&nbsp;			break;</b>
<i>1072</i>&nbsp;		default:
<b class="nc"><i>1073</i>&nbsp;			throw new IllegalArgumentException(&quot;Unknown combine op &quot; + op);</b>
<i>1074</i>&nbsp;		}
<i>1075</i>&nbsp;	
<b class="nc"><i>1076</i>&nbsp;		if (newROI == null) {</b>
<b class="nc"><i>1077</i>&nbsp;			logger.debug(&quot;No changes were made&quot;);</b>
<b class="nc"><i>1078</i>&nbsp;			return false;</b>
<i>1079</i>&nbsp;		}
<i>1080</i>&nbsp;		
<b class="nc"><i>1081</i>&nbsp;		PathObject newObject = null;</b>
<b class="nc"><i>1082</i>&nbsp;		if (!newROI.isEmpty()) {</b>
<b class="nc"><i>1083</i>&nbsp;			newObject = PathObjects.createAnnotationObject(newROI, pathObject.getPathClass());</b>
<b class="nc"><i>1084</i>&nbsp;			newObject.setName(pathObject.getName());</b>
<b class="nc"><i>1085</i>&nbsp;			newObject.setColorRGB(pathObject.getColorRGB());</b>
<i>1086</i>&nbsp;		}
<i>1087</i>&nbsp;
<i>1088</i>&nbsp;		// Remove previous objects
<b class="nc"><i>1089</i>&nbsp;		hierarchy.removeObjects(pathObjects, true);</b>
<b class="nc"><i>1090</i>&nbsp;		if (newObject != null)</b>
<b class="nc"><i>1091</i>&nbsp;			hierarchy.addPathObject(newObject);</b>
<b class="nc"><i>1092</i>&nbsp;		return true;</b>
<i>1093</i>&nbsp;	}
<i>1094</i>&nbsp;	
<i>1095</i>&nbsp;	/**
<i>1096</i>&nbsp;	 * Prompt to select objects according to their classifications.
<i>1097</i>&nbsp;	 * @param qupath
<i>1098</i>&nbsp;	 * @param imageData
<i>1099</i>&nbsp;	 */
<i>1100</i>&nbsp;	public static void promptToSelectObjectsByClassification(QuPathGUI qupath, ImageData&lt;?&gt; imageData) {
<b class="nc"><i>1101</i>&nbsp;		if (imageData == null)</b>
<b class="nc"><i>1102</i>&nbsp;			return;</b>
<b class="nc"><i>1103</i>&nbsp;		var pathClass = Dialogs.showChoiceDialog(&quot;Select objects&quot;, &quot;&quot;, qupath.getAvailablePathClasses(), null);</b>
<b class="nc"><i>1104</i>&nbsp;		if (pathClass == null)</b>
<b class="nc"><i>1105</i>&nbsp;			return;</b>
<b class="nc"><i>1106</i>&nbsp;		PathClassPane.selectObjectsByClassification(imageData, pathClass);</b>
<b class="nc"><i>1107</i>&nbsp;	}</b>
<i>1108</i>&nbsp;
<i>1109</i>&nbsp;	
<i>1110</i>&nbsp;	/**
<i>1111</i>&nbsp;	 * Prompt to delete objects of a specified type, or all objects.
<i>1112</i>&nbsp;	 * @param imageData
<i>1113</i>&nbsp;	 * @param cls
<i>1114</i>&nbsp;	 */
<i>1115</i>&nbsp;	public static void promptToDeleteObjects(ImageData&lt;?&gt; imageData, Class&lt;? extends PathObject&gt; cls) {
<b class="nc"><i>1116</i>&nbsp;		if (imageData == null)</b>
<b class="nc"><i>1117</i>&nbsp;			return;</b>
<b class="nc"><i>1118</i>&nbsp;		PathObjectHierarchy hierarchy = imageData.getHierarchy();</b>
<i>1119</i>&nbsp;		
<i>1120</i>&nbsp;		// Handle no specified class - indicates all objects of all types should be cleared
<b class="nc"><i>1121</i>&nbsp;		if (cls == null) {</b>
<b class="nc"><i>1122</i>&nbsp;			int n = hierarchy.nObjects();</b>
<b class="nc"><i>1123</i>&nbsp;			if (n == 0)</b>
<b class="nc"><i>1124</i>&nbsp;				return;</b>
<i>1125</i>&nbsp;			String message;
<b class="nc"><i>1126</i>&nbsp;			if (n == 1)</b>
<b class="nc"><i>1127</i>&nbsp;				message = &quot;Delete object?&quot;;</b>
<i>1128</i>&nbsp;			else
<b class="nc"><i>1129</i>&nbsp;				message = &quot;Delete all &quot; + n + &quot; objects?&quot;;</b>
<b class="nc"><i>1130</i>&nbsp;			if (Dialogs.showYesNoDialog(&quot;Delete objects&quot;, message)) {</b>
<b class="nc"><i>1131</i>&nbsp;				hierarchy.clearAll();</b>
<b class="nc"><i>1132</i>&nbsp;				hierarchy.getSelectionModel().setSelectedObject(null);</b>
<b class="nc"><i>1133</i>&nbsp;				imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Clear all objects&quot;, &quot;clearAllObjects();&quot;));</b>
<i>1134</i>&nbsp;			}
<b class="nc"><i>1135</i>&nbsp;			return;</b>
<i>1136</i>&nbsp;		}
<i>1137</i>&nbsp;		
<i>1138</i>&nbsp;		// Handle clearing TMA grid
<b class="nc"><i>1139</i>&nbsp;		if (TMACoreObject.class.equals(cls)) {</b>
<b class="nc"><i>1140</i>&nbsp;			if (hierarchy.getTMAGrid() != null) {</b>
<b class="nc"><i>1141</i>&nbsp;				if (Dialogs.showYesNoDialog(&quot;Delete objects&quot;, &quot;Clear TMA grid?&quot;)) {</b>
<b class="nc"><i>1142</i>&nbsp;					hierarchy.clearAll();</b>
<i>1143</i>&nbsp;					
<b class="nc"><i>1144</i>&nbsp;					PathObject selected = hierarchy.getSelectionModel().getSelectedObject();</b>
<b class="nc"><i>1145</i>&nbsp;					if (selected instanceof TMACoreObject)</b>
<b class="nc"><i>1146</i>&nbsp;						hierarchy.getSelectionModel().setSelectedObject(null);</b>
<i>1147</i>&nbsp;
<b class="nc"><i>1148</i>&nbsp;					imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Clear TMA Grid&quot;, &quot;clearTMAGrid();&quot;));</b>
<i>1149</i>&nbsp;				}
<b class="nc"><i>1150</i>&nbsp;				return;</b>
<i>1151</i>&nbsp;			}
<i>1152</i>&nbsp;		}
<i>1153</i>&nbsp;		
<i>1154</i>&nbsp;		
<i>1155</i>&nbsp;		// Handle clearing objects of another specified type
<b class="nc"><i>1156</i>&nbsp;		Collection&lt;PathObject&gt; pathObjects = hierarchy.getObjects(null, cls);</b>
<b class="nc"><i>1157</i>&nbsp;		if (pathObjects.isEmpty())</b>
<b class="nc"><i>1158</i>&nbsp;			return;</b>
<b class="nc"><i>1159</i>&nbsp;		int n = pathObjects.size();</b>
<b class="nc"><i>1160</i>&nbsp;		String message = n == 1 ? &quot;Delete 1 object?&quot; : &quot;Delete &quot; + n + &quot; objects?&quot;;</b>
<b class="nc"><i>1161</i>&nbsp;		if (Dialogs.showYesNoDialog(&quot;Delete objects&quot;, message)) {</b>
<b class="nc"><i>1162</i>&nbsp;			hierarchy.removeObjects(pathObjects, true);</b>
<i>1163</i>&nbsp;			
<b class="nc"><i>1164</i>&nbsp;			PathObject selected = hierarchy.getSelectionModel().getSelectedObject();</b>
<b class="nc"><i>1165</i>&nbsp;			if (selected != null &amp;&amp; selected.getClass().isAssignableFrom(cls))</b>
<b class="nc"><i>1166</i>&nbsp;				hierarchy.getSelectionModel().setSelectedObject(null);</b>
<i>1167</i>&nbsp;			
<b class="nc"><i>1168</i>&nbsp;			if (selected != null &amp;&amp; selected.getClass().isAssignableFrom(cls))</b>
<b class="nc"><i>1169</i>&nbsp;				hierarchy.getSelectionModel().setSelectedObject(null);</b>
<i>1170</i>&nbsp;			
<b class="nc"><i>1171</i>&nbsp;			if (cls == PathDetectionObject.class)</b>
<b class="nc"><i>1172</i>&nbsp;				imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Clear detections&quot;, &quot;clearDetections();&quot;));</b>
<b class="nc"><i>1173</i>&nbsp;			else if (cls == PathAnnotationObject.class)</b>
<b class="nc"><i>1174</i>&nbsp;				imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Clear annotations&quot;, &quot;clearAnnotations();&quot;));</b>
<b class="nc"><i>1175</i>&nbsp;			else if (cls == TMACoreObject.class)</b>
<b class="nc"><i>1176</i>&nbsp;				imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Clear TMA grid&quot;, &quot;clearTMAGrid();&quot;));</b>
<i>1177</i>&nbsp;			else
<b class="nc"><i>1178</i>&nbsp;				logger.warn(&quot;Cannot clear all objects for class {}&quot;, cls);</b>
<i>1179</i>&nbsp;		}
<b class="nc"><i>1180</i>&nbsp;	}</b>
<i>1181</i>&nbsp;	
<i>1182</i>&nbsp;	
<i>1183</i>&nbsp;	/**
<i>1184</i>&nbsp;	 * Reset QuPath&#39;s preferences, after confirming with the user.
<i>1185</i>&nbsp;	 * QuPath needs to be restarted for this to take effect.
<i>1186</i>&nbsp;	 * @return true if the preferences were reset, false otherwise
<i>1187</i>&nbsp;	 */
<i>1188</i>&nbsp;	public static boolean promptToResetPreferences() {
<b class="nc"><i>1189</i>&nbsp;		if (Dialogs.showConfirmDialog(&quot;Reset Preferences&quot;, &quot;Do you want to reset all custom preferences?\n\nYou may have to restart QuPath to see all changes.&quot;)) {</b>
<b class="nc"><i>1190</i>&nbsp;			PathPrefs.resetPreferences();</b>
<b class="nc"><i>1191</i>&nbsp;			return true;</b>
<i>1192</i>&nbsp;		}
<i>1193</i>&nbsp;		else
<b class="nc"><i>1194</i>&nbsp;			logger.info(&quot;Reset preferences command skipped!&quot;);</b>
<b class="nc"><i>1195</i>&nbsp;		return false;</b>
<i>1196</i>&nbsp;	}
<i>1197</i>&nbsp;
<i>1198</i>&nbsp;	
<i>1199</i>&nbsp;	
<i>1200</i>&nbsp;	/**
<i>1201</i>&nbsp;	 * Set the downsample factor for the specified viewer.
<i>1202</i>&nbsp;	 * @param viewer
<i>1203</i>&nbsp;	 * @param downsample
<i>1204</i>&nbsp;	 */
<i>1205</i>&nbsp;	public static void setViewerDownsample(QuPathViewer viewer, double downsample) {
<b class="nc"><i>1206</i>&nbsp;		if (viewer != null)</b>
<b class="nc"><i>1207</i>&nbsp;			viewer.setDownsampleFactor(downsample);</b>
<b class="nc"><i>1208</i>&nbsp;	}</b>
<i>1209</i>&nbsp;	
<i>1210</i>&nbsp;	
<i>1211</i>&nbsp;	/**
<i>1212</i>&nbsp;	 * Close the current project open in the {@link QuPathGUI}.
<i>1213</i>&nbsp;	 * @param qupath
<i>1214</i>&nbsp;	 */
<i>1215</i>&nbsp;	public static void closeProject(QuPathGUI qupath) {
<b class="nc"><i>1216</i>&nbsp;		qupath.setProject(null);</b>
<b class="nc"><i>1217</i>&nbsp;	}</b>
<i>1218</i>&nbsp;	
<i>1219</i>&nbsp;	
<i>1220</i>&nbsp;	/**
<i>1221</i>&nbsp;	 * Prompt the user to select an empty directory, and use this to create a new project and set it as active.
<i>1222</i>&nbsp;	 * @param qupath the {@link QuPathGUI} instance for which the project should be created.
<i>1223</i>&nbsp;	 * @return true if a project was created, false otherwise (e.g. the user cancelled).
<i>1224</i>&nbsp;	 */
<i>1225</i>&nbsp;	public static boolean promptToCreateProject(QuPathGUI qupath) {
<b class="nc"><i>1226</i>&nbsp;		File dir = Dialogs.promptForDirectory(null);</b>
<b class="nc"><i>1227</i>&nbsp;		if (dir == null)</b>
<b class="nc"><i>1228</i>&nbsp;			return false;</b>
<b class="nc"><i>1229</i>&nbsp;		if (!dir.isDirectory()) {</b>
<b class="nc"><i>1230</i>&nbsp;			logger.error(dir + &quot; is not a valid project directory!&quot;);</b>
<i>1231</i>&nbsp;		}
<b class="nc"><i>1232</i>&nbsp;		for (File f : dir.listFiles()) {</b>
<b class="nc"><i>1233</i>&nbsp;			if (!f.isHidden()) {</b>
<b class="nc"><i>1234</i>&nbsp;				logger.error(&quot;Cannot create project for non-empty directory {}&quot;, dir);</b>
<b class="nc"><i>1235</i>&nbsp;				Dialogs.showErrorMessage(&quot;Project creator&quot;, &quot;Project directory must be empty!&quot;);</b>
<b class="nc"><i>1236</i>&nbsp;				return false;</b>
<i>1237</i>&nbsp;			}
<i>1238</i>&nbsp;		}
<b class="nc"><i>1239</i>&nbsp;		qupath.setProject(Projects.createProject(dir, BufferedImage.class));</b>
<b class="nc"><i>1240</i>&nbsp;		return true;</b>
<i>1241</i>&nbsp;	}
<i>1242</i>&nbsp;	
<i>1243</i>&nbsp;	
<i>1244</i>&nbsp;	/**
<i>1245</i>&nbsp;	 * Prompt the user to open an existing project and set it as active.
<i>1246</i>&nbsp;	 * @param qupath the {@link QuPathGUI} instance for which the project should be opened.
<i>1247</i>&nbsp;	 * @return true if a project was opened, false otherwise (e.g. the user cancelled).
<i>1248</i>&nbsp;	 */
<i>1249</i>&nbsp;
<i>1250</i>&nbsp;	public static boolean promptToOpenProject(QuPathGUI qupath) {
<b class="nc"><i>1251</i>&nbsp;		File fileProject = Dialogs.promptForFile(&quot;Choose project file&quot;, null, &quot;QuPath projects&quot;, new String[]{ProjectIO.getProjectExtension()});</b>
<b class="nc"><i>1252</i>&nbsp;		if (fileProject != null) {</b>
<i>1253</i>&nbsp;			try {
<b class="nc"><i>1254</i>&nbsp;				Project&lt;BufferedImage&gt; project = ProjectIO.loadProject(fileProject, BufferedImage.class);</b>
<b class="nc"><i>1255</i>&nbsp;				qupath.setProject(project);</b>
<b class="nc"><i>1256</i>&nbsp;				return true;</b>
<b class="nc"><i>1257</i>&nbsp;			} catch (Exception e) {</b>
<b class="nc"><i>1258</i>&nbsp;				Dialogs.showErrorMessage(&quot;Load project&quot;, &quot;Could not read project from &quot; + fileProject.getName());</b>
<i>1259</i>&nbsp;			}
<i>1260</i>&nbsp;		}
<b class="nc"><i>1261</i>&nbsp;		return false;</b>
<i>1262</i>&nbsp;	}
<i>1263</i>&nbsp;	
<i>1264</i>&nbsp;	
<i>1265</i>&nbsp;	
<i>1266</i>&nbsp;	/**
<i>1267</i>&nbsp;	 * Open new window with the TMA data viewer.
<i>1268</i>&nbsp;	 * @param qupath current {@link QuPathGUI} instance (may be null).
<i>1269</i>&nbsp;	 */
<i>1270</i>&nbsp;	public static void launchTMADataViewer(QuPathGUI qupath) {
<b class="nc"><i>1271</i>&nbsp;		Stage stage = new Stage();</b>
<b class="nc"><i>1272</i>&nbsp;		if (qupath != null)</b>
<b class="nc"><i>1273</i>&nbsp;			stage.initOwner(qupath.getStage());</b>
<b class="nc"><i>1274</i>&nbsp;		TMASummaryViewer tmaViewer = new TMASummaryViewer(stage);</b>
<i>1275</i>&nbsp;		
<b class="nc"><i>1276</i>&nbsp;		ImageData&lt;BufferedImage&gt; imageData = qupath.getImageData();</b>
<b class="nc"><i>1277</i>&nbsp;		if (imageData != null &amp;&amp; imageData.getHierarchy().getTMAGrid() != null)</b>
<b class="nc"><i>1278</i>&nbsp;			tmaViewer.setTMAEntriesFromImageData(imageData);</b>
<i>1279</i>&nbsp;		
<i>1280</i>&nbsp;		try {
<b class="nc"><i>1281</i>&nbsp;			Screen screen = Screen.getPrimary();</b>
<b class="nc"><i>1282</i>&nbsp;			stage.setWidth(screen.getBounds().getWidth()*0.75);</b>
<b class="nc"><i>1283</i>&nbsp;			stage.setHeight(screen.getBounds().getHeight()*0.75);</b>
<b class="nc"><i>1284</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>1285</i>&nbsp;			logger.error(&quot;Exception setting stage size&quot;, e);</b>
<b class="nc"><i>1286</i>&nbsp;		}</b>
<i>1287</i>&nbsp;		
<b class="nc"><i>1288</i>&nbsp;		stage.show();</b>
<b class="nc"><i>1289</i>&nbsp;	}</b>
<i>1290</i>&nbsp;	
<i>1291</i>&nbsp;	/**
<i>1292</i>&nbsp;	 * Compute the distance between all detections and the closest annotation, for all annotation classifications.
<i>1293</i>&nbsp;	 * @param imageData the image data to process
<i>1294</i>&nbsp;	 */
<i>1295</i>&nbsp;	public static void distanceToAnnotations2D(ImageData&lt;?&gt; imageData) {
<b class="nc"><i>1296</i>&nbsp;		String title = &quot;Distance to annotations 2D&quot;;</b>
<b class="nc"><i>1297</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>1298</i>&nbsp;			Dialogs.showNoImageError(title);</b>
<b class="nc"><i>1299</i>&nbsp;			return;</b>
<i>1300</i>&nbsp;		}
<i>1301</i>&nbsp;		
<b class="nc"><i>1302</i>&nbsp;		if (imageData.getServer().nZSlices() &gt; 1) {</b>
<b class="nc"><i>1303</i>&nbsp;			logger.debug(&quot;Warning user that measurements will be 2D...&quot;);</b>
<b class="nc"><i>1304</i>&nbsp;			if (!Dialogs.showConfirmDialog(title, </b>
<i>1305</i>&nbsp;					&quot;Distance to annotations command works only in 2D - distances will not be calculated for objects on different z-slices or time-points&quot;)) {
<b class="nc"><i>1306</i>&nbsp;				logger.debug(&quot;Command cancelled&quot;);</b>
<b class="nc"><i>1307</i>&nbsp;				return;</b>
<i>1308</i>&nbsp;			}
<i>1309</i>&nbsp;		}
<b class="nc"><i>1310</i>&nbsp;		var result = Dialogs.showYesNoCancelDialog(title, &quot;Split multi-part classifications?\nIf yes, each component of classifications such as \&quot;Class1: Class2\&quot; will be treated separately.&quot;);</b>
<b class="nc"><i>1311</i>&nbsp;		boolean doSplit = false;</b>
<b class="nc"><i>1312</i>&nbsp;		if (result == DialogButton.YES)</b>
<b class="nc"><i>1313</i>&nbsp;			doSplit = true;</b>
<b class="nc"><i>1314</i>&nbsp;		else if (result != DialogButton.NO)</b>
<b class="nc"><i>1315</i>&nbsp;			return;</b>
<i>1316</i>&nbsp;
<i>1317</i>&nbsp;		
<b class="nc"><i>1318</i>&nbsp;		DistanceTools.detectionToAnnotationDistances(imageData, doSplit);</b>
<b class="nc"><i>1319</i>&nbsp;		imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(</b>
<i>1320</i>&nbsp;				&quot;Distance to annotations 2D&quot;,
<b class="nc"><i>1321</i>&nbsp;				doSplit ? &quot;detectionToAnnotationDistances(true)&quot; : &quot;detectionToAnnotationDistances(false)&quot;));</b>
<b class="nc"><i>1322</i>&nbsp;	}</b>
<i>1323</i>&nbsp;	
<i>1324</i>&nbsp;	/**
<i>1325</i>&nbsp;	 * Compute the distance between the centroids of all detections, for all available classifications.
<i>1326</i>&nbsp;	 * @param imageData the image data to process
<i>1327</i>&nbsp;	 */
<i>1328</i>&nbsp;	public static void detectionCentroidDistances2D(ImageData&lt;?&gt; imageData) {
<b class="nc"><i>1329</i>&nbsp;		String title = &quot;Detection centroid distances 2D&quot;;</b>
<b class="nc"><i>1330</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>1331</i>&nbsp;			Dialogs.showNoImageError(title);</b>
<b class="nc"><i>1332</i>&nbsp;			return;</b>
<i>1333</i>&nbsp;		}
<i>1334</i>&nbsp;		
<b class="nc"><i>1335</i>&nbsp;		if (imageData.getServer().nZSlices() &gt; 1) {</b>
<b class="nc"><i>1336</i>&nbsp;			logger.debug(&quot;Warning user that measurements will be 2D...&quot;);</b>
<b class="nc"><i>1337</i>&nbsp;			if (!Dialogs.showConfirmDialog(title, </b>
<i>1338</i>&nbsp;					&quot;Detection centroid distances command works only in 2D - distances will not be calculated for objects on different z-slices or time-points&quot;)) {
<b class="nc"><i>1339</i>&nbsp;				logger.debug(&quot;Command cancelled&quot;);</b>
<b class="nc"><i>1340</i>&nbsp;				return;</b>
<i>1341</i>&nbsp;			}
<i>1342</i>&nbsp;		}
<i>1343</i>&nbsp;		
<b class="nc"><i>1344</i>&nbsp;		var result = Dialogs.showYesNoCancelDialog(title, &quot;Split multi-part classifications?\nIf yes, each component of classifications such as \&quot;Class1: Class2\&quot; will be treated separately.&quot;);</b>
<b class="nc"><i>1345</i>&nbsp;		boolean doSplit = false;</b>
<b class="nc"><i>1346</i>&nbsp;		if (result == DialogButton.YES)</b>
<b class="nc"><i>1347</i>&nbsp;			doSplit = true;</b>
<b class="nc"><i>1348</i>&nbsp;		else if (result != DialogButton.NO)</b>
<b class="nc"><i>1349</i>&nbsp;			return;</b>
<i>1350</i>&nbsp;		
<b class="nc"><i>1351</i>&nbsp;		DistanceTools.detectionCentroidDistances(imageData, doSplit);</b>
<b class="nc"><i>1352</i>&nbsp;		imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(</b>
<i>1353</i>&nbsp;				&quot;Detection centroid distances 2D&quot;,
<b class="nc"><i>1354</i>&nbsp;				doSplit ? &quot;detectionCentroidDistances(true)&quot; : &quot;detectionCentroidDistances(false)&quot;));</b>
<b class="nc"><i>1355</i>&nbsp;	}</b>
<i>1356</i>&nbsp;	
<i>1357</i>&nbsp;	
<i>1358</i>&nbsp;	/**
<i>1359</i>&nbsp;	 * Prompt to input the spacing for the grid lines optionally displayed on viewers.
<i>1360</i>&nbsp;	 * @param options the {@link OverlayOptions} that manage the grid lines.
<i>1361</i>&nbsp;	 */
<i>1362</i>&nbsp;	public static void promptToSetGridLineSpacing(OverlayOptions options) {
<b class="nc"><i>1363</i>&nbsp;		GridLines gridLines = options.getGridLines();</b>
<i>1364</i>&nbsp;		
<b class="nc"><i>1365</i>&nbsp;		ParameterList params = new ParameterList()</b>
<b class="nc"><i>1366</i>&nbsp;				.addDoubleParameter(&quot;hSpacing&quot;, &quot;Horizontal spacing&quot;, gridLines.getSpaceX())</b>
<b class="nc"><i>1367</i>&nbsp;				.addDoubleParameter(&quot;vSpacing&quot;, &quot;Vertical spacing&quot;, gridLines.getSpaceY())</b>
<b class="nc"><i>1368</i>&nbsp;				.addBooleanParameter(&quot;useMicrons&quot;, &quot;Use microns&quot;, gridLines.useMicrons());</b>
<i>1369</i>&nbsp;		
<b class="nc"><i>1370</i>&nbsp;		if (!Dialogs.showParameterDialog(&quot;Set grid spacing&quot;, params))</b>
<b class="nc"><i>1371</i>&nbsp;			return;</b>
<i>1372</i>&nbsp;		
<b class="nc"><i>1373</i>&nbsp;		gridLines = new GridLines();</b>
<b class="nc"><i>1374</i>&nbsp;		gridLines.setSpaceX(params.getDoubleParameterValue(&quot;hSpacing&quot;));</b>
<b class="nc"><i>1375</i>&nbsp;		gridLines.setSpaceY(params.getDoubleParameterValue(&quot;vSpacing&quot;));</b>
<b class="nc"><i>1376</i>&nbsp;		gridLines.setUseMicrons(params.getBooleanParameterValue(&quot;useMicrons&quot;));</b>
<i>1377</i>&nbsp;		
<b class="nc"><i>1378</i>&nbsp;		options.gridLinesProperty().set(gridLines);</b>
<b class="nc"><i>1379</i>&nbsp;	}</b>
<i>1380</i>&nbsp;	
<i>1381</i>&nbsp;	
<i>1382</i>&nbsp;	/**
<i>1383</i>&nbsp;	 * Reload the specified image data from a previously saved version,if available.
<i>1384</i>&nbsp;	 * @param qupath
<i>1385</i>&nbsp;	 * @param imageData
<i>1386</i>&nbsp;	 */
<i>1387</i>&nbsp;	public static void reloadImageData(QuPathGUI qupath, ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>1388</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>1389</i>&nbsp;			Dialogs.showNoImageError(&quot;Reload data&quot;);</b>
<b class="nc"><i>1390</i>&nbsp;			return;</b>
<i>1391</i>&nbsp;		}
<i>1392</i>&nbsp;		// TODO: Support loading from a project as well
<i>1393</i>&nbsp;		
<b class="nc"><i>1394</i>&nbsp;		var viewer = qupath.getViewers().stream().filter(v -&gt; v.getImageData() == imageData).findFirst().orElse(null);</b>
<b class="nc"><i>1395</i>&nbsp;		if (viewer == null) {</b>
<b class="nc"><i>1396</i>&nbsp;			Dialogs.showErrorMessage(&quot;Reload data&quot;, &quot;Specified image data not found open in any viewer!&quot;);</b>
<b class="nc"><i>1397</i>&nbsp;			return;</b>
<i>1398</i>&nbsp;		}
<i>1399</i>&nbsp;
<i>1400</i>&nbsp;		// Check if we have a saved file
<b class="nc"><i>1401</i>&nbsp;		File savedFile = imageData.getLastSavedPath() == null ? null : new File(imageData.getLastSavedPath());</b>
<b class="nc"><i>1402</i>&nbsp;		if (savedFile == null || !savedFile.isFile()) {</b>
<b class="nc"><i>1403</i>&nbsp;			Dialogs.showErrorMessage(&quot;Reload&quot;, &quot;No previously saved data found!&quot;);</b>
<b class="nc"><i>1404</i>&nbsp;			return;</b>
<i>1405</i>&nbsp;		}
<i>1406</i>&nbsp;		
<b class="nc"><i>1407</i>&nbsp;		if (Dialogs.showConfirmDialog(&quot;Reload&quot;, &quot;Revert to last saved version?  All changes will be lost.&quot;)) {</b>
<i>1408</i>&nbsp;			try {
<b class="nc"><i>1409</i>&nbsp;				var project = qupath.getProject();</b>
<b class="nc"><i>1410</i>&nbsp;				var entry = project == null ? null : project.getEntry(imageData);</b>
<i>1411</i>&nbsp;				ImageData&lt;BufferedImage&gt; imageDataNew;
<b class="nc"><i>1412</i>&nbsp;				if (entry != null) {</b>
<b class="nc"><i>1413</i>&nbsp;					logger.info(&quot;Reloading image data from project entry: {}&quot;, entry);</b>
<b class="nc"><i>1414</i>&nbsp;					imageDataNew = entry.readImageData();</b>
<i>1415</i>&nbsp;				} else {
<b class="nc"><i>1416</i>&nbsp;					logger.info(&quot;Reverting to last saved version: {}&quot;, savedFile.getAbsolutePath());</b>
<b class="nc"><i>1417</i>&nbsp;					imageDataNew = PathIO.readImageData(savedFile, null, imageData.getServer(), BufferedImage.class);</b>
<i>1418</i>&nbsp;				}
<b class="nc"><i>1419</i>&nbsp;				viewer.setImageData(imageDataNew);</b>
<b class="nc"><i>1420</i>&nbsp;			} catch (Exception e) {</b>
<b class="nc"><i>1421</i>&nbsp;				Dialogs.showErrorMessage(&quot;Reload&quot;, &quot;Error reverting to previously saved file\n\n&quot; + e.getLocalizedMessage());</b>
<b class="nc"><i>1422</i>&nbsp;			}</b>
<i>1423</i>&nbsp;		}
<i>1424</i>&nbsp;
<b class="nc"><i>1425</i>&nbsp;	}</b>
<i>1426</i>&nbsp;	
<i>1427</i>&nbsp;	
<i>1428</i>&nbsp;	
<i>1429</i>&nbsp;	/**
<i>1430</i>&nbsp;	 * Prompt to add shape features for selected objects.
<i>1431</i>&nbsp;	 * @param qupath current QuPath instance
<i>1432</i>&nbsp;	 */
<i>1433</i>&nbsp;	public static void promptToAddShapeFeatures(QuPathGUI qupath) {
<i>1434</i>&nbsp;		
<b class="nc"><i>1435</i>&nbsp;		var listView = new CheckListView&lt;ShapeFeatures&gt;();</b>
<b class="nc"><i>1436</i>&nbsp;		listView.getItems().setAll(ShapeFeatures.values());</b>
<b class="nc"><i>1437</i>&nbsp;		listView.getCheckModel().checkAll();</b>
<i>1438</i>&nbsp;		
<i>1439</i>&nbsp;		// This is to work around a bug in ControlsFX 11.0.1 that can throw a NPE if the parent is unavailable
<b class="nc"><i>1440</i>&nbsp;		listView.setCellFactory(view -&gt; {</b>
<b class="nc"><i>1441</i>&nbsp;            var cell = new CheckBoxListCell&lt;ShapeFeatures&gt;(item -&gt; listView.getItemBooleanProperty(item));</b>
<b class="nc"><i>1442</i>&nbsp;            cell.focusedProperty().addListener((o, ov, nv) -&gt; {</b>
<b class="nc"><i>1443</i>&nbsp;                if (nv) {</b>
<b class="nc"><i>1444</i>&nbsp;                	var parent = cell.getParent();</b>
<b class="nc"><i>1445</i>&nbsp;                	if (parent != null)</b>
<b class="nc"><i>1446</i>&nbsp;                		parent.requestFocus();</b>
<i>1447</i>&nbsp;                }
<b class="nc"><i>1448</i>&nbsp;            });</b>
<b class="nc"><i>1449</i>&nbsp;            return cell;</b>
<i>1450</i>&nbsp;        });
<i>1451</i>&nbsp;		
<b class="nc"><i>1452</i>&nbsp;		listView.setPrefHeight(Math.min(listView.getItems().size() * 30, 320));</b>
<i>1453</i>&nbsp;		
<b class="nc"><i>1454</i>&nbsp;		var pane = new BorderPane(listView);</b>
<i>1455</i>&nbsp;		
<b class="nc"><i>1456</i>&nbsp;		listView.setTooltip(new Tooltip(&quot;Choose shape features&quot;));</b>
<b class="nc"><i>1457</i>&nbsp;		var label = new Label(&quot;Add shape features to selected objects.\nNote that not all measurements are compatible with all objects.&quot;);</b>
<b class="nc"><i>1458</i>&nbsp;		label.setTextAlignment(TextAlignment.CENTER);</b>
<b class="nc"><i>1459</i>&nbsp;		label.setPadding(new Insets(10));</b>
<b class="nc"><i>1460</i>&nbsp;		pane.setTop(label);</b>
<i>1461</i>&nbsp;		
<b class="nc"><i>1462</i>&nbsp;		var btnSelectAll = new Button(&quot;Select all&quot;);</b>
<b class="nc"><i>1463</i>&nbsp;		btnSelectAll.setOnAction(e -&gt; listView.getCheckModel().checkAll());</b>
<b class="nc"><i>1464</i>&nbsp;		var btnSelectNone = new Button(&quot;Select none&quot;);</b>
<b class="nc"><i>1465</i>&nbsp;		btnSelectNone.setOnAction(e -&gt; listView.getCheckModel().clearChecks());</b>
<i>1466</i>&nbsp;		
<b class="nc"><i>1467</i>&nbsp;		btnSelectAll.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>1468</i>&nbsp;		btnSelectNone.setMaxWidth(Double.MAX_VALUE);</b>
<i>1469</i>&nbsp;		
<b class="nc"><i>1470</i>&nbsp;		pane.setBottom(PaneTools.createColumnGrid(btnSelectAll, btnSelectNone));</b>
<i>1471</i>&nbsp;		
<b class="nc"><i>1472</i>&nbsp;		var dialog = Dialogs.builder()</b>
<b class="nc"><i>1473</i>&nbsp;				.title(&quot;Shape features&quot;)</b>
<b class="nc"><i>1474</i>&nbsp;				.content(pane)</b>
<b class="nc"><i>1475</i>&nbsp;				.modality(Modality.NONE)</b>
<b class="nc"><i>1476</i>&nbsp;				.buttons(ButtonType.APPLY, ButtonType.CANCEL)</b>
<b class="nc"><i>1477</i>&nbsp;				.build();</b>
<i>1478</i>&nbsp;		
<b class="nc"><i>1479</i>&nbsp;		var btnApply = (Button)dialog.getDialogPane().lookupButton(ButtonType.APPLY);</b>
<b class="nc"><i>1480</i>&nbsp;		btnApply.disableProperty().bind(qupath.imageDataProperty().isNull());</b>
<i>1481</i>&nbsp;		
<b class="nc"><i>1482</i>&nbsp;		btnApply.setOnAction(e -&gt; requestShapeFeatures(qupath.getImageData(), listView.getCheckModel().getCheckedItems()));</b>
<i>1483</i>&nbsp;		
<b class="nc"><i>1484</i>&nbsp;		dialog.show();</b>
<i>1485</i>&nbsp;		
<i>1486</i>&nbsp;//		var result = dialog.showAndWait();
<i>1487</i>&nbsp;//		if (result.orElse(ButtonType.CANCEL) == ButtonType.APPLY)
<i>1488</i>&nbsp;//			requestShapeFeatures(qupath.getImageData(), listView.getSelectionModel().getSelectedItems());
<b class="nc"><i>1489</i>&nbsp;	}</b>
<i>1490</i>&nbsp;		
<i>1491</i>&nbsp;		
<i>1492</i>&nbsp;	private static void requestShapeFeatures(ImageData&lt;?&gt; imageData, Collection&lt;ShapeFeatures&gt; features) {
<b class="nc"><i>1493</i>&nbsp;		if (imageData == null)</b>
<b class="nc"><i>1494</i>&nbsp;			return;</b>
<b class="nc"><i>1495</i>&nbsp;		var featureArray = features.toArray(ShapeFeatures[]::new);</b>
<b class="nc"><i>1496</i>&nbsp;		if (featureArray.length == 0)</b>
<b class="nc"><i>1497</i>&nbsp;			return;</b>
<b class="nc"><i>1498</i>&nbsp;		Collection&lt;PathObject&gt; selected = imageData.getHierarchy().getSelectionModel().getSelectedObjects();</b>
<b class="nc"><i>1499</i>&nbsp;		if (selected.isEmpty()) {</b>
<b class="nc"><i>1500</i>&nbsp;			Dialogs.showWarningNotification(&quot;Shape features&quot;, &quot;No objects selected!&quot;);</b>
<i>1501</i>&nbsp;		} else {
<b class="nc"><i>1502</i>&nbsp;			selected = new ArrayList&lt;&gt;(selected);			</b>
<b class="nc"><i>1503</i>&nbsp;			String featureString = Arrays.stream(featureArray).map(f -&gt; &quot;\&quot;&quot; + f.name() + &quot;\&quot;&quot;).collect(Collectors.joining(&quot;, &quot;));</b>
<b class="nc"><i>1504</i>&nbsp;			QP.addShapeMeasurements(imageData, selected, featureArray);</b>
<b class="nc"><i>1505</i>&nbsp;			imageData.getHistoryWorkflow().addStep(new DefaultScriptableWorkflowStep(&quot;Add shape measurements&quot;,</b>
<b class="nc"><i>1506</i>&nbsp;					String.format(&quot;addShapeMeasurements(%s)&quot;, featureString)</b>
<i>1507</i>&nbsp;					));
<i>1508</i>&nbsp;			
<b class="nc"><i>1509</i>&nbsp;			if (selected.size() == 1)</b>
<b class="nc"><i>1510</i>&nbsp;				Dialogs.showInfoNotification(&quot;Shape features&quot;, &quot;Shape features calculated for one object&quot;);</b>
<i>1511</i>&nbsp;			else
<b class="nc"><i>1512</i>&nbsp;				Dialogs.showInfoNotification(&quot;Shape features&quot;, &quot;Shape features calculated for &quot; + selected.size() + &quot; objects&quot;);</b>
<i>1513</i>&nbsp;		}
<b class="nc"><i>1514</i>&nbsp;	}</b>
<i>1515</i>&nbsp;	
<i>1516</i>&nbsp;
<i>1517</i>&nbsp;	
<i>1518</i>&nbsp;	/**
<i>1519</i>&nbsp;	 * Convert detection objects to point annotations based upon their ROI centroids.
<i>1520</i>&nbsp;	 * @param imageData the image data to process
<i>1521</i>&nbsp;	 * @param preferNucleus if true, use a nucleus ROI for cell objects (if available
<i>1522</i>&nbsp;	 */
<i>1523</i>&nbsp;	public static void convertDetectionsToPoints(ImageData&lt;?&gt; imageData, boolean preferNucleus) {
<b class="nc"><i>1524</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>1525</i>&nbsp;			Dialogs.showNoImageError(&quot;Convert detections to points&quot;);</b>
<b class="nc"><i>1526</i>&nbsp;			return;</b>
<i>1527</i>&nbsp;		}
<b class="nc"><i>1528</i>&nbsp;		PathObjectHierarchy hierarchy = imageData.getHierarchy();</b>
<b class="nc"><i>1529</i>&nbsp;		Collection&lt;PathObject&gt; pathObjects = hierarchy.getDetectionObjects();</b>
<b class="nc"><i>1530</i>&nbsp;		if (pathObjects.isEmpty()) {</b>
<b class="nc"><i>1531</i>&nbsp;			Dialogs.showErrorMessage(&quot;Detections to points&quot;, &quot;No detections found!&quot;);</b>
<b class="nc"><i>1532</i>&nbsp;			return;</b>
<i>1533</i>&nbsp;		}
<i>1534</i>&nbsp;		
<i>1535</i>&nbsp;		// Remove any detections that don&#39;t have a ROI - can&#39;t do much with them
<b class="nc"><i>1536</i>&nbsp;		Iterator&lt;PathObject&gt; iter = pathObjects.iterator();</b>
<b class="nc"><i>1537</i>&nbsp;		while (iter.hasNext()) {</b>
<b class="nc"><i>1538</i>&nbsp;			if (!iter.next().hasROI())</b>
<b class="nc"><i>1539</i>&nbsp;				iter.remove();</b>
<i>1540</i>&nbsp;		}
<i>1541</i>&nbsp;		
<b class="nc"><i>1542</i>&nbsp;		if (pathObjects.isEmpty()) {</b>
<b class="nc"><i>1543</i>&nbsp;			logger.warn(&quot;No detections found with ROIs!&quot;);</b>
<b class="nc"><i>1544</i>&nbsp;			return;</b>
<i>1545</i>&nbsp;		}
<i>1546</i>&nbsp;		
<i>1547</i>&nbsp;		// Check if existing objects should be deleted
<b class="nc"><i>1548</i>&nbsp;		String message = pathObjects.size() == 1 ? &quot;Delete detection after converting to a point?&quot; :</b>
<b class="nc"><i>1549</i>&nbsp;			String.format(&quot;Delete %d detections after converting to points?&quot;, pathObjects.size());</b>
<b class="nc"><i>1550</i>&nbsp;		var button = Dialogs.showYesNoCancelDialog(&quot;Detections to points&quot;, message);</b>
<b class="nc"><i>1551</i>&nbsp;		if (button == Dialogs.DialogButton.CANCEL)</b>
<b class="nc"><i>1552</i>&nbsp;			return;</b>
<i>1553</i>&nbsp;		
<b class="nc"><i>1554</i>&nbsp;		boolean	deleteDetections = button == Dialogs.DialogButton.YES;		</b>
<b class="nc"><i>1555</i>&nbsp;		PathObjectTools.convertToPoints(hierarchy, pathObjects, preferNucleus, deleteDetections);</b>
<b class="nc"><i>1556</i>&nbsp;	}</b>
<i>1557</i>&nbsp;
<i>1558</i>&nbsp;
<i>1559</i>&nbsp;	/**
<i>1560</i>&nbsp;	 * Show a prompt to selected annotations in a hierarchy.
<i>1561</i>&nbsp;	 * @param imageData the current image data
<i>1562</i>&nbsp;	 * @param altitudeThreshold default altitude value for simplification
<i>1563</i>&nbsp;	 */
<i>1564</i>&nbsp;	public static void promptToSimplifySelectedAnnotations(ImageData&lt;?&gt; imageData, double altitudeThreshold) {
<b class="nc"><i>1565</i>&nbsp;			PathObjectHierarchy hierarchy = imageData.getHierarchy();</b>
<b class="nc"><i>1566</i>&nbsp;			List&lt;PathObject&gt; pathObjects = hierarchy.getSelectionModel().getSelectedObjects().stream()</b>
<b class="nc"><i>1567</i>&nbsp;					.filter(p -&gt; p.isAnnotation() &amp;&amp; p.hasROI() &amp;&amp; p.isEditable() &amp;&amp; !p.getROI().isPoint())</b>
<b class="nc"><i>1568</i>&nbsp;					.collect(Collectors.toList());</b>
<b class="nc"><i>1569</i>&nbsp;			if (pathObjects.isEmpty()) {</b>
<b class="nc"><i>1570</i>&nbsp;				Dialogs.showErrorMessage(&quot;Simplify annotations&quot;, &quot;No unlocked shape annotations selected!&quot;);</b>
<b class="nc"><i>1571</i>&nbsp;				return;</b>
<i>1572</i>&nbsp;			}
<i>1573</i>&nbsp;	
<b class="nc"><i>1574</i>&nbsp;			String input = Dialogs.showInputDialog(&quot;Simplify shape&quot;, </b>
<i>1575</i>&nbsp;					&quot;Set altitude threshold in pixels (&gt; 0; higher values give simpler shapes)&quot;, 
<b class="nc"><i>1576</i>&nbsp;					Double.toString(altitudeThreshold));</b>
<b class="nc"><i>1577</i>&nbsp;			if (input == null || !(input instanceof String) || ((String)input).trim().length() == 0)</b>
<b class="nc"><i>1578</i>&nbsp;				return;</b>
<i>1579</i>&nbsp;			try {
<b class="nc"><i>1580</i>&nbsp;				altitudeThreshold = Double.parseDouble(((String)input).trim());</b>
<b class="nc"><i>1581</i>&nbsp;			} catch (NumberFormatException e) {</b>
<b class="nc"><i>1582</i>&nbsp;				logger.error(&quot;Could not parse altitude threshold from {}&quot;, input);</b>
<b class="nc"><i>1583</i>&nbsp;				return;</b>
<b class="nc"><i>1584</i>&nbsp;			}</b>
<i>1585</i>&nbsp;			
<b class="nc"><i>1586</i>&nbsp;			long startTime = System.currentTimeMillis();</b>
<b class="nc"><i>1587</i>&nbsp;			for (var pathObject : pathObjects) {</b>
<b class="nc"><i>1588</i>&nbsp;				ROI pathROI = pathObject.getROI();</b>
<b class="nc"><i>1589</i>&nbsp;				if (pathROI instanceof PolygonROI) {</b>
<b class="nc"><i>1590</i>&nbsp;					PolygonROI polygonROI = (PolygonROI)pathROI;</b>
<b class="nc"><i>1591</i>&nbsp;					pathROI = ShapeSimplifier.simplifyPolygon(polygonROI, altitudeThreshold);</b>
<b class="nc"><i>1592</i>&nbsp;				} else {</b>
<b class="nc"><i>1593</i>&nbsp;					pathROI = ShapeSimplifier.simplifyShape(pathROI, altitudeThreshold);</b>
<i>1594</i>&nbsp;				}
<b class="nc"><i>1595</i>&nbsp;				((PathAnnotationObject)pathObject).setROI(pathROI);</b>
<b class="nc"><i>1596</i>&nbsp;			}</b>
<b class="nc"><i>1597</i>&nbsp;			long endTime = System.currentTimeMillis();</b>
<b class="nc"><i>1598</i>&nbsp;			logger.debug(&quot;Shapes simplified in &quot; + (endTime - startTime) + &quot; ms&quot;);</b>
<b class="nc"><i>1599</i>&nbsp;			hierarchy.fireObjectsChangedEvent(hierarchy, pathObjects);</b>
<b class="nc"><i>1600</i>&nbsp;		}</b>
<i>1601</i>&nbsp;
<i>1602</i>&nbsp;
<i>1603</i>&nbsp;
<i>1604</i>&nbsp;	/**
<i>1605</i>&nbsp;	 * Select objects that are instances of a specified class, logging an appropriate method in the workflow.
<i>1606</i>&nbsp;	 * 
<i>1607</i>&nbsp;	 * @param imageData
<i>1608</i>&nbsp;	 * @param cls
<i>1609</i>&nbsp;	 */
<i>1610</i>&nbsp;	public static void selectObjectsByClass(final ImageData&lt;?&gt; imageData, final Class&lt;? extends PathObject&gt; cls) {
<b class="nc"><i>1611</i>&nbsp;		if (cls == TMACoreObject.class)</b>
<b class="nc"><i>1612</i>&nbsp;			QP.selectTMACores(imageData.getHierarchy());</b>
<i>1613</i>&nbsp;		else
<b class="nc"><i>1614</i>&nbsp;			QP.selectObjectsByClass(imageData.getHierarchy(), cls);</b>
<i>1615</i>&nbsp;		
<b class="nc"><i>1616</i>&nbsp;		Map&lt;String, String&gt; params = Collections.singletonMap(&quot;Type&quot;, PathObjectTools.getSuitableName(cls, false));</b>
<i>1617</i>&nbsp;		String method;
<b class="nc"><i>1618</i>&nbsp;		if (cls == PathAnnotationObject.class)</b>
<b class="nc"><i>1619</i>&nbsp;			method = &quot;selectAnnotations();&quot;;</b>
<b class="nc"><i>1620</i>&nbsp;		else if (cls == PathDetectionObject.class)</b>
<b class="nc"><i>1621</i>&nbsp;			method = &quot;selectDetections();&quot;;</b>
<b class="nc"><i>1622</i>&nbsp;		else if (cls == TMACoreObject.class)</b>
<b class="nc"><i>1623</i>&nbsp;			method = &quot;selectTMACores();&quot;;</b>
<b class="nc"><i>1624</i>&nbsp;		else if (cls == PathCellObject.class)</b>
<b class="nc"><i>1625</i>&nbsp;			method = &quot;selectCells();&quot;;</b>
<b class="nc"><i>1626</i>&nbsp;		else if (cls == PathTileObject.class)</b>
<b class="nc"><i>1627</i>&nbsp;			method = &quot;selectTiles();&quot;;</b>
<i>1628</i>&nbsp;		else
<i>1629</i>&nbsp;			// TODO: Get a suitable name to disguise Java classes
<b class="nc"><i>1630</i>&nbsp;			method = &quot;selectObjectsByClass(&quot; + cls.getName() + &quot;);&quot;;</b>
<i>1631</i>&nbsp;		
<b class="nc"><i>1632</i>&nbsp;		WorkflowStep newStep = new DefaultScriptableWorkflowStep(&quot;Select objects by class&quot;, params, method);</b>
<b class="nc"><i>1633</i>&nbsp;		WorkflowStep lastStep = imageData.getHistoryWorkflow().getLastStep();</b>
<b class="nc"><i>1634</i>&nbsp;		if (newStep.equals(lastStep))</b>
<b class="nc"><i>1635</i>&nbsp;			imageData.getHistoryWorkflow().replaceLastStep(newStep);</b>
<i>1636</i>&nbsp;		else
<b class="nc"><i>1637</i>&nbsp;			imageData.getHistoryWorkflow().addStep(newStep);</b>
<b class="nc"><i>1638</i>&nbsp;	}</b>
<i>1639</i>&nbsp;
<i>1640</i>&nbsp;
<i>1641</i>&nbsp;
<i>1642</i>&nbsp;	/**
<i>1643</i>&nbsp;	 * Reset the selection for an image.
<i>1644</i>&nbsp;	 * @param imageData
<i>1645</i>&nbsp;	 */
<i>1646</i>&nbsp;	public static void resetSelection(final ImageData&lt;?&gt; imageData) {
<b class="nc"><i>1647</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>1648</i>&nbsp;			logger.warn(&quot;No image available!&quot;);</b>
<b class="nc"><i>1649</i>&nbsp;			return;</b>
<i>1650</i>&nbsp;		}
<i>1651</i>&nbsp;		
<i>1652</i>&nbsp;		// Do the action reset
<b class="nc"><i>1653</i>&nbsp;		imageData.getHierarchy().getSelectionModel().clearSelection();</b>
<i>1654</i>&nbsp;		
<i>1655</i>&nbsp;		// Log the appropriate command
<b class="nc"><i>1656</i>&nbsp;		String method = &quot;resetSelection();&quot;;</b>
<i>1657</i>&nbsp;		
<b class="nc"><i>1658</i>&nbsp;		WorkflowStep newStep = new DefaultScriptableWorkflowStep(&quot;Reset selection&quot;, method);</b>
<b class="nc"><i>1659</i>&nbsp;		WorkflowStep lastStep = imageData.getHistoryWorkflow().getLastStep();</b>
<b class="nc"><i>1660</i>&nbsp;		if (newStep.equals(lastStep))</b>
<b class="nc"><i>1661</i>&nbsp;			imageData.getHistoryWorkflow().replaceLastStep(newStep);</b>
<i>1662</i>&nbsp;		else
<b class="nc"><i>1663</i>&nbsp;			imageData.getHistoryWorkflow().addStep(newStep);</b>
<b class="nc"><i>1664</i>&nbsp;	}</b>
<i>1665</i>&nbsp;
<i>1666</i>&nbsp;
<i>1667</i>&nbsp;
<i>1668</i>&nbsp;	/**
<i>1669</i>&nbsp;	 * Select objects that are instances of a specified class, logging an appropriate method in the workflow.
<i>1670</i>&nbsp;	 * 
<i>1671</i>&nbsp;	 * @param imageData
<i>1672</i>&nbsp;	 * @param cls
<i>1673</i>&nbsp;	 */
<i>1674</i>&nbsp;	public static void resetClassifications(final ImageData&lt;?&gt; imageData, final Class&lt;? extends PathObject&gt; cls) {
<b class="nc"><i>1675</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>1676</i>&nbsp;			logger.warn(&quot;No classifications to reset!&quot;);</b>
<b class="nc"><i>1677</i>&nbsp;			return;</b>
<i>1678</i>&nbsp;		}
<i>1679</i>&nbsp;		// Do the reset
<b class="nc"><i>1680</i>&nbsp;		QP.resetClassifications(imageData.getHierarchy(), cls);</b>
<i>1681</i>&nbsp;		
<i>1682</i>&nbsp;		// Log the appropriate command
<b class="nc"><i>1683</i>&nbsp;		Map&lt;String, String&gt; params = Collections.singletonMap(&quot;Type&quot;, PathObjectTools.getSuitableName(cls, false));</b>
<i>1684</i>&nbsp;		String method;
<b class="nc"><i>1685</i>&nbsp;		if (cls == PathDetectionObject.class)</b>
<b class="nc"><i>1686</i>&nbsp;			method = &quot;resetDetectionClassifications();&quot;;</b>
<i>1687</i>&nbsp;		else // TODO: Get a suitable name to disguise Java classes
<b class="nc"><i>1688</i>&nbsp;			method = &quot;resetClassifications(&quot; + cls.getName() + &quot;);&quot;;</b>
<i>1689</i>&nbsp;		
<b class="nc"><i>1690</i>&nbsp;		WorkflowStep newStep = new DefaultScriptableWorkflowStep(&quot;Reset classifications&quot;, params, method);</b>
<b class="nc"><i>1691</i>&nbsp;		WorkflowStep lastStep = imageData.getHistoryWorkflow().getLastStep();</b>
<b class="nc"><i>1692</i>&nbsp;		if (newStep.equals(lastStep))</b>
<b class="nc"><i>1693</i>&nbsp;			imageData.getHistoryWorkflow().replaceLastStep(newStep);</b>
<i>1694</i>&nbsp;		else
<b class="nc"><i>1695</i>&nbsp;			imageData.getHistoryWorkflow().addStep(newStep);</b>
<b class="nc"><i>1696</i>&nbsp;	}</b>
<i>1697</i>&nbsp;	
<i>1698</i>&nbsp;	
<i>1699</i>&nbsp;	/**
<i>1700</i>&nbsp;	 * Create a dialog to show the workflow history for the current image data.
<i>1701</i>&nbsp;	 * @param qupath the QuPath instance
<i>1702</i>&nbsp;	 * @return a workflow display dialog
<i>1703</i>&nbsp;	 */
<i>1704</i>&nbsp;	public static Stage createWorkflowDisplayDialog(QuPathGUI qupath) {
<b class="nc"><i>1705</i>&nbsp;		var view = new WorkflowCommandLogView(qupath);</b>
<b class="nc"><i>1706</i>&nbsp;		Stage dialog = new Stage();</b>
<b class="nc"><i>1707</i>&nbsp;		dialog.initOwner(qupath.getStage());</b>
<b class="nc"><i>1708</i>&nbsp;		dialog.setTitle(&quot;Workflow viewer&quot;);</b>
<b class="nc"><i>1709</i>&nbsp;		Pane pane = view.getPane();</b>
<b class="nc"><i>1710</i>&nbsp;		dialog.setScene(new Scene(pane, 400, 400));</b>
<b class="nc"><i>1711</i>&nbsp;		return dialog;</b>
<i>1712</i>&nbsp;	}
<i>1713</i>&nbsp;	
<i>1714</i>&nbsp;	
<i>1715</i>&nbsp;	/**
<i>1716</i>&nbsp;	 * Show the QuPath script editor with a script corresponding to the command history of a specified image.
<i>1717</i>&nbsp;	 * @param qupath
<i>1718</i>&nbsp;	 * @param imageData
<i>1719</i>&nbsp;	 */
<i>1720</i>&nbsp;	public static void showWorkflowScript(QuPathGUI qupath, ImageData&lt;?&gt; imageData) {
<b class="nc"><i>1721</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>1722</i>&nbsp;			Dialogs.showNoImageError(&quot;Show workflow script&quot;);</b>
<b class="nc"><i>1723</i>&nbsp;			return;</b>
<i>1724</i>&nbsp;		}
<b class="nc"><i>1725</i>&nbsp;		WorkflowCommandLogView.showScript(qupath.getScriptEditor(), imageData.getHistoryWorkflow());</b>
<b class="nc"><i>1726</i>&nbsp;	}</b>
<i>1727</i>&nbsp;	
<i>1728</i>&nbsp;	
<i>1729</i>&nbsp;	/**
<i>1730</i>&nbsp;	 * Show the script editor, or bring the window to the front if it is already open.
<i>1731</i>&nbsp;	 * @param qupath
<i>1732</i>&nbsp;	 */
<i>1733</i>&nbsp;	public static void showScriptEditor(QuPathGUI qupath) {
<b class="nc"><i>1734</i>&nbsp;		var scriptEditor = qupath.getScriptEditor();</b>
<b class="nc"><i>1735</i>&nbsp;		if (scriptEditor == null) {</b>
<b class="nc"><i>1736</i>&nbsp;			Dialogs.showErrorMessage(&quot;Script editor&quot;, &quot;No script editor found!&quot;);</b>
<b class="nc"><i>1737</i>&nbsp;			return;</b>
<i>1738</i>&nbsp;		}
<i>1739</i>&nbsp;		// Show script editor with a new script
<b class="nc"><i>1740</i>&nbsp;		if ((scriptEditor instanceof Window) &amp;&amp; ((Window)scriptEditor).isShowing())</b>
<b class="nc"><i>1741</i>&nbsp;			((Window)scriptEditor).toFront();</b>
<i>1742</i>&nbsp;		else
<b class="nc"><i>1743</i>&nbsp;			scriptEditor.showEditor();</b>
<b class="nc"><i>1744</i>&nbsp;	}</b>
<i>1745</i>&nbsp;
<i>1746</i>&nbsp;	/**
<i>1747</i>&nbsp;	 * Create a dialog to monitor memory usage.
<i>1748</i>&nbsp;	 * @param qupath
<i>1749</i>&nbsp;	 * @return
<i>1750</i>&nbsp;	 */
<i>1751</i>&nbsp;	public static Stage createMemoryMonitorDialog(QuPathGUI qupath) {
<b class="nc"><i>1752</i>&nbsp;		return new MemoryMonitorDialog(qupath).getStage();</b>
<i>1753</i>&nbsp;	}
<i>1754</i>&nbsp;
<i>1755</i>&nbsp;	/**
<i>1756</i>&nbsp;	 * Show a mini viewer window associated with a specific viewer.
<i>1757</i>&nbsp;	 * @param viewer the viewer with which to associate this window
<i>1758</i>&nbsp;	 */
<i>1759</i>&nbsp;	public static void showMiniViewer(QuPathViewer viewer) {
<b class="nc"><i>1760</i>&nbsp;		if (viewer == null)</b>
<b class="nc"><i>1761</i>&nbsp;			return;</b>
<b class="nc"><i>1762</i>&nbsp;		MiniViewers.createDialog(viewer, false).show();</b>
<b class="nc"><i>1763</i>&nbsp;	}</b>
<i>1764</i>&nbsp;
<i>1765</i>&nbsp;	/**
<i>1766</i>&nbsp;	 * Show a channel viewer window associated with a specific viewer.
<i>1767</i>&nbsp;	 * @param viewer the viewer with which to associate this window
<i>1768</i>&nbsp;	 */
<i>1769</i>&nbsp;	public static void showChannelViewer(QuPathViewer viewer) {
<b class="nc"><i>1770</i>&nbsp;		if (viewer == null)</b>
<b class="nc"><i>1771</i>&nbsp;			return;</b>
<b class="nc"><i>1772</i>&nbsp;		MiniViewers.createDialog(viewer, true).show();</b>
<b class="nc"><i>1773</i>&nbsp;	}</b>
<i>1774</i>&nbsp;	
<i>1775</i>&nbsp;	
<i>1776</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2021-01-25 09:46</div>
</div>
</body>
</html>
