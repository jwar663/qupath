


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: SummaryMeasurementTableCommand</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">qupath.lib.gui.commands</a> ]
</div>

<h1>Coverage Summary for Class: SummaryMeasurementTableCommand (qupath.lib.gui.commands)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SummaryMeasurementTableCommand</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 298)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SummaryMeasurementTableCommand$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SummaryMeasurementTableCommand$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SummaryMeasurementTableCommand$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SummaryMeasurementTableCommand$BasicTableCell</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SummaryMeasurementTableCommand$NumericTableCell</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SummaryMeasurementTableCommand$TableViewerListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SummaryMeasurementTableCommand$TMACoreTableCell</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 39)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 57)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 384)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*-
<i>2</i>&nbsp; * #%L
<i>3</i>&nbsp; * This file is part of QuPath.
<i>4</i>&nbsp; * %%
<i>5</i>&nbsp; * Copyright (C) 2014 - 2016 The Queen&#39;s University of Belfast, Northern Ireland
<i>6</i>&nbsp; * Contact: IP Management (ipmanagement@qub.ac.uk)
<i>7</i>&nbsp; * Copyright (C) 2018 - 2020 QuPath developers, The University of Edinburgh
<i>8</i>&nbsp; * %%
<i>9</i>&nbsp; * QuPath is free software: you can redistribute it and/or modify
<i>10</i>&nbsp; * it under the terms of the GNU General Public License as
<i>11</i>&nbsp; * published by the Free Software Foundation, either version 3 of the
<i>12</i>&nbsp; * License, or (at your option) any later version.
<i>13</i>&nbsp; * 
<i>14</i>&nbsp; * QuPath is distributed in the hope that it will be useful,
<i>15</i>&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
<i>16</i>&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<i>17</i>&nbsp; * GNU General Public License for more details.
<i>18</i>&nbsp; * 
<i>19</i>&nbsp; * You should have received a copy of the GNU General Public License 
<i>20</i>&nbsp; * along with QuPath.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
<i>21</i>&nbsp; * #L%
<i>22</i>&nbsp; */
<i>23</i>&nbsp;
<i>24</i>&nbsp;package qupath.lib.gui.commands;
<i>25</i>&nbsp;
<i>26</i>&nbsp;import java.awt.Shape;
<i>27</i>&nbsp;import java.awt.image.BufferedImage;
<i>28</i>&nbsp;import java.io.File;
<i>29</i>&nbsp;import java.io.IOException;
<i>30</i>&nbsp;import java.io.PrintWriter;
<i>31</i>&nbsp;import java.nio.charset.StandardCharsets;
<i>32</i>&nbsp;import java.util.ArrayList;
<i>33</i>&nbsp;import java.util.Arrays;
<i>34</i>&nbsp;import java.util.Collection;
<i>35</i>&nbsp;import java.util.Collections;
<i>36</i>&nbsp;import java.util.HashSet;
<i>37</i>&nbsp;import java.util.LinkedHashMap;
<i>38</i>&nbsp;import java.util.List;
<i>39</i>&nbsp;import java.util.Map;
<i>40</i>&nbsp;import java.util.Set;
<i>41</i>&nbsp;import java.util.stream.Collectors;
<i>42</i>&nbsp;
<i>43</i>&nbsp;import org.slf4j.Logger;
<i>44</i>&nbsp;import org.slf4j.LoggerFactory;
<i>45</i>&nbsp;
<i>46</i>&nbsp;import javafx.application.Platform;
<i>47</i>&nbsp;import javafx.beans.property.SimpleObjectProperty;
<i>48</i>&nbsp;import javafx.beans.property.StringProperty;
<i>49</i>&nbsp;import javafx.collections.ListChangeListener;
<i>50</i>&nbsp;import javafx.collections.transformation.SortedList;
<i>51</i>&nbsp;import javafx.embed.swing.SwingFXUtils;
<i>52</i>&nbsp;import javafx.geometry.Insets;
<i>53</i>&nbsp;import javafx.geometry.Pos;
<i>54</i>&nbsp;import javafx.scene.Scene;
<i>55</i>&nbsp;import javafx.scene.canvas.Canvas;
<i>56</i>&nbsp;import javafx.scene.control.Button;
<i>57</i>&nbsp;import javafx.scene.control.ButtonBase;
<i>58</i>&nbsp;import javafx.scene.control.CheckBox;
<i>59</i>&nbsp;import javafx.scene.control.ContentDisplay;
<i>60</i>&nbsp;import javafx.scene.control.ContextMenu;
<i>61</i>&nbsp;import javafx.scene.control.Label;
<i>62</i>&nbsp;import javafx.scene.control.Menu;
<i>63</i>&nbsp;import javafx.scene.control.MenuItem;
<i>64</i>&nbsp;import javafx.scene.control.MultipleSelectionModel;
<i>65</i>&nbsp;import javafx.scene.control.SelectionMode;
<i>66</i>&nbsp;import javafx.scene.control.SplitPane;
<i>67</i>&nbsp;import javafx.scene.control.TableCell;
<i>68</i>&nbsp;import javafx.scene.control.TableColumn;
<i>69</i>&nbsp;import javafx.scene.control.TableRow;
<i>70</i>&nbsp;import javafx.scene.control.TableView;
<i>71</i>&nbsp;import javafx.scene.control.TableView.TableViewSelectionModel;
<i>72</i>&nbsp;import javafx.scene.control.TextField;
<i>73</i>&nbsp;import javafx.scene.control.ToggleButton;
<i>74</i>&nbsp;import javafx.scene.image.Image;
<i>75</i>&nbsp;import javafx.scene.input.Clipboard;
<i>76</i>&nbsp;import javafx.scene.input.ClipboardContent;
<i>77</i>&nbsp;import javafx.scene.layout.BorderPane;
<i>78</i>&nbsp;import javafx.scene.layout.GridPane;
<i>79</i>&nbsp;import javafx.scene.layout.Pane;
<i>80</i>&nbsp;import javafx.scene.layout.Priority;
<i>81</i>&nbsp;import javafx.stage.Stage;
<i>82</i>&nbsp;import qupath.lib.common.GeneralTools;
<i>83</i>&nbsp;import qupath.lib.gui.QuPathGUI;
<i>84</i>&nbsp;import qupath.lib.gui.charts.HistogramDisplay;
<i>85</i>&nbsp;import qupath.lib.gui.dialogs.Dialogs;
<i>86</i>&nbsp;import qupath.lib.gui.measure.ObservableMeasurementTableData;
<i>87</i>&nbsp;import qupath.lib.gui.measure.PathTableData;
<i>88</i>&nbsp;import qupath.lib.gui.prefs.PathPrefs;
<i>89</i>&nbsp;import qupath.lib.gui.tools.GuiTools;
<i>90</i>&nbsp;import qupath.lib.gui.tools.PaneTools;
<i>91</i>&nbsp;import qupath.lib.gui.viewer.QuPathViewer;
<i>92</i>&nbsp;import qupath.lib.gui.viewer.QuPathViewerListener;
<i>93</i>&nbsp;import qupath.lib.images.ImageData;
<i>94</i>&nbsp;import qupath.lib.images.servers.ImageServer;
<i>95</i>&nbsp;import qupath.lib.images.servers.ServerTools;
<i>96</i>&nbsp;import qupath.lib.objects.PathAnnotationObject;
<i>97</i>&nbsp;import qupath.lib.objects.PathDetectionObject;
<i>98</i>&nbsp;import qupath.lib.objects.PathObject;
<i>99</i>&nbsp;import qupath.lib.objects.PathObjectTools;
<i>100</i>&nbsp;import qupath.lib.objects.TMACoreObject;
<i>101</i>&nbsp;import qupath.lib.objects.classes.PathClass;
<i>102</i>&nbsp;import qupath.lib.objects.hierarchy.PathObjectHierarchy;
<i>103</i>&nbsp;import qupath.lib.objects.hierarchy.events.PathObjectHierarchyEvent;
<i>104</i>&nbsp;import qupath.lib.objects.hierarchy.events.PathObjectHierarchyListener;
<i>105</i>&nbsp;import qupath.lib.objects.hierarchy.events.PathObjectSelectionModel;
<i>106</i>&nbsp;import qupath.lib.plugins.workflow.DefaultScriptableWorkflowStep;
<i>107</i>&nbsp;import qupath.lib.plugins.workflow.WorkflowStep;
<i>108</i>&nbsp;import qupath.lib.regions.RegionRequest;
<i>109</i>&nbsp;import qupath.lib.roi.interfaces.ROI;
<i>110</i>&nbsp;
<i>111</i>&nbsp;
<i>112</i>&nbsp;/**
<i>113</i>&nbsp; * Show a summary table for an object of a particular type (annotation, detection, TMA core...)
<i>114</i>&nbsp; * 
<i>115</i>&nbsp; * @author Pete Bankhead
<i>116</i>&nbsp; */
<i>117</i>&nbsp;public class SummaryMeasurementTableCommand {
<i>118</i>&nbsp;
<b class="nc"><i>119</i>&nbsp;	final private static Logger logger = LoggerFactory.getLogger(SummaryMeasurementTableCommand.class);</b>
<i>120</i>&nbsp;
<i>121</i>&nbsp;	private QuPathGUI qupath;
<i>122</i>&nbsp;	
<i>123</i>&nbsp;	/**
<i>124</i>&nbsp;	 * Max thumbnails to store in cache
<i>125</i>&nbsp;	 */
<b class="nc"><i>126</i>&nbsp;	private static int MAX_CACHE_SIZE = 200;</b>
<i>127</i>&nbsp;	
<i>128</i>&nbsp;	/**
<i>129</i>&nbsp;	 * Cache for storing image thumbnails
<i>130</i>&nbsp;	 */
<b class="nc"><i>131</i>&nbsp;	private static Map&lt;ROI, Image&gt; cache = new LinkedHashMap&lt;ROI, Image&gt;() {</b>
<i>132</i>&nbsp;		private static final long serialVersionUID = 1L;
<i>133</i>&nbsp;		@Override
<i>134</i>&nbsp;		protected synchronized boolean removeEldestEntry(Map.Entry&lt;ROI, Image&gt; eldest) {
<b class="nc"><i>135</i>&nbsp;			return size() &gt; MAX_CACHE_SIZE;</b>
<i>136</i>&nbsp;		}
<i>137</i>&nbsp;
<i>138</i>&nbsp;	};
<i>139</i>&nbsp;	
<i>140</i>&nbsp;	/**
<i>141</i>&nbsp;	 * Max thumbnail size
<i>142</i>&nbsp;	 */
<b class="nc"><i>143</i>&nbsp;	private static double maxDimForTMACore = Runtime.getRuntime().maxMemory() &gt; 1024L*1024L*1024L*4L ? 500 : 250;</b>
<i>144</i>&nbsp;
<i>145</i>&nbsp;	/**
<i>146</i>&nbsp;	 * Command to show a summary measurement table, for PathObjects of a specified type (e.g. annotation, detection).
<i>147</i>&nbsp;	 * @param qupath
<i>148</i>&nbsp;	 */
<i>149</i>&nbsp;	public SummaryMeasurementTableCommand(final QuPathGUI qupath) {
<b class="nc"><i>150</i>&nbsp;		super();</b>
<b class="nc"><i>151</i>&nbsp;		this.qupath = qupath;</b>
<i>152</i>&nbsp;	}
<i>153</i>&nbsp;
<i>154</i>&nbsp;	/**
<i>155</i>&nbsp;	 * Show a measurement table for the specified image data.
<i>156</i>&nbsp;	 * @param imageData the image data
<i>157</i>&nbsp;	 * @param type the object type to show
<i>158</i>&nbsp;	 */
<i>159</i>&nbsp;	public void showTable(ImageData&lt;BufferedImage&gt; imageData, Class&lt;? extends PathObject&gt; type) {
<b class="nc"><i>160</i>&nbsp;		if (imageData == null) {</b>
<b class="nc"><i>161</i>&nbsp;			Dialogs.showNoImageError(&quot;Show measurement table&quot;);</b>
<i>162</i>&nbsp;			return;
<i>163</i>&nbsp;		}
<i>164</i>&nbsp;
<b class="nc"><i>165</i>&nbsp;		final PathObjectHierarchy hierarchy = imageData.getHierarchy();</b>
<i>166</i>&nbsp;
<b class="nc"><i>167</i>&nbsp;		ObservableMeasurementTableData model = new ObservableMeasurementTableData();</b>
<b class="nc"><i>168</i>&nbsp;		model.setImageData(imageData, imageData == null ? Collections.emptyList() : imageData.getHierarchy().getObjects(null, type));</b>
<i>169</i>&nbsp;
<b class="nc"><i>170</i>&nbsp;		SplitPane splitPane = new SplitPane();</b>
<b class="nc"><i>171</i>&nbsp;		HistogramDisplay histogramDisplay = new HistogramDisplay(model, true);</b>
<i>172</i>&nbsp;
<i>173</i>&nbsp;		//		table.setTableMenuButtonVisible(true);
<b class="nc"><i>174</i>&nbsp;		TableView&lt;PathObject&gt; table = new TableView&lt;&gt;();</b>
<b class="nc"><i>175</i>&nbsp;		table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);</b>
<b class="nc"><i>176</i>&nbsp;		table.getSelectionModel().getSelectedItems().addListener(new ListChangeListener&lt;PathObject&gt;() {</b>
<i>177</i>&nbsp;			@Override
<i>178</i>&nbsp;			public void onChanged(ListChangeListener.Change&lt;? extends PathObject&gt; c) {
<b class="nc"><i>179</i>&nbsp;				synchronizeSelectionModelToTable(hierarchy, c, table);</b>
<i>180</i>&nbsp;			}
<i>181</i>&nbsp;		});
<b class="nc"><i>182</i>&nbsp;		String displayedName = ServerTools.getDisplayableImageName(imageData.getServer());</b>
<i>183</i>&nbsp;		String name;
<b class="nc"><i>184</i>&nbsp;		if (type == null)</b>
<b class="nc"><i>185</i>&nbsp;			name = &quot;Results &quot; + displayedName;</b>
<i>186</i>&nbsp;		else
<b class="nc"><i>187</i>&nbsp;			name = PathObjectTools.getSuitableName(type, false) + &quot; results - &quot; + displayedName;</b>
<i>188</i>&nbsp;
<i>189</i>&nbsp;		// Handle double-click as a way to center on a ROI
<i>190</i>&nbsp;//		var enter = new KeyCodeCombination(KeyCode.ENTER);
<b class="nc"><i>191</i>&nbsp;		table.setRowFactory(params -&gt; {</b>
<b class="nc"><i>192</i>&nbsp;			var row = new TableRow&lt;PathObject&gt;() ;</b>
<b class="nc"><i>193</i>&nbsp;			row.setOnMouseClicked(e -&gt; {</b>
<b class="nc"><i>194</i>&nbsp;				if (e.getClickCount() == 2) {</b>
<b class="nc"><i>195</i>&nbsp;					maybeCenterROI(row.getItem());</b>
<i>196</i>&nbsp;				}
<i>197</i>&nbsp;			});
<i>198</i>&nbsp;//			row.setOnKeyPressed(e -&gt; {
<i>199</i>&nbsp;//				if (enter.match(e))
<i>200</i>&nbsp;//					maybeCenterROI(row.getItem());
<i>201</i>&nbsp;//			});
<b class="nc"><i>202</i>&nbsp;			return row;</b>
<i>203</i>&nbsp;		});
<i>204</i>&nbsp;
<i>205</i>&nbsp;		// Create columns according to the table model
<i>206</i>&nbsp;//		for (int i = 0; i &lt; model.getColumnCount(); i++) {
<i>207</i>&nbsp;//			// Add string column
<i>208</i>&nbsp;//			if (model.getColumnClass(i).equals(String.class)) {
<i>209</i>&nbsp;//				TableColumn&lt;PathObject, String&gt; col = null;
<i>210</i>&nbsp;//				col = new TableColumn&lt;&gt;(model.getColumnName(i));
<i>211</i>&nbsp;//				col.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;PathObject, String&gt;, ObservableValue&lt;String&gt;&gt;() {
<i>212</i>&nbsp;//					public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;PathObject, String&gt; val) {
<i>213</i>&nbsp;//						return new SimpleStringProperty(val.getValue().getDisplayedName());
<i>214</i>&nbsp;//					}
<i>215</i>&nbsp;//				});
<i>216</i>&nbsp;//				col.setCellFactory(column -&gt; new BasicTableCell&lt;String&gt;());
<i>217</i>&nbsp;//				table.getColumns().add(col);
<i>218</i>&nbsp;//			}
<i>219</i>&nbsp;//		}
<i>220</i>&nbsp;		
<b class="nc"><i>221</i>&nbsp;		boolean tmaCoreList = TMACoreObject.class.isAssignableFrom(type);</b>
<i>222</i>&nbsp;		
<i>223</i>&nbsp;		// Add TMA core columns, if suitable
<b class="nc"><i>224</i>&nbsp;		if (tmaCoreList) {</b>
<b class="nc"><i>225</i>&nbsp;			TableColumn&lt;PathObject, ROI&gt; col = new TableColumn&lt;&gt;(&quot;Image&quot;);</b>
<b class="nc"><i>226</i>&nbsp;			col.setCellValueFactory(val -&gt; new SimpleObjectProperty&lt;&gt;(val.getValue().getROI()));</b>
<b class="nc"><i>227</i>&nbsp;			double maxWidth = maxDimForTMACore;</b>
<b class="nc"><i>228</i>&nbsp;			double padding = 10;</b>
<b class="nc"><i>229</i>&nbsp;			col.setCellFactory(column -&gt; new TMACoreTableCell(table, imageData.getServer(), maxWidth, padding));</b>
<b class="nc"><i>230</i>&nbsp;			col.widthProperty().addListener((v, o, n) -&gt; table.refresh());</b>
<b class="nc"><i>231</i>&nbsp;			col.setMaxWidth(maxWidth + padding*2);</b>
<b class="nc"><i>232</i>&nbsp;			table.getColumns().add(col);</b>
<i>233</i>&nbsp;			
<i>234</i>&nbsp;			// While here, make sure we have fewer bins - don&#39;t usually have all that many cores
<b class="nc"><i>235</i>&nbsp;			histogramDisplay.setNumBins(10);</b>
<i>236</i>&nbsp;		}
<i>237</i>&nbsp;		
<i>238</i>&nbsp;//		// TODO: Create object columns
<i>239</i>&nbsp;//		TableColumn&lt;PathObject, String&gt; colObject = new TableColumn&lt;&gt;(&quot;Object&quot;);
<i>240</i>&nbsp;//		colObject.setCellValueFactory(column -&gt; new SimpleStringProperty(column.getValue().getDisplayedName()));
<i>241</i>&nbsp;//		colObject.setCellFactory(column -&gt; new BasicTableCell&lt;&gt;());
<i>242</i>&nbsp;//		table.getColumns().add(colObject);
<i>243</i>&nbsp;//		
<i>244</i>&nbsp;//		if (!tmaCoreList) {
<i>245</i>&nbsp;//			TableColumn&lt;PathObject, String&gt; colClass = new TableColumn&lt;&gt;(&quot;Class&quot;);
<i>246</i>&nbsp;//			colClass.setCellValueFactory(column -&gt; new SimpleStringProperty(column.getValue().getPathClass() == null ? &quot;-&quot; : column.getValue().getPathClass().toString()));
<i>247</i>&nbsp;//			colClass.setCellFactory(column -&gt; new BasicTableCell&lt;&gt;());
<i>248</i>&nbsp;//			table.getColumns().add(colClass);
<i>249</i>&nbsp;//		}
<i>250</i>&nbsp;		
<i>251</i>&nbsp;//		// If we have annotations, include shape
<i>252</i>&nbsp;//		if (PathAnnotationObject.class.isAssignableFrom(type)) {
<i>253</i>&nbsp;//			TableColumn&lt;PathObject, String&gt; colClass = new TableColumn&lt;&gt;(&quot;ROI&quot;);
<i>254</i>&nbsp;//			colClass.setCellValueFactory(column -&gt; new SimpleStringProperty(column.getValue().getROI() == null ? &quot;-&quot; : column.getValue().getROI().getROIType()));
<i>255</i>&nbsp;//			colClass.setCellFactory(column -&gt; new BasicTableCell&lt;&gt;());
<i>256</i>&nbsp;//			table.getColumns().add(colClass);
<i>257</i>&nbsp;//		}
<i>258</i>&nbsp;			
<i>259</i>&nbsp;			
<i>260</i>&nbsp;		// Create numeric columns
<b class="nc"><i>261</i>&nbsp;		for (String columnName : model.getAllNames()) {</b>
<i>262</i>&nbsp;			// Add column
<b class="nc"><i>263</i>&nbsp;			if (model.isStringMeasurement(columnName)) {</b>
<b class="nc"><i>264</i>&nbsp;				TableColumn&lt;PathObject, String&gt; col = new TableColumn&lt;&gt;(columnName);</b>
<b class="nc"><i>265</i>&nbsp;				col.setCellValueFactory(column -&gt; model.createStringMeasurement(column.getValue(), column.getTableColumn().getText()));</b>
<b class="nc"><i>266</i>&nbsp;				col.setCellFactory(column -&gt; new BasicTableCell&lt;&gt;());</b>
<b class="nc"><i>267</i>&nbsp;				table.getColumns().add(col);			</b>
<b class="nc"><i>268</i>&nbsp;			} else {</b>
<b class="nc"><i>269</i>&nbsp;				TableColumn&lt;PathObject, Number&gt; col = new TableColumn&lt;&gt;(columnName);</b>
<b class="nc"><i>270</i>&nbsp;				col.setCellValueFactory(column -&gt; model.createNumericMeasurement(column.getValue(), column.getTableColumn().getText()));</b>
<b class="nc"><i>271</i>&nbsp;				col.setCellFactory(column -&gt; new NumericTableCell&lt;PathObject&gt;(histogramDisplay));</b>
<b class="nc"><i>272</i>&nbsp;				table.getColumns().add(col);			</b>
<i>273</i>&nbsp;			}
<b class="nc"><i>274</i>&nbsp;		}</b>
<i>275</i>&nbsp;
<i>276</i>&nbsp;
<i>277</i>&nbsp;		// Set the PathObjects - need to deal with sorting, since a FilteredList won&#39;t handle it directly
<b class="nc"><i>278</i>&nbsp;		SortedList&lt;PathObject&gt; items = new SortedList&lt;&gt;(model.getItems());</b>
<b class="nc"><i>279</i>&nbsp;		items.comparatorProperty().bind(table.comparatorProperty());</b>
<b class="nc"><i>280</i>&nbsp;		table.setItems(items);</b>
<i>281</i>&nbsp;
<i>282</i>&nbsp;
<i>283</i>&nbsp;
<i>284</i>&nbsp;
<b class="nc"><i>285</i>&nbsp;		List&lt;ButtonBase&gt; buttons = new ArrayList&lt;&gt;();</b>
<i>286</i>&nbsp;		
<b class="nc"><i>287</i>&nbsp;		ToggleButton btnHistogram = new ToggleButton(&quot;Show histograms&quot;);</b>
<b class="nc"><i>288</i>&nbsp;		btnHistogram.selectedProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>289</i>&nbsp;			if (n) {</b>
<b class="nc"><i>290</i>&nbsp;				Pane paneHistograms = histogramDisplay.getPane();</b>
<b class="nc"><i>291</i>&nbsp;				splitPane.getItems().add(paneHistograms);</b>
<b class="nc"><i>292</i>&nbsp;			} else if (histogramDisplay != null)</b>
<b class="nc"><i>293</i>&nbsp;				splitPane.getItems().remove(histogramDisplay.getPane());</b>
<i>294</i>&nbsp;		});
<b class="nc"><i>295</i>&nbsp;		buttons.add(btnHistogram);</b>
<i>296</i>&nbsp;
<i>297</i>&nbsp;//		Button btnScatterplot = new Button(&quot;Show scatterplots&quot;);
<i>298</i>&nbsp;//		btnScatterplot.setOnAction(e -&gt; {
<i>299</i>&nbsp;//			SwingUtilities.invokeLater(() -&gt; {
<i>300</i>&nbsp;//				JDialog dialog = new ScatterplotDisplay(null, &quot;Scatterplots: &quot; + displayedName, model).getDialog();
<i>301</i>&nbsp;//				dialog.setLocationRelativeTo(null);
<i>302</i>&nbsp;//				dialog.setVisible(true);
<i>303</i>&nbsp;//			});
<i>304</i>&nbsp;//		});
<i>305</i>&nbsp;//		buttons.add(btnScatterplot);
<i>306</i>&nbsp;		
<i>307</i>&nbsp;		
<b class="nc"><i>308</i>&nbsp;		Button btnCopy = new Button(&quot;Copy to clipboard&quot;);</b>
<b class="nc"><i>309</i>&nbsp;		btnCopy.setOnAction(e -&gt; {</b>
<i>310</i>&nbsp;			// TODO: Deal with repetition immediately below...
<b class="nc"><i>311</i>&nbsp;			Set&lt;String&gt; excludeColumns = new HashSet&lt;&gt;();</b>
<b class="nc"><i>312</i>&nbsp;			for (TableColumn&lt;?, ?&gt; col : table.getColumns()) {</b>
<b class="nc"><i>313</i>&nbsp;				if (!col.isVisible())</b>
<b class="nc"><i>314</i>&nbsp;					excludeColumns.add(col.getText());</b>
<b class="nc"><i>315</i>&nbsp;			}</b>
<b class="nc"><i>316</i>&nbsp;			copyTableContentsToClipboard(model, excludeColumns);</b>
<i>317</i>&nbsp;		});
<b class="nc"><i>318</i>&nbsp;		buttons.add(btnCopy);</b>
<i>319</i>&nbsp;
<b class="nc"><i>320</i>&nbsp;		Button btnSave = new Button(&quot;Save&quot;);</b>
<b class="nc"><i>321</i>&nbsp;		btnSave.setOnAction(e -&gt; {</b>
<b class="nc"><i>322</i>&nbsp;			Set&lt;String&gt; excludeColumns = new HashSet&lt;&gt;();</b>
<b class="nc"><i>323</i>&nbsp;			for (TableColumn&lt;?, ?&gt; col : table.getColumns()) {</b>
<b class="nc"><i>324</i>&nbsp;				if (!col.isVisible())</b>
<b class="nc"><i>325</i>&nbsp;					excludeColumns.add(col.getText());</b>
<b class="nc"><i>326</i>&nbsp;			}</b>
<b class="nc"><i>327</i>&nbsp;			File fileOutput = promptForOutputFile();</b>
<b class="nc"><i>328</i>&nbsp;			if (fileOutput == null)</b>
<i>329</i>&nbsp;				return;
<b class="nc"><i>330</i>&nbsp;			if (saveTableModel(model, fileOutput, excludeColumns)) {</b>
<i>331</i>&nbsp;				WorkflowStep step;
<i>332</i>&nbsp;				String includeColumns;
<b class="nc"><i>333</i>&nbsp;				if (excludeColumns.isEmpty())</b>
<b class="nc"><i>334</i>&nbsp;					includeColumns = &quot;&quot;;</b>
<i>335</i>&nbsp;				else {
<b class="nc"><i>336</i>&nbsp;					List&lt;String&gt; includeColumnList = new ArrayList&lt;&gt;(model.getAllNames());</b>
<b class="nc"><i>337</i>&nbsp;					includeColumnList.removeAll(excludeColumns);</b>
<b class="nc"><i>338</i>&nbsp;					includeColumns = &quot;, &quot; + includeColumnList.stream().map(s -&gt; &quot;&#39;&quot; + s + &quot;&#39;&quot;).collect(Collectors.joining(&quot;, &quot;));</b>
<i>339</i>&nbsp;				}
<b class="nc"><i>340</i>&nbsp;				String path = qupath.getProject() == null ? fileOutput.toURI().getPath() : fileOutput.getParentFile().toURI().getPath();</b>
<b class="nc"><i>341</i>&nbsp;				if (type == TMACoreObject.class) {</b>
<b class="nc"><i>342</i>&nbsp;					step = new DefaultScriptableWorkflowStep(&quot;Save TMA measurements&quot;,</b>
<b class="nc"><i>343</i>&nbsp;							String.format(&quot;saveTMAMeasurements(&#39;%s&#39;%s)&quot;, path, includeColumns)</b>
<i>344</i>&nbsp;							);
<i>345</i>&nbsp;				}
<b class="nc"><i>346</i>&nbsp;				else if (type == PathAnnotationObject.class) {</b>
<b class="nc"><i>347</i>&nbsp;					step = new DefaultScriptableWorkflowStep(&quot;Save annotation measurements&quot;,</b>
<b class="nc"><i>348</i>&nbsp;							String.format(&quot;saveAnnotationMeasurements(&#39;%s\&#39;%s)&quot;, path, includeColumns)</b>
<i>349</i>&nbsp;							);
<b class="nc"><i>350</i>&nbsp;				} else if (type == PathDetectionObject.class) {</b>
<b class="nc"><i>351</i>&nbsp;					step = new DefaultScriptableWorkflowStep(&quot;Save detection measurements&quot;,</b>
<b class="nc"><i>352</i>&nbsp;							String.format(&quot;saveDetectionMeasurements(&#39;%s&#39;%s)&quot;, path, includeColumns)</b>
<i>353</i>&nbsp;							);
<i>354</i>&nbsp;				} else {
<b class="nc"><i>355</i>&nbsp;					step = new DefaultScriptableWorkflowStep(&quot;Save measurements&quot;,</b>
<b class="nc"><i>356</i>&nbsp;							String.format(&quot;saveMeasurements(&#39;%s&#39;, %s%s)&quot;, path, type == null ? null : type.getName(), includeColumns)</b>
<i>357</i>&nbsp;							);
<i>358</i>&nbsp;				}
<b class="nc"><i>359</i>&nbsp;				imageData.getHistoryWorkflow().addStep(step);</b>
<i>360</i>&nbsp;			}
<i>361</i>&nbsp;		});
<b class="nc"><i>362</i>&nbsp;		buttons.add(btnSave);</b>
<i>363</i>&nbsp;
<i>364</i>&nbsp;
<b class="nc"><i>365</i>&nbsp;		Stage frame = new Stage();</b>
<b class="nc"><i>366</i>&nbsp;		frame.initOwner(qupath.getStage());</b>
<b class="nc"><i>367</i>&nbsp;		frame.setTitle(name);</b>
<i>368</i>&nbsp;
<i>369</i>&nbsp;
<b class="nc"><i>370</i>&nbsp;		BorderPane paneTable = new BorderPane();</b>
<b class="nc"><i>371</i>&nbsp;		paneTable.setCenter(table);</b>
<i>372</i>&nbsp;		// Add text field to filter visible columns
<b class="nc"><i>373</i>&nbsp;		TextField tfColumnFilter = new TextField();</b>
<b class="nc"><i>374</i>&nbsp;		GridPane paneFilter = new GridPane();</b>
<b class="nc"><i>375</i>&nbsp;		paneFilter.add(new Label(&quot;Column filter&quot;), 0, 0);</b>
<b class="nc"><i>376</i>&nbsp;		paneFilter.add(tfColumnFilter, 1, 0);</b>
<b class="nc"><i>377</i>&nbsp;		GridPane.setHgrow(tfColumnFilter, Priority.ALWAYS);</b>
<b class="nc"><i>378</i>&nbsp;		paneFilter.setHgap(5);</b>
<b class="nc"><i>379</i>&nbsp;		if (tmaCoreList) {</b>
<b class="nc"><i>380</i>&nbsp;			CheckBox cbHideMissing = new CheckBox(&quot;Hide missing cores&quot;);</b>
<b class="nc"><i>381</i>&nbsp;			paneFilter.add(cbHideMissing, 2, 0);</b>
<b class="nc"><i>382</i>&nbsp;			cbHideMissing.selectedProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>383</i>&nbsp;				if (n) {</b>
<b class="nc"><i>384</i>&nbsp;					model.setPredicate(p -&gt; (!(p instanceof TMACoreObject)) || !((TMACoreObject)p).isMissing());</b>
<i>385</i>&nbsp;				} else
<b class="nc"><i>386</i>&nbsp;					model.setPredicate(null);</b>
<i>387</i>&nbsp;			});
<b class="nc"><i>388</i>&nbsp;			cbHideMissing.setSelected(true);</b>
<i>389</i>&nbsp;		}
<i>390</i>&nbsp;		
<b class="nc"><i>391</i>&nbsp;		paneFilter.setPadding(new Insets(2, 5, 2, 5));</b>
<b class="nc"><i>392</i>&nbsp;		paneTable.setBottom(paneFilter);</b>
<b class="nc"><i>393</i>&nbsp;		StringProperty columnFilter = tfColumnFilter.textProperty();</b>
<b class="nc"><i>394</i>&nbsp;		columnFilter.addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>395</i>&nbsp;			String val = n.toLowerCase().trim();</b>
<b class="nc"><i>396</i>&nbsp;			if (val.isEmpty()) {</b>
<b class="nc"><i>397</i>&nbsp;				for (TableColumn&lt;?, ?&gt; col : table.getColumns()) {</b>
<b class="nc"><i>398</i>&nbsp;					if (!col.isVisible())</b>
<b class="nc"><i>399</i>&nbsp;						col.setVisible(true);</b>
<b class="nc"><i>400</i>&nbsp;				}</b>
<i>401</i>&nbsp;				return;
<i>402</i>&nbsp;			}
<b class="nc"><i>403</i>&nbsp;			for (TableColumn&lt;?, ?&gt; col : table.getColumns()) {</b>
<b class="nc"><i>404</i>&nbsp;				col.setVisible(col.getText().toLowerCase().contains(val));</b>
<b class="nc"><i>405</i>&nbsp;			}</b>
<i>406</i>&nbsp;		});
<i>407</i>&nbsp;
<i>408</i>&nbsp;
<b class="nc"><i>409</i>&nbsp;		BorderPane pane = new BorderPane();</b>
<i>410</i>&nbsp;		//		pane.setCenter(table);
<b class="nc"><i>411</i>&nbsp;		splitPane.getItems().add(paneTable);</b>
<b class="nc"><i>412</i>&nbsp;		pane.setCenter(splitPane);</b>
<b class="nc"><i>413</i>&nbsp;		GridPane panelButtons = PaneTools.createColumnGridControls(buttons.toArray(new ButtonBase[0]));</b>
<b class="nc"><i>414</i>&nbsp;		pane.setBottom(panelButtons);</b>
<i>415</i>&nbsp;
<i>416</i>&nbsp;		
<b class="nc"><i>417</i>&nbsp;		PathObjectHierarchyListener listener = new PathObjectHierarchyListener() {</b>
<i>418</i>&nbsp;
<i>419</i>&nbsp;			@Override
<i>420</i>&nbsp;			public void hierarchyChanged(PathObjectHierarchyEvent event) {
<b class="nc"><i>421</i>&nbsp;				if (event.isChanging())</b>
<i>422</i>&nbsp;					return;
<i>423</i>&nbsp;				
<b class="nc"><i>424</i>&nbsp;				if (!Platform.isFxApplicationThread()) {</b>
<b class="nc"><i>425</i>&nbsp;					Platform.runLater(() -&gt; hierarchyChanged(event));</b>
<i>426</i>&nbsp;					return;
<i>427</i>&nbsp;				}
<b class="nc"><i>428</i>&nbsp;				model.refreshEntries();</b>
<b class="nc"><i>429</i>&nbsp;				table.refresh();</b>
<b class="nc"><i>430</i>&nbsp;				if (histogramDisplay != null)</b>
<b class="nc"><i>431</i>&nbsp;					histogramDisplay.refreshHistogram();</b>
<i>432</i>&nbsp;			}
<i>433</i>&nbsp;			
<i>434</i>&nbsp;		};
<i>435</i>&nbsp;		
<i>436</i>&nbsp;		
<b class="nc"><i>437</i>&nbsp;		QuPathViewer viewer = qupath.getViewer();</b>
<b class="nc"><i>438</i>&nbsp;		TableViewerListener tableViewerListener = new TableViewerListener(viewer, table);</b>
<i>439</i>&nbsp;
<b class="nc"><i>440</i>&nbsp;		frame.setOnShowing(e -&gt; {</b>
<b class="nc"><i>441</i>&nbsp;			hierarchy.addPathObjectListener(listener);</b>
<b class="nc"><i>442</i>&nbsp;			viewer.addViewerListener(tableViewerListener);</b>
<i>443</i>&nbsp;		});
<b class="nc"><i>444</i>&nbsp;		frame.setOnHiding(e -&gt; {</b>
<b class="nc"><i>445</i>&nbsp;			hierarchy.removePathObjectListener(listener);</b>
<b class="nc"><i>446</i>&nbsp;			viewer.removeViewerListener(tableViewerListener);</b>
<i>447</i>&nbsp;		});
<i>448</i>&nbsp;
<b class="nc"><i>449</i>&nbsp;		Scene scene = new Scene(pane, 600, 500);</b>
<b class="nc"><i>450</i>&nbsp;		frame.setScene(scene);</b>
<b class="nc"><i>451</i>&nbsp;		frame.show();</b>
<i>452</i>&nbsp;		
<i>453</i>&nbsp;		
<i>454</i>&nbsp;		// Add ability to remove entries from table
<b class="nc"><i>455</i>&nbsp;		ContextMenu menu = new ContextMenu();</b>
<b class="nc"><i>456</i>&nbsp;		Menu menuLimitClasses = new Menu(&quot;Show classes&quot;);</b>
<b class="nc"><i>457</i>&nbsp;		menu.setOnShowing(e -&gt; {</b>
<b class="nc"><i>458</i>&nbsp;			Set&lt;PathClass&gt; representedClasses = model.getBackingListEntries().stream().map(p -&gt; p.getPathClass() == null ? null : p.getPathClass().getBaseClass()).collect(Collectors.toCollection(() -&gt; new HashSet&lt;&gt;()));</b>
<b class="nc"><i>459</i>&nbsp;			representedClasses.remove(null);</b>
<b class="nc"><i>460</i>&nbsp;			if (representedClasses.isEmpty()) {</b>
<b class="nc"><i>461</i>&nbsp;				menuLimitClasses.setVisible(false);</b>
<i>462</i>&nbsp;			}
<i>463</i>&nbsp;			else {
<b class="nc"><i>464</i>&nbsp;				menuLimitClasses.setVisible(true);</b>
<i>465</i>&nbsp;			}
<b class="nc"><i>466</i>&nbsp;			menuLimitClasses.getItems().clear();</b>
<b class="nc"><i>467</i>&nbsp;			List&lt;PathClass&gt; sortedClasses = new ArrayList&lt;&gt;(representedClasses);</b>
<b class="nc"><i>468</i>&nbsp;			Collections.sort(sortedClasses);</b>
<b class="nc"><i>469</i>&nbsp;			MenuItem miClass = new MenuItem(&quot;All&quot;);</b>
<b class="nc"><i>470</i>&nbsp;			miClass.setOnAction(e2 -&gt; {</b>
<b class="nc"><i>471</i>&nbsp;				model.setPredicate(null);</b>
<b class="nc"><i>472</i>&nbsp;				histogramDisplay.refreshHistogram();</b>
<i>473</i>&nbsp;			});
<b class="nc"><i>474</i>&nbsp;			menuLimitClasses.getItems().add(miClass);</b>
<b class="nc"><i>475</i>&nbsp;			for (PathClass pathClass : sortedClasses) {</b>
<b class="nc"><i>476</i>&nbsp;				miClass = new MenuItem(pathClass.getName());</b>
<b class="nc"><i>477</i>&nbsp;				miClass.setOnAction(e2 -&gt; {</b>
<b class="nc"><i>478</i>&nbsp;					model.setPredicate(p -&gt; pathClass.isAncestorOf(p.getPathClass()));</b>
<b class="nc"><i>479</i>&nbsp;					histogramDisplay.refreshHistogram();</b>
<i>480</i>&nbsp;				});
<b class="nc"><i>481</i>&nbsp;				menuLimitClasses.getItems().add(miClass);</b>
<b class="nc"><i>482</i>&nbsp;			}</b>
<i>483</i>&nbsp;		});
<i>484</i>&nbsp;		
<b class="nc"><i>485</i>&nbsp;		if (type != TMACoreObject.class) {</b>
<b class="nc"><i>486</i>&nbsp;			menu.getItems().add(menuLimitClasses);</b>
<b class="nc"><i>487</i>&nbsp;			table.setContextMenu(menu);</b>
<i>488</i>&nbsp;		}
<i>489</i>&nbsp;
<i>490</i>&nbsp;	}
<i>491</i>&nbsp;
<i>492</i>&nbsp;	
<i>493</i>&nbsp;	private void maybeCenterROI(PathObject pathObject) {
<b class="nc"><i>494</i>&nbsp;		if (pathObject == null)</b>
<i>495</i>&nbsp;			return;
<b class="nc"><i>496</i>&nbsp;		var roi = pathObject.getROI();</b>
<b class="nc"><i>497</i>&nbsp;		var viewer = qupath.getViewer();</b>
<b class="nc"><i>498</i>&nbsp;		if (roi != null &amp;&amp; viewer != null &amp;&amp; viewer.getHierarchy() != null)</b>
<b class="nc"><i>499</i>&nbsp;			viewer.centerROI(roi);</b>
<i>500</i>&nbsp;	}
<i>501</i>&nbsp;
<i>502</i>&nbsp;
<i>503</i>&nbsp;
<i>504</i>&nbsp;	class TMACoreTableCell extends TableCell&lt;PathObject, ROI&gt; {
<i>505</i>&nbsp;
<i>506</i>&nbsp;		private TableView&lt;?&gt; table;
<i>507</i>&nbsp;		private ImageServer&lt;BufferedImage&gt; server;
<b class="nc"><i>508</i>&nbsp;		private Canvas canvas = new Canvas();</b>
<b class="nc"><i>509</i>&nbsp;		private double preferredSize = 100;</b>
<i>510</i>&nbsp;		private double maxDim;
<i>511</i>&nbsp;		private double padding;
<i>512</i>&nbsp;
<b class="nc"><i>513</i>&nbsp;		TMACoreTableCell(final TableView&lt;?&gt; table, final ImageServer&lt;BufferedImage&gt; server, final double maxDim, final double padding) {</b>
<b class="nc"><i>514</i>&nbsp;			this.table = table;</b>
<b class="nc"><i>515</i>&nbsp;			this.server = server;</b>
<b class="nc"><i>516</i>&nbsp;			this.maxDim = maxDim;</b>
<b class="nc"><i>517</i>&nbsp;			this.padding = padding;</b>
<b class="nc"><i>518</i>&nbsp;			canvas.setWidth(preferredSize);</b>
<b class="nc"><i>519</i>&nbsp;			canvas.setHeight(preferredSize);</b>
<b class="nc"><i>520</i>&nbsp;			canvas.setStyle(&quot;-fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.5), 4, 0, 1, 1);&quot;);</b>
<b class="nc"><i>521</i>&nbsp;			canvas.heightProperty().bind(canvas.widthProperty());</b>
<i>522</i>&nbsp;		}
<i>523</i>&nbsp;
<i>524</i>&nbsp;
<i>525</i>&nbsp;		@Override
<i>526</i>&nbsp;		protected void updateItem(ROI roi, boolean empty) {
<b class="nc"><i>527</i>&nbsp;			super.updateItem(roi, empty);</b>
<b class="nc"><i>528</i>&nbsp;			if (empty) {</b>
<b class="nc"><i>529</i>&nbsp;				setText(null);</b>
<b class="nc"><i>530</i>&nbsp;				setGraphic(null);</b>
<i>531</i>&nbsp;				return;
<i>532</i>&nbsp;			}
<b class="nc"><i>533</i>&nbsp;			canvas.setWidth(getTableColumn().getWidth()-padding*2);</b>
<b class="nc"><i>534</i>&nbsp;			setGraphic(canvas);</b>
<b class="nc"><i>535</i>&nbsp;			this.setContentDisplay(ContentDisplay.CENTER);</b>
<b class="nc"><i>536</i>&nbsp;			this.setAlignment(Pos.CENTER);</b>
<b class="nc"><i>537</i>&nbsp;			canvas.getGraphicsContext2D().clearRect(0, 0, canvas.getWidth(), canvas.getHeight());</b>
<i>538</i>&nbsp;			try {
<b class="nc"><i>539</i>&nbsp;				if (roi == null) {</b>
<b class="nc"><i>540</i>&nbsp;					setText(null);</b>
<i>541</i>&nbsp;					return;
<i>542</i>&nbsp;				}
<i>543</i>&nbsp;				
<b class="nc"><i>544</i>&nbsp;				Image image = cache.get(roi);</b>
<b class="nc"><i>545</i>&nbsp;				if (image != null) {</b>
<b class="nc"><i>546</i>&nbsp;					GuiTools.paintImage(canvas, image);</b>
<i>547</i>&nbsp;					return;
<i>548</i>&nbsp;				}
<b class="nc"><i>549</i>&nbsp;				qupath.submitShortTask(() -&gt; {</b>
<b class="nc"><i>550</i>&nbsp;					double downsample = Math.max(roi.getBoundsWidth(), roi.getBoundsHeight()) / maxDim;</b>
<i>551</i>&nbsp;					// TODO: Put requests into a background thread!
<b class="nc"><i>552</i>&nbsp;					RegionRequest request = RegionRequest.createInstance(server.getPath(), downsample, roi);</b>
<i>553</i>&nbsp;					try {
<b class="nc"><i>554</i>&nbsp;						BufferedImage img = server.readBufferedImage(request);</b>
<b class="nc"><i>555</i>&nbsp;						Image imageNew = SwingFXUtils.toFXImage(img, null);</b>
<b class="nc"><i>556</i>&nbsp;						if (imageNew != null) {</b>
<b class="nc"><i>557</i>&nbsp;							cache.put(roi, imageNew);</b>
<b class="nc"><i>558</i>&nbsp;							Platform.runLater(() -&gt; table.refresh());</b>
<i>559</i>&nbsp;						}
<b class="nc"><i>560</i>&nbsp;					} catch (IOException e) {</b>
<b class="nc"><i>561</i>&nbsp;						logger.debug(&quot;Unable to return image for &quot; + request, e);</b>
<b class="nc"><i>562</i>&nbsp;					}</b>
<i>563</i>&nbsp;				});
<b class="nc"><i>564</i>&nbsp;			} catch (Exception e) {</b>
<b class="nc"><i>565</i>&nbsp;				logger.error(&quot;Problem reading thumbnail for core {}: {}&quot;, roi, e);</b>
<i>566</i>&nbsp;//				setGraphic(null);
<b class="nc"><i>567</i>&nbsp;			}</b>
<i>568</i>&nbsp;		}
<i>569</i>&nbsp;
<i>570</i>&nbsp;	}
<i>571</i>&nbsp;
<i>572</i>&nbsp;
<i>573</i>&nbsp;
<i>574</i>&nbsp;	static class BasicTableCell&lt;S, T&gt; extends TableCell&lt;S, T&gt; {
<i>575</i>&nbsp;
<b class="nc"><i>576</i>&nbsp;		public BasicTableCell() {</b>
<b class="nc"><i>577</i>&nbsp;			setAlignment(Pos.CENTER);</b>
<i>578</i>&nbsp;		}
<i>579</i>&nbsp;
<i>580</i>&nbsp;		@Override
<i>581</i>&nbsp;		protected void updateItem(T item, boolean empty) {
<b class="nc"><i>582</i>&nbsp;			super.updateItem(item, empty);</b>
<b class="nc"><i>583</i>&nbsp;			if (item == null || empty) {</b>
<b class="nc"><i>584</i>&nbsp;				setText(null);</b>
<b class="nc"><i>585</i>&nbsp;				setGraphic(null);</b>
<i>586</i>&nbsp;				return;
<i>587</i>&nbsp;			}
<b class="nc"><i>588</i>&nbsp;			setText(item.toString());</b>
<i>589</i>&nbsp;		}
<i>590</i>&nbsp;
<i>591</i>&nbsp;	}
<i>592</i>&nbsp;
<i>593</i>&nbsp;
<i>594</i>&nbsp;
<i>595</i>&nbsp;	static class NumericTableCell&lt;T&gt; extends TableCell&lt;T, Number&gt; {
<i>596</i>&nbsp;
<i>597</i>&nbsp;		private HistogramDisplay histogramDisplay;
<i>598</i>&nbsp;
<b class="nc"><i>599</i>&nbsp;		public NumericTableCell(final HistogramDisplay histogramDisplay) {</b>
<b class="nc"><i>600</i>&nbsp;			this.histogramDisplay = histogramDisplay;</b>
<i>601</i>&nbsp;		}
<i>602</i>&nbsp;
<i>603</i>&nbsp;
<i>604</i>&nbsp;		@Override
<i>605</i>&nbsp;		protected void updateItem(Number item, boolean empty) {
<b class="nc"><i>606</i>&nbsp;			super.updateItem(item, empty);</b>
<b class="nc"><i>607</i>&nbsp;			if (item == null || empty) {</b>
<b class="nc"><i>608</i>&nbsp;				setText(null);</b>
<b class="nc"><i>609</i>&nbsp;				setStyle(&quot;&quot;);</b>
<i>610</i>&nbsp;			} else {
<b class="nc"><i>611</i>&nbsp;				setAlignment(Pos.CENTER);</b>
<b class="nc"><i>612</i>&nbsp;				if (Double.isNaN(item.doubleValue()))</b>
<b class="nc"><i>613</i>&nbsp;					setText(&quot;-&quot;);</b>
<i>614</i>&nbsp;				else {
<b class="nc"><i>615</i>&nbsp;					if (item.doubleValue() &gt;= 1000)</b>
<b class="nc"><i>616</i>&nbsp;						setText(GeneralTools.formatNumber(item.doubleValue(), 1));</b>
<b class="nc"><i>617</i>&nbsp;					else if (item.doubleValue() &gt;= 10)</b>
<b class="nc"><i>618</i>&nbsp;						setText(GeneralTools.formatNumber(item.doubleValue(), 2));</b>
<i>619</i>&nbsp;					else
<b class="nc"><i>620</i>&nbsp;						setText(GeneralTools.formatNumber(item.doubleValue(), 3));</b>
<i>621</i>&nbsp;				}
<i>622</i>&nbsp;
<i>623</i>&nbsp;
<b class="nc"><i>624</i>&nbsp;				setOnMouseClicked(e -&gt; {</b>
<b class="nc"><i>625</i>&nbsp;					if (e.isAltDown() &amp;&amp; histogramDisplay != null) {</b>
<b class="nc"><i>626</i>&nbsp;						histogramDisplay.showHistogram(getTableColumn().getText());</b>
<b class="nc"><i>627</i>&nbsp;						e.consume();</b>
<i>628</i>&nbsp;						//	            		showChart(column);
<i>629</i>&nbsp;					}
<i>630</i>&nbsp;				});
<i>631</i>&nbsp;
<i>632</i>&nbsp;				//			                setTooltip(new Tooltip(df6.format(item))); // Performance issue?
<i>633</i>&nbsp;			}
<i>634</i>&nbsp;		}
<i>635</i>&nbsp;
<i>636</i>&nbsp;	}
<i>637</i>&nbsp;
<i>638</i>&nbsp;
<i>639</i>&nbsp;
<i>640</i>&nbsp;
<i>641</i>&nbsp;
<i>642</i>&nbsp;
<i>643</i>&nbsp;	class TableViewerListener implements QuPathViewerListener {
<i>644</i>&nbsp;
<i>645</i>&nbsp;		private TableView&lt;PathObject&gt; table;
<i>646</i>&nbsp;		private QuPathViewer viewer;
<i>647</i>&nbsp;
<b class="nc"><i>648</i>&nbsp;		TableViewerListener(final QuPathViewer viewer, final TableView&lt;PathObject&gt; table) {</b>
<b class="nc"><i>649</i>&nbsp;			this.viewer = viewer;</b>
<b class="nc"><i>650</i>&nbsp;			this.table = table;</b>
<i>651</i>&nbsp;		}
<i>652</i>&nbsp;
<i>653</i>&nbsp;		@Override
<i>654</i>&nbsp;		public void imageDataChanged(QuPathViewer viewer, ImageData&lt;BufferedImage&gt; imageDataOld, ImageData&lt;BufferedImage&gt; imageDataNew) {
<i>655</i>&nbsp;			// Stop listening to the viewer when the data changes
<b class="nc"><i>656</i>&nbsp;			if (this.viewer == viewer &amp;&amp; imageDataNew != imageDataOld)</b>
<b class="nc"><i>657</i>&nbsp;				viewer.removeViewerListener(this);</b>
<i>658</i>&nbsp;		}
<i>659</i>&nbsp;
<i>660</i>&nbsp;		@Override
<i>661</i>&nbsp;		public void visibleRegionChanged(QuPathViewer viewer, Shape shape) {}
<i>662</i>&nbsp;
<i>663</i>&nbsp;		@Override
<i>664</i>&nbsp;		public void selectedObjectChanged(QuPathViewer viewer, PathObject pathObjectSelected) {
<i>665</i>&nbsp;//			if (this.viewer != null || table.getSelectionModel().getSelectedItem() == pathObjectSelected || !table.getItems().contains(pathObjectSelected))
<i>666</i>&nbsp;//				return;
<i>667</i>&nbsp;			
<b class="nc"><i>668</i>&nbsp;			if (!Platform.isFxApplicationThread()) {</b>
<b class="nc"><i>669</i>&nbsp;				Platform.runLater(() -&gt; selectedObjectChanged(viewer, pathObjectSelected));</b>
<i>670</i>&nbsp;				return;
<i>671</i>&nbsp;			}
<b class="nc"><i>672</i>&nbsp;			synchronizeTableToSelectionModel(viewer.getHierarchy(), table);</b>
<i>673</i>&nbsp;
<i>674</i>&nbsp;//			Platform.runLater(() -&gt; {
<i>675</i>&nbsp;//				if (pathObjectSelected == null)
<i>676</i>&nbsp;//					table.getSelectionModel().clearSelection();
<i>677</i>&nbsp;//				else {
<i>678</i>&nbsp;//					table.getSelectionModel().select(pathObjectSelected);
<i>679</i>&nbsp;//					// Scroll to the object if it is present in the table
<i>680</i>&nbsp;//					//					if (table.getSelectionModel().getSelectedItem() == pathObjectSelected)
<i>681</i>&nbsp;//					table.scrollTo(pathObjectSelected);
<i>682</i>&nbsp;//				}
<i>683</i>&nbsp;//			});
<i>684</i>&nbsp;		}
<i>685</i>&nbsp;
<i>686</i>&nbsp;		@Override
<i>687</i>&nbsp;		public void viewerClosed(QuPathViewer viewer) {
<b class="nc"><i>688</i>&nbsp;			viewer.removeViewerListener(this);</b>
<b class="nc"><i>689</i>&nbsp;			this.viewer = null; // Remove reference</b>
<i>690</i>&nbsp;		}
<i>691</i>&nbsp;
<i>692</i>&nbsp;	}
<i>693</i>&nbsp;
<i>694</i>&nbsp;
<i>695</i>&nbsp;
<i>696</i>&nbsp;	//	public static String getTableString(final JTable table, final String delim) {
<i>697</i>&nbsp;	//		return getTableModelString(table.getModel(), delim);
<i>698</i>&nbsp;	//	}
<i>699</i>&nbsp;
<i>700</i>&nbsp;	/**
<i>701</i>&nbsp;	 * Get a list of Strings representing table data.
<i>702</i>&nbsp;	 * &lt;p&gt;
<i>703</i>&nbsp;	 * Each entry in the list corresponds to a row.
<i>704</i>&nbsp;	 * 
<i>705</i>&nbsp;	 * @param &lt;T&gt; the data type for the table
<i>706</i>&nbsp;	 * @param model
<i>707</i>&nbsp;	 * @param delim
<i>708</i>&nbsp;	 * @param excludeColumns
<i>709</i>&nbsp;	 * @return
<i>710</i>&nbsp;	 */
<i>711</i>&nbsp;	public static &lt;T&gt; List&lt;String&gt; getTableModelStrings(final PathTableData&lt;T&gt; model, final String delim, Collection&lt;String&gt; excludeColumns) {
<b class="nc"><i>712</i>&nbsp;		List&lt;String&gt; rows = new ArrayList&lt;&gt;();</b>
<i>713</i>&nbsp;		
<b class="nc"><i>714</i>&nbsp;		StringBuilder sb = new StringBuilder();</b>
<i>715</i>&nbsp;		
<b class="nc"><i>716</i>&nbsp;		List&lt;String&gt; names = new ArrayList&lt;&gt;(model.getAllNames());</b>
<b class="nc"><i>717</i>&nbsp;		names.removeAll(excludeColumns);</b>
<i>718</i>&nbsp;		
<b class="nc"><i>719</i>&nbsp;		int nColumns = names.size();</b>
<b class="nc"><i>720</i>&nbsp;		for (int col = 0; col &lt; nColumns; col++) {</b>
<b class="nc"><i>721</i>&nbsp;			if (names.get(col).chars().filter(e -&gt; e == &#39;&quot;&#39;).count() % 2 != 0)</b>
<b class="nc"><i>722</i>&nbsp;				logger.warn(&quot;Syntax is ambiguous (i.e. misuse of &#39;\&quot;&#39;), which might result in inconsistencies/errors.&quot;);</b>
<b class="nc"><i>723</i>&nbsp;			if (names.get(col).contains(delim))</b>
<b class="nc"><i>724</i>&nbsp;				sb.append(&quot;\&quot;&quot; + names.get(col) + &quot;\&quot;&quot;);</b>
<i>725</i>&nbsp;			else
<b class="nc"><i>726</i>&nbsp;				sb.append(names.get(col));</b>
<i>727</i>&nbsp;			
<b class="nc"><i>728</i>&nbsp;			if (col &lt; nColumns - 1)</b>
<b class="nc"><i>729</i>&nbsp;				sb.append(delim);</b>
<i>730</i>&nbsp;		}
<b class="nc"><i>731</i>&nbsp;		rows.add(sb.toString());</b>
<b class="nc"><i>732</i>&nbsp;		sb.setLength(0);</b>
<i>733</i>&nbsp;		
<b class="nc"><i>734</i>&nbsp;		for (T object : model.getItems()) {</b>
<b class="nc"><i>735</i>&nbsp;			for (int col = 0; col &lt; nColumns; col++) {</b>
<b class="nc"><i>736</i>&nbsp;				String val = model.getStringValue(object, names.get(col));</b>
<b class="nc"><i>737</i>&nbsp;				if (val != null) {</b>
<b class="nc"><i>738</i>&nbsp;					if (val.contains(&quot;\&quot;&quot;))</b>
<b class="nc"><i>739</i>&nbsp;						logger.warn(&quot;Syntax is ambiguous (i.e. misuse of &#39;\&quot;&#39;), which might result in inconsistencies/errors.&quot;);</b>
<b class="nc"><i>740</i>&nbsp;					if (val.contains(delim))</b>
<b class="nc"><i>741</i>&nbsp;						sb.append(&quot;\&quot;&quot; + val + &quot;\&quot;&quot;);</b>
<i>742</i>&nbsp;					else
<b class="nc"><i>743</i>&nbsp;						sb.append(val);						</b>
<i>744</i>&nbsp;				}
<i>745</i>&nbsp;//				double value = model.getNumericValue(object, model.getAllNames().get(col));
<i>746</i>&nbsp;//				if (Double.isNaN(value))
<i>747</i>&nbsp;//					sb.append(&quot;-&quot;);
<i>748</i>&nbsp;//				else
<i>749</i>&nbsp;//					sb.append(GeneralTools.getFormatter(4).format(value));
<b class="nc"><i>750</i>&nbsp;				if (col &lt; nColumns - 1)</b>
<b class="nc"><i>751</i>&nbsp;					sb.append(delim);</b>
<i>752</i>&nbsp;			}
<b class="nc"><i>753</i>&nbsp;			rows.add(sb.toString());</b>
<b class="nc"><i>754</i>&nbsp;			sb.setLength(0);</b>
<b class="nc"><i>755</i>&nbsp;		}</b>
<b class="nc"><i>756</i>&nbsp;		return rows;</b>
<i>757</i>&nbsp;	}
<i>758</i>&nbsp;
<i>759</i>&nbsp;	/**
<i>760</i>&nbsp;	 * Get a single String representing the data in a table.
<i>761</i>&nbsp;	 * &lt;p&gt;
<i>762</i>&nbsp;	 * Note: if the required String is too long (approximately Integer.MAX_VALUE characters), this will throw an IllegalArgumentException.
<i>763</i>&nbsp;	 * 
<i>764</i>&nbsp;	 * @param &lt;T&gt; the data type for the items in the table
<i>765</i>&nbsp;	 * @param model
<i>766</i>&nbsp;	 * @param delim
<i>767</i>&nbsp;	 * @param excludeColumns
<i>768</i>&nbsp;	 * @return
<i>769</i>&nbsp;	 * @throws IllegalArgumentException 
<i>770</i>&nbsp;	 */
<i>771</i>&nbsp;	public static &lt;T&gt; String getTableModelString(final PathTableData&lt;T&gt; model, final String delim, Collection&lt;String&gt; excludeColumns) throws IllegalArgumentException {
<b class="nc"><i>772</i>&nbsp;		List&lt;String&gt; rows = getTableModelStrings(model, delim, excludeColumns);</b>
<b class="nc"><i>773</i>&nbsp;		long length = rows.stream().mapToLong(r -&gt; r.length()).sum() + rows.size() * System.lineSeparator().length();</b>
<b class="nc"><i>774</i>&nbsp;		long maxLength = Integer.MAX_VALUE - 1;</b>
<b class="nc"><i>775</i>&nbsp;		if (length &gt; Integer.MAX_VALUE)</b>
<b class="nc"><i>776</i>&nbsp;			throw new IllegalArgumentException(&quot;Requested string is too long! Requires &quot; + maxLength + &quot; characters, but Java arrays limited to &quot; + maxLength);</b>
<b class="nc"><i>777</i>&nbsp;		logger.debug(&quot;Getting table string (approx {} characters, {} % of maximum)&quot;, length, Math.round(length / (double)maxLength  * 100));</b>
<b class="nc"><i>778</i>&nbsp;		return String.join(System.lineSeparator(), rows);</b>
<i>779</i>&nbsp;	}
<i>780</i>&nbsp;
<i>781</i>&nbsp;	/**
<i>782</i>&nbsp;	 * Get a single String representing the data in a table and copy it to the clipboard.
<i>783</i>&nbsp;	 * &lt;p&gt;
<i>784</i>&nbsp;	 * Note: this may not be possible if the String is too long, see {@link #getTableModelString(PathTableData, String, Collection)}.
<i>785</i>&nbsp;	 * 
<i>786</i>&nbsp;	 * @param model
<i>787</i>&nbsp;	 * @param excludeColumns
<i>788</i>&nbsp;	 */
<i>789</i>&nbsp;	public static void copyTableContentsToClipboard(final PathTableData&lt;?&gt; model, Collection&lt;String&gt; excludeColumns) {
<b class="nc"><i>790</i>&nbsp;		if (model == null) {</b>
<b class="nc"><i>791</i>&nbsp;			logger.warn(&quot;No table available to copy!&quot;);</b>
<i>792</i>&nbsp;			return;
<i>793</i>&nbsp;		}
<b class="nc"><i>794</i>&nbsp;		String string = getTableModelString(model, PathPrefs.tableDelimiterProperty().get(), excludeColumns);</b>
<b class="nc"><i>795</i>&nbsp;		Clipboard clipboard = Clipboard.getSystemClipboard();</b>
<b class="nc"><i>796</i>&nbsp;		ClipboardContent content = new ClipboardContent();</b>
<b class="nc"><i>797</i>&nbsp;		content.putString(string);</b>
<b class="nc"><i>798</i>&nbsp;		clipboard.setContent(content);</b>
<i>799</i>&nbsp;	}
<i>800</i>&nbsp;	
<i>801</i>&nbsp;	
<i>802</i>&nbsp;	private static File promptForOutputFile() {
<b class="nc"><i>803</i>&nbsp;		String ext = &quot;,&quot;.equals(PathPrefs.tableDelimiterProperty().get()) ? &quot;csv&quot; : &quot;txt&quot;;</b>
<b class="nc"><i>804</i>&nbsp;		return Dialogs.promptToSaveFile(null, null, null, &quot;Results data&quot;, ext);</b>
<i>805</i>&nbsp;	}
<i>806</i>&nbsp;	
<i>807</i>&nbsp;	/**
<i>808</i>&nbsp;	 * Save the data from a table to a text file, using the default delimiter from {@link PathPrefs}.
<i>809</i>&nbsp;	 * @param tableModel the data to export
<i>810</i>&nbsp;	 * @param fileOutput the file to write the text to; if null, a file chooser will be shown
<i>811</i>&nbsp;	 * @param excludeColumns headings for columns that should be excluded
<i>812</i>&nbsp;	 * @return
<i>813</i>&nbsp;	 */
<i>814</i>&nbsp;	public static boolean saveTableModel(final PathTableData&lt;?&gt; tableModel, File fileOutput, Collection&lt;String&gt; excludeColumns) {
<b class="nc"><i>815</i>&nbsp;		if (fileOutput == null) {</b>
<b class="nc"><i>816</i>&nbsp;			fileOutput = promptForOutputFile();</b>
<b class="nc"><i>817</i>&nbsp;			if (fileOutput == null)</b>
<b class="nc"><i>818</i>&nbsp;				return false;</b>
<i>819</i>&nbsp;		}
<b class="nc"><i>820</i>&nbsp;		try (PrintWriter writer = new PrintWriter(fileOutput, StandardCharsets.UTF_8)) {</b>
<b class="nc"><i>821</i>&nbsp;			for (String row : getTableModelStrings(tableModel, PathPrefs.tableDelimiterProperty().get(), excludeColumns))</b>
<b class="nc"><i>822</i>&nbsp;				writer.println(row);</b>
<b class="nc"><i>823</i>&nbsp;			writer.close();</b>
<b class="nc"><i>824</i>&nbsp;			return true;</b>
<b class="nc"><i>825</i>&nbsp;		} catch (IOException e) {</b>
<b class="nc"><i>826</i>&nbsp;			logger.error(&quot;Error writing file to &quot; + fileOutput, e);</b>
<i>827</i>&nbsp;		}
<b class="nc"><i>828</i>&nbsp;		return false;</b>
<i>829</i>&nbsp;	}
<i>830</i>&nbsp;	
<i>831</i>&nbsp;	
<b class="nc"><i>832</i>&nbsp;	private boolean synchronizingTableToModel = false;</b>
<b class="nc"><i>833</i>&nbsp;	private boolean synchronizingModelToTable = false;</b>
<i>834</i>&nbsp;	
<i>835</i>&nbsp;	private void synchronizeSelectionModelToTable(final PathObjectHierarchy hierarchy, final ListChangeListener.Change&lt;? extends PathObject&gt; change, final TableView&lt;PathObject&gt; table) {
<b class="nc"><i>836</i>&nbsp;		if (synchronizingTableToModel || hierarchy == null)</b>
<i>837</i>&nbsp;			return;
<i>838</i>&nbsp;		
<b class="nc"><i>839</i>&nbsp;		PathObjectSelectionModel model = hierarchy.getSelectionModel();</b>
<b class="nc"><i>840</i>&nbsp;		if (model == null) {</b>
<i>841</i>&nbsp;			return;
<i>842</i>&nbsp;		}
<i>843</i>&nbsp;		
<b class="nc"><i>844</i>&nbsp;		boolean wasSynchronizingToTree = synchronizingModelToTable;</b>
<i>845</i>&nbsp;		try {
<b class="nc"><i>846</i>&nbsp;			synchronizingModelToTable = true;</b>
<i>847</i>&nbsp;			
<i>848</i>&nbsp;			// Check - was anything removed?
<b class="nc"><i>849</i>&nbsp;			boolean removed = false;</b>
<b class="nc"><i>850</i>&nbsp;			if (change != null) {</b>
<b class="nc"><i>851</i>&nbsp;				while (change.next())</b>
<b class="nc"><i>852</i>&nbsp;					removed = removed | change.wasRemoved();</b>
<i>853</i>&nbsp;			}
<i>854</i>&nbsp;			
<b class="nc"><i>855</i>&nbsp;			MultipleSelectionModel&lt;PathObject&gt; treeModel = table.getSelectionModel();</b>
<b class="nc"><i>856</i>&nbsp;			List&lt;PathObject&gt; selectedItems = treeModel.getSelectedItems();</b>
<i>857</i>&nbsp;			
<i>858</i>&nbsp;			// If we just have no selected items, and something was removed, then clear the selection
<b class="nc"><i>859</i>&nbsp;			if (selectedItems.isEmpty() &amp;&amp; removed) {</b>
<b class="nc"><i>860</i>&nbsp;				model.clearSelection();</b>
<i>861</i>&nbsp;				return;				
<i>862</i>&nbsp;			}
<i>863</i>&nbsp;			
<i>864</i>&nbsp;			// If we just have one selected item, and also items were removed from the selection, then only select the one item we have
<i>865</i>&nbsp;//			if (selectedItems.size() == 1 &amp;&amp; removed) {
<b class="nc"><i>866</i>&nbsp;			if (selectedItems.size() == 1) {</b>
<b class="nc"><i>867</i>&nbsp;				model.setSelectedObject(selectedItems.get(0), false);</b>
<i>868</i>&nbsp;				return;
<i>869</i>&nbsp;			}
<i>870</i>&nbsp;			
<i>871</i>&nbsp;			// If we have multiple selected items, we need to ensure that everything in the tree matches with everything in the selection model
<b class="nc"><i>872</i>&nbsp;			Set&lt;PathObject&gt; toSelect = new HashSet&lt;&gt;(treeModel.getSelectedItems());</b>
<b class="nc"><i>873</i>&nbsp;			PathObject primary = treeModel.getSelectedItem();</b>
<b class="nc"><i>874</i>&nbsp;			model.setSelectedObjects(toSelect, primary);</b>
<i>875</i>&nbsp;		} finally {
<b class="nc"><i>876</i>&nbsp;			synchronizingModelToTable = wasSynchronizingToTree;</b>
<b class="nc"><i>877</i>&nbsp;		}</b>
<i>878</i>&nbsp;	}
<i>879</i>&nbsp;	
<i>880</i>&nbsp;	
<i>881</i>&nbsp;	private void synchronizeTableToSelectionModel(final PathObjectHierarchy hierarchy, final TableView&lt;PathObject&gt; table) {
<b class="nc"><i>882</i>&nbsp;		if (synchronizingModelToTable || hierarchy == null)</b>
<i>883</i>&nbsp;			return;
<b class="nc"><i>884</i>&nbsp;		boolean ownsChanges = !synchronizingTableToModel;</b>
<i>885</i>&nbsp;		try {
<b class="nc"><i>886</i>&nbsp;			synchronizingTableToModel = true;</b>
<i>887</i>&nbsp;			
<b class="nc"><i>888</i>&nbsp;			PathObjectSelectionModel model = hierarchy.getSelectionModel();</b>
<b class="nc"><i>889</i>&nbsp;			TableViewSelectionModel&lt;PathObject&gt; tableModel = table.getSelectionModel();</b>
<b class="nc"><i>890</i>&nbsp;			if (model == null || model.noSelection()) {</b>
<b class="nc"><i>891</i>&nbsp;				tableModel.clearSelection();</b>
<i>892</i>&nbsp;				return;
<i>893</i>&nbsp;			}
<i>894</i>&nbsp;			
<b class="nc"><i>895</i>&nbsp;			if (model.singleSelection() || tableModel.getSelectionMode() == SelectionMode.SINGLE) {</b>
<b class="nc"><i>896</i>&nbsp;				int ind = table.getItems().indexOf(model.getSelectedObject());</b>
<b class="nc"><i>897</i>&nbsp;				if (ind &gt;= 0) {</b>
<b class="nc"><i>898</i>&nbsp;					tableModel.clearAndSelect(ind);</b>
<b class="nc"><i>899</i>&nbsp;					table.scrollTo(ind);</b>
<i>900</i>&nbsp;				}
<i>901</i>&nbsp;				else
<b class="nc"><i>902</i>&nbsp;					tableModel.clearSelection();</b>
<i>903</i>&nbsp;				return;
<i>904</i>&nbsp;			}
<i>905</i>&nbsp;			
<i>906</i>&nbsp;			// Loop through all possible selections, and select them if they should be selected (and not if they shouldn&#39;t)
<i>907</i>&nbsp;			// For performance reasons, we need to do this using arrays - otherwise way too many events may be fired
<b class="nc"><i>908</i>&nbsp;			int n = table.getItems().size();</b>
<b class="nc"><i>909</i>&nbsp;			PathObject mainSelectedObject = model.getSelectedObject();</b>
<b class="nc"><i>910</i>&nbsp;			int mainObjectInd = -1;</b>
<b class="nc"><i>911</i>&nbsp;			int[] indsToSelect = new int[table.getItems().size()];</b>
<b class="nc"><i>912</i>&nbsp;			int count = 0;</b>
<b class="nc"><i>913</i>&nbsp;			for (int i = 0; i &lt; n; i++) {</b>
<b class="nc"><i>914</i>&nbsp;				PathObject temp = table.getItems().get(i);</b>
<b class="nc"><i>915</i>&nbsp;				if (temp == mainSelectedObject)</b>
<b class="nc"><i>916</i>&nbsp;					mainObjectInd = i;</b>
<b class="nc"><i>917</i>&nbsp;				if (model.isSelected(temp)) {</b>
<b class="nc"><i>918</i>&nbsp;					indsToSelect[count] = i;</b>
<b class="nc"><i>919</i>&nbsp;					count++;</b>
<i>920</i>&nbsp;				}
<i>921</i>&nbsp;			}
<b class="nc"><i>922</i>&nbsp;			tableModel.clearSelection();</b>
<b class="nc"><i>923</i>&nbsp;			if (count &gt; 0) {</b>
<b class="nc"><i>924</i>&nbsp;				int maxCount = 1000;</b>
<b class="nc"><i>925</i>&nbsp;				if (count &gt; maxCount) {</b>
<b class="nc"><i>926</i>&nbsp;					logger.warn(&quot;Only the first {} items will be selected in the table (out of {} total) - otherwise QuPath can grind to a halt, sorry&quot;,</b>
<b class="nc"><i>927</i>&nbsp;							maxCount, count);</b>
<b class="nc"><i>928</i>&nbsp;					count = maxCount;</b>
<i>929</i>&nbsp;				}
<b class="nc"><i>930</i>&nbsp;				tableModel.selectIndices(indsToSelect[0], Arrays.copyOfRange(indsToSelect, 1, count));</b>
<i>931</i>&nbsp;			}
<i>932</i>&nbsp;			
<i>933</i>&nbsp;//			for (int i = 0; i &lt; n; i++) {
<i>934</i>&nbsp;//				PathObject temp = table.getItems().get(i);
<i>935</i>&nbsp;//				if (temp == mainSelectedObject)
<i>936</i>&nbsp;//					mainObjectInd = i;
<i>937</i>&nbsp;//				if (model.isSelected(temp)) {
<i>938</i>&nbsp;//					// Only select if necessary, or if this is the main selected object
<i>939</i>&nbsp;//					if (!tableModel.isSelected(i))
<i>940</i>&nbsp;//						tableModel.select(i);
<i>941</i>&nbsp;//				}
<i>942</i>&nbsp;//				else
<i>943</i>&nbsp;//					tableModel.clearSelection(i);
<i>944</i>&nbsp;//			}
<i>945</i>&nbsp;			// Ensure that the main object is focussed &amp; its node expanded
<b class="nc"><i>946</i>&nbsp;			if (mainObjectInd &gt;= 0 &amp;&amp; model.singleSelection()) {</b>
<b class="nc"><i>947</i>&nbsp;				tableModel.select(mainObjectInd);</b>
<b class="nc"><i>948</i>&nbsp;				table.scrollTo(mainObjectInd);</b>
<i>949</i>&nbsp;			}
<i>950</i>&nbsp;			
<i>951</i>&nbsp;		} finally {
<b class="nc"><i>952</i>&nbsp;			if (ownsChanges)</b>
<b class="nc"><i>953</i>&nbsp;				synchronizingTableToModel = false;</b>
<b class="nc"><i>954</i>&nbsp;		}</b>
<i>955</i>&nbsp;	}
<i>956</i>&nbsp;	
<i>957</i>&nbsp;
<i>958</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2021-01-25 09:46</div>
</div>
</body>
</html>
