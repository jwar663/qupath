


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: TMASummaryViewer</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">qupath.lib.gui.tma</a> ]
</div>

<h1>Coverage Summary for Class: TMASummaryViewer (qupath.lib.gui.tma)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TMASummaryViewer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 93)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 782)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TMASummaryViewer$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$ImageAvailability</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$RootTreeItem</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$ScatterPane</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 105)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$SummaryTreeItem</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$TablePredicate</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$TMATableModel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 47)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TMASummaryViewer$TMATableModel$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 145)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1015)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*-
<i>2</i>&nbsp; * #%L
<i>3</i>&nbsp; * This file is part of QuPath.
<i>4</i>&nbsp; * %%
<i>5</i>&nbsp; * Copyright (C) 2014 - 2016 The Queen&#39;s University of Belfast, Northern Ireland
<i>6</i>&nbsp; * Contact: IP Management (ipmanagement@qub.ac.uk)
<i>7</i>&nbsp; * Copyright (C) 2018 - 2020 QuPath developers, The University of Edinburgh
<i>8</i>&nbsp; * %%
<i>9</i>&nbsp; * QuPath is free software: you can redistribute it and/or modify
<i>10</i>&nbsp; * it under the terms of the GNU General Public License as
<i>11</i>&nbsp; * published by the Free Software Foundation, either version 3 of the
<i>12</i>&nbsp; * License, or (at your option) any later version.
<i>13</i>&nbsp; * 
<i>14</i>&nbsp; * QuPath is distributed in the hope that it will be useful,
<i>15</i>&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
<i>16</i>&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<i>17</i>&nbsp; * GNU General Public License for more details.
<i>18</i>&nbsp; * 
<i>19</i>&nbsp; * You should have received a copy of the GNU General Public License 
<i>20</i>&nbsp; * along with QuPath.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
<i>21</i>&nbsp; * #L%
<i>22</i>&nbsp; */
<i>23</i>&nbsp;
<i>24</i>&nbsp;package qupath.lib.gui.tma;
<i>25</i>&nbsp;
<i>26</i>&nbsp;import java.awt.image.BufferedImage;
<i>27</i>&nbsp;import java.io.File;
<i>28</i>&nbsp;import java.io.IOException;
<i>29</i>&nbsp;import java.util.ArrayList;
<i>30</i>&nbsp;import java.util.Arrays;
<i>31</i>&nbsp;import java.util.Collection;
<i>32</i>&nbsp;import java.util.Collections;
<i>33</i>&nbsp;import java.util.HashMap;
<i>34</i>&nbsp;import java.util.HashSet;
<i>35</i>&nbsp;import java.util.LinkedHashMap;
<i>36</i>&nbsp;import java.util.LinkedHashSet;
<i>37</i>&nbsp;import java.util.List;
<i>38</i>&nbsp;import java.util.Map;
<i>39</i>&nbsp;import java.util.Map.Entry;
<i>40</i>&nbsp;import java.util.Optional;
<i>41</i>&nbsp;import java.util.Scanner;
<i>42</i>&nbsp;import java.util.Set;
<i>43</i>&nbsp;import java.util.TreeMap;
<i>44</i>&nbsp;import java.util.concurrent.ExecutorService;
<i>45</i>&nbsp;import java.util.concurrent.Executors;
<i>46</i>&nbsp;import java.util.function.Predicate;
<i>47</i>&nbsp;import java.util.stream.Collectors;
<i>48</i>&nbsp;
<i>49</i>&nbsp;import javax.script.ScriptContext;
<i>50</i>&nbsp;import javax.script.ScriptEngine;
<i>51</i>&nbsp;import javax.script.ScriptEngineManager;
<i>52</i>&nbsp;import javax.script.ScriptException;
<i>53</i>&nbsp;import javax.script.SimpleBindings;
<i>54</i>&nbsp;
<i>55</i>&nbsp;import org.apache.commons.math3.stat.correlation.PearsonsCorrelation;
<i>56</i>&nbsp;import org.apache.commons.math3.stat.correlation.SpearmansCorrelation;
<i>57</i>&nbsp;import org.controlsfx.control.MasterDetailPane;
<i>58</i>&nbsp;import org.controlsfx.control.action.Action;
<i>59</i>&nbsp;import org.controlsfx.control.action.ActionUtils;
<i>60</i>&nbsp;import org.controlsfx.control.textfield.TextFields;
<i>61</i>&nbsp;import org.slf4j.Logger;
<i>62</i>&nbsp;import org.slf4j.LoggerFactory;
<i>63</i>&nbsp;
<i>64</i>&nbsp;import javafx.application.Platform;
<i>65</i>&nbsp;import javafx.beans.binding.Bindings;
<i>66</i>&nbsp;import javafx.beans.property.BooleanProperty;
<i>67</i>&nbsp;import javafx.beans.property.DoubleProperty;
<i>68</i>&nbsp;import javafx.beans.property.IntegerProperty;
<i>69</i>&nbsp;import javafx.beans.property.ObjectProperty;
<i>70</i>&nbsp;import javafx.beans.property.ReadOnlyObjectProperty;
<i>71</i>&nbsp;import javafx.beans.property.SimpleBooleanProperty;
<i>72</i>&nbsp;import javafx.beans.property.SimpleDoubleProperty;
<i>73</i>&nbsp;import javafx.beans.property.SimpleIntegerProperty;
<i>74</i>&nbsp;import javafx.beans.property.SimpleObjectProperty;
<i>75</i>&nbsp;import javafx.beans.property.SimpleStringProperty;
<i>76</i>&nbsp;import javafx.beans.value.ChangeListener;
<i>77</i>&nbsp;import javafx.beans.value.ObservableValue;
<i>78</i>&nbsp;import javafx.beans.value.WeakChangeListener;
<i>79</i>&nbsp;import javafx.collections.FXCollections;
<i>80</i>&nbsp;import javafx.collections.ListChangeListener;
<i>81</i>&nbsp;import javafx.collections.ListChangeListener.Change;
<i>82</i>&nbsp;import javafx.collections.ObservableList;
<i>83</i>&nbsp;import javafx.collections.transformation.FilteredList;
<i>84</i>&nbsp;import javafx.collections.transformation.SortedList;
<i>85</i>&nbsp;import javafx.geometry.Insets;
<i>86</i>&nbsp;import javafx.geometry.Orientation;
<i>87</i>&nbsp;import javafx.geometry.Pos;
<i>88</i>&nbsp;import javafx.geometry.Side;
<i>89</i>&nbsp;import javafx.scene.Node;
<i>90</i>&nbsp;import javafx.scene.Scene;
<i>91</i>&nbsp;import javafx.scene.chart.NumberAxis;
<i>92</i>&nbsp;import javafx.scene.chart.ScatterChart;
<i>93</i>&nbsp;import javafx.scene.chart.XYChart;
<i>94</i>&nbsp;import javafx.scene.control.Button;
<i>95</i>&nbsp;import javafx.scene.control.CheckBox;
<i>96</i>&nbsp;import javafx.scene.control.ComboBox;
<i>97</i>&nbsp;import javafx.scene.control.ContextMenu;
<i>98</i>&nbsp;import javafx.scene.control.Label;
<i>99</i>&nbsp;import javafx.scene.control.ListView;
<i>100</i>&nbsp;import javafx.scene.control.Menu;
<i>101</i>&nbsp;import javafx.scene.control.MenuBar;
<i>102</i>&nbsp;import javafx.scene.control.MenuItem;
<i>103</i>&nbsp;import javafx.scene.control.ScrollPane;
<i>104</i>&nbsp;import javafx.scene.control.ScrollPane.ScrollBarPolicy;
<i>105</i>&nbsp;import javafx.scene.control.SelectionMode;
<i>106</i>&nbsp;import javafx.scene.control.Separator;
<i>107</i>&nbsp;import javafx.scene.control.SeparatorMenuItem;
<i>108</i>&nbsp;import javafx.scene.control.Tab;
<i>109</i>&nbsp;import javafx.scene.control.TabPane;
<i>110</i>&nbsp;import javafx.scene.control.TabPane.TabClosingPolicy;
<i>111</i>&nbsp;import javafx.scene.control.TableColumn;
<i>112</i>&nbsp;import javafx.scene.control.TableView;
<i>113</i>&nbsp;import javafx.scene.control.TextField;
<i>114</i>&nbsp;import javafx.scene.control.TitledPane;
<i>115</i>&nbsp;import javafx.scene.control.ToolBar;
<i>116</i>&nbsp;import javafx.scene.control.Tooltip;
<i>117</i>&nbsp;import javafx.scene.control.TreeItem;
<i>118</i>&nbsp;import javafx.scene.control.TreeTableColumn;
<i>119</i>&nbsp;import javafx.scene.control.TreeTableColumn.CellDataFeatures;
<i>120</i>&nbsp;import javafx.scene.control.TreeTableRow;
<i>121</i>&nbsp;import javafx.scene.control.TreeTableView;
<i>122</i>&nbsp;import javafx.scene.control.cell.CheckBoxTableCell;
<i>123</i>&nbsp;import javafx.scene.effect.DropShadow;
<i>124</i>&nbsp;import javafx.scene.input.Clipboard;
<i>125</i>&nbsp;import javafx.scene.input.KeyCode;
<i>126</i>&nbsp;import javafx.scene.input.KeyCodeCombination;
<i>127</i>&nbsp;import javafx.scene.input.KeyCombination;
<i>128</i>&nbsp;import javafx.scene.input.KeyEvent;
<i>129</i>&nbsp;import javafx.scene.layout.BorderPane;
<i>130</i>&nbsp;import javafx.scene.layout.GridPane;
<i>131</i>&nbsp;import javafx.scene.layout.Pane;
<i>132</i>&nbsp;import javafx.scene.layout.Priority;
<i>133</i>&nbsp;import javafx.scene.layout.VBox;
<i>134</i>&nbsp;import javafx.scene.text.Text;
<i>135</i>&nbsp;import javafx.scene.text.TextAlignment;
<i>136</i>&nbsp;import javafx.stage.Stage;
<i>137</i>&nbsp;import javafx.util.Callback;
<i>138</i>&nbsp;import qupath.lib.common.GeneralTools;
<i>139</i>&nbsp;import qupath.lib.gui.QuPathGUI;
<i>140</i>&nbsp;import qupath.lib.gui.charts.ChartTools;
<i>141</i>&nbsp;import qupath.lib.gui.charts.HistogramDisplay;
<i>142</i>&nbsp;import qupath.lib.gui.commands.SummaryMeasurementTableCommand;
<i>143</i>&nbsp;import qupath.lib.gui.dialogs.Dialogs;
<i>144</i>&nbsp;import qupath.lib.gui.measure.ObservableMeasurementTableData;
<i>145</i>&nbsp;import qupath.lib.gui.measure.PathTableData;
<i>146</i>&nbsp;import qupath.lib.gui.prefs.PathPrefs;
<i>147</i>&nbsp;import qupath.lib.gui.tma.TMAEntries.TMAEntry;
<i>148</i>&nbsp;import qupath.lib.gui.tma.TMAEntries.TMAObjectEntry;
<i>149</i>&nbsp;import qupath.lib.gui.tools.MenuTools;
<i>150</i>&nbsp;import qupath.lib.gui.tools.PaneTools;
<i>151</i>&nbsp;import qupath.lib.images.ImageData;
<i>152</i>&nbsp;import qupath.lib.images.servers.ServerTools;
<i>153</i>&nbsp;import qupath.lib.io.PathIO;
<i>154</i>&nbsp;import qupath.lib.io.TMAScoreImporter;
<i>155</i>&nbsp;import qupath.lib.measurements.MeasurementList;
<i>156</i>&nbsp;import qupath.lib.objects.TMACoreObject;
<i>157</i>&nbsp;import qupath.lib.objects.hierarchy.DefaultTMAGrid;
<i>158</i>&nbsp;import qupath.lib.objects.hierarchy.PathObjectHierarchy;
<i>159</i>&nbsp;import qupath.lib.objects.hierarchy.TMAGrid;
<i>160</i>&nbsp;import qupath.lib.projects.Project;
<i>161</i>&nbsp;import qupath.lib.projects.ProjectImageEntry;
<i>162</i>&nbsp;
<i>163</i>&nbsp;
<i>164</i>&nbsp;/**
<i>165</i>&nbsp; * Standalone viewer for looking at TMA summary results.
<i>166</i>&nbsp; * 
<i>167</i>&nbsp; * @author Pete Bankhead
<i>168</i>&nbsp; *
<i>169</i>&nbsp; */
<i>170</i>&nbsp;public class TMASummaryViewer {
<i>171</i>&nbsp;	
<b class="nc"><i>172</i>&nbsp;	private final static Logger logger = LoggerFactory.getLogger(TMASummaryViewer.class);</b>
<i>173</i>&nbsp;	
<b class="nc"><i>174</i>&nbsp;	private IntegerProperty maxSmallWidth = new SimpleIntegerProperty(150);</b>
<i>175</i>&nbsp;	
<b class="nc"><i>176</i>&nbsp;	private TMAImageCache imageCache = new TMAImageCache(maxSmallWidth.get());</b>
<i>177</i>&nbsp;	
<b class="nc"><i>178</i>&nbsp;	private static String MISSING_COLUMN = &quot;Missing&quot;;</b>
<i>179</i>&nbsp;
<i>180</i>&nbsp;	private final Stage stage;
<i>181</i>&nbsp;
<b class="nc"><i>182</i>&nbsp;	private ObservableList&lt;String&gt; metadataNames = FXCollections.observableArrayList();</b>
<b class="nc"><i>183</i>&nbsp;	private ObservableList&lt;String&gt; measurementNames = FXCollections.observableArrayList();</b>
<b class="nc"><i>184</i>&nbsp;	private ObservableList&lt;String&gt; filteredMeasurementNames = new FilteredList&lt;&gt;(measurementNames, m -&gt; !TMASummaryEntry.isSurvivalColumn(m));</b>
<i>185</i>&nbsp;
<b class="nc"><i>186</i>&nbsp;	private ObservableList&lt;String&gt; survivalColumns = FXCollections.observableArrayList();</b>
<b class="nc"><i>187</i>&nbsp;	private ComboBox&lt;String&gt; comboSurvival = new ComboBox&lt;&gt;(survivalColumns);</b>
<i>188</i>&nbsp;
<b class="nc"><i>189</i>&nbsp;	private ObservableList&lt;TMAEntry&gt; entriesBase = FXCollections.observableArrayList();</b>
<i>190</i>&nbsp;	
<i>191</i>&nbsp;	/**
<i>192</i>&nbsp;	 * If trimUniqueIDs is true, Unique ID string will be trimmed to remove whitespace.
<i>193</i>&nbsp;	 * This can help with alignment problems due to the ID containing (unrecognized) additional spaces.
<i>194</i>&nbsp;	 */
<b class="nc"><i>195</i>&nbsp;	private boolean trimUniqueIDs = true;</b>
<i>196</i>&nbsp;	
<i>197</i>&nbsp;	/**
<i>198</i>&nbsp;	 * Maintain a reference to columns that were previously hidden whenever loading new data.
<i>199</i>&nbsp;	 * This helps maintain some continuity, so that if any columns have the same names then they 
<i>200</i>&nbsp;	 * can be hidden as well.
<i>201</i>&nbsp;	 */
<b class="nc"><i>202</i>&nbsp;	private Set&lt;String&gt; lastHiddenColumns = new HashSet&lt;&gt;();</b>
<i>203</i>&nbsp;	
<b class="nc"><i>204</i>&nbsp;	private String colCensored = null;</b>
<i>205</i>&nbsp;	
<i>206</i>&nbsp;	private Scene scene;
<i>207</i>&nbsp;
<i>208</i>&nbsp;	
<b class="nc"><i>209</i>&nbsp;	private static enum ImageAvailability {IMAGE_ONLY, OVERLAY_ONLY, BOTH, NONE}</b>
<b class="nc"><i>210</i>&nbsp;	private static ObjectProperty&lt;ImageAvailability&gt; imageAvailability = new SimpleObjectProperty&lt;&gt;(ImageAvailability.NONE);</b>
<i>211</i>&nbsp;	
<i>212</i>&nbsp;	
<i>213</i>&nbsp;	
<i>214</i>&nbsp;	/**
<i>215</i>&nbsp;	 * A combo-box representing the main measurement.
<i>216</i>&nbsp;	 * This will be used for any survival curves.
<i>217</i>&nbsp;	 */
<b class="nc"><i>218</i>&nbsp;	private ComboBox&lt;String&gt; comboMainMeasurement = new ComboBox&lt;&gt;(filteredMeasurementNames);</b>
<i>219</i>&nbsp;	
<i>220</i>&nbsp;	/**
<i>221</i>&nbsp;	 * A combo-box representing how measurements are combined whenever multiple cores are available per patient.
<i>222</i>&nbsp;	 * 
<i>223</i>&nbsp;	 * Options include min, max, mean &amp; median.
<i>224</i>&nbsp;	 */
<b class="nc"><i>225</i>&nbsp;	private ComboBox&lt;TMAEntries.MeasurementCombinationMethod&gt; comboMeasurementMethod = new ComboBox&lt;&gt;();</b>
<b class="nc"><i>226</i>&nbsp;	private ReadOnlyObjectProperty&lt;TMAEntries.MeasurementCombinationMethod&gt; selectedMeasurementCombinationProperty = comboMeasurementMethod.getSelectionModel().selectedItemProperty();</b>
<i>227</i>&nbsp;	
<i>228</i>&nbsp;	
<b class="nc"><i>229</i>&nbsp;	private TreeTableView&lt;TMAEntry&gt; table = new TreeTableView&lt;&gt;();</b>
<i>230</i>&nbsp;	private TMATableModel model;
<i>231</i>&nbsp;
<b class="nc"><i>232</i>&nbsp;	private TMAEntry entrySelected = null;</b>
<i>233</i>&nbsp;
<b class="nc"><i>234</i>&nbsp;	private BooleanProperty hidePaneProperty = new SimpleBooleanProperty(false);</b>
<b class="nc"><i>235</i>&nbsp;	private BooleanProperty useSelectedProperty = new SimpleBooleanProperty(false);</b>
<b class="nc"><i>236</i>&nbsp;	private BooleanProperty skipMissingCoresProperty = new SimpleBooleanProperty(true);</b>
<b class="nc"><i>237</i>&nbsp;	private BooleanProperty groupByIDProperty = new SimpleBooleanProperty(true);</b>
<i>238</i>&nbsp;
<i>239</i>&nbsp;	private HistogramDisplay histogramDisplay;
<i>240</i>&nbsp;	private	KaplanMeierDisplay kmDisplay;
<b class="nc"><i>241</i>&nbsp;	private ScatterPane scatterPane = new ScatterPane();</b>
<i>242</i>&nbsp;	
<i>243</i>&nbsp;	
<b class="nc"><i>244</i>&nbsp;	private ObservableValue&lt;Predicate&lt;TMAEntry&gt;&gt; predicateHideMissing = Bindings.createObjectBinding(() -&gt; {</b>
<b class="nc"><i>245</i>&nbsp;		if (!skipMissingCoresProperty.get())</b>
<b class="nc"><i>246</i>&nbsp;			return c -&gt; true;</b>
<i>247</i>&nbsp;		else
<b class="nc"><i>248</i>&nbsp;			return c -&gt; !c.isMissing();</b>
<i>249</i>&nbsp;		}, skipMissingCoresProperty);
<i>250</i>&nbsp;	
<b class="nc"><i>251</i>&nbsp;	private ObjectProperty&lt;Predicate&lt;TMAEntry&gt;&gt; predicateMetadataFilter = new SimpleObjectProperty&lt;&gt;();</b>
<i>252</i>&nbsp;	
<b class="nc"><i>253</i>&nbsp;	private ObjectProperty&lt;Predicate&lt;TMAEntry&gt;&gt; predicateMeasurements = new SimpleObjectProperty&lt;&gt;();</b>
<i>254</i>&nbsp;
<i>255</i>&nbsp;	private ObservableValue&lt;Predicate&lt;TMAEntry&gt;&gt; combinedPredicate;
<i>256</i>&nbsp;
<i>257</i>&nbsp;	
<i>258</i>&nbsp;	/**
<i>259</i>&nbsp;	 * Constructor.
<i>260</i>&nbsp;	 * @param stage stage that should be used for this TMA summary viewer. If null, a new stage will be created.
<i>261</i>&nbsp;	 */
<b class="nc"><i>262</i>&nbsp;	public TMASummaryViewer(final Stage stage) {</b>
<b class="nc"><i>263</i>&nbsp;		if (stage == null)</b>
<b class="nc"><i>264</i>&nbsp;			this.stage = new Stage();</b>
<i>265</i>&nbsp;		else
<b class="nc"><i>266</i>&nbsp;			this.stage = stage;</b>
<i>267</i>&nbsp;		
<b class="nc"><i>268</i>&nbsp;		logger.trace(&quot;Creating TMA summary viewer&quot;);</b>
<i>269</i>&nbsp;		
<b class="nc"><i>270</i>&nbsp;		combinedPredicate = Bindings.createObjectBinding(() -&gt; {</b>
<b class="nc"><i>271</i>&nbsp;			Predicate&lt;TMAEntry&gt; thisPredicate = predicateHideMissing.getValue();</b>
<b class="nc"><i>272</i>&nbsp;			if (predicateMeasurements.get() != null)</b>
<b class="nc"><i>273</i>&nbsp;				thisPredicate = thisPredicate.and(predicateMeasurements.getValue());</b>
<b class="nc"><i>274</i>&nbsp;			if (predicateMetadataFilter.get() != null)</b>
<b class="nc"><i>275</i>&nbsp;				thisPredicate = thisPredicate.and(predicateMetadataFilter.getValue());</b>
<b class="nc"><i>276</i>&nbsp;			return thisPredicate;</b>
<i>277</i>&nbsp;		}, predicateMeasurements, predicateHideMissing, predicateMetadataFilter);
<i>278</i>&nbsp;		
<b class="nc"><i>279</i>&nbsp;		initialize();</b>
<b class="nc"><i>280</i>&nbsp;		this.stage.setTitle(&quot;TMA Results Viewer&quot;);</b>
<b class="nc"><i>281</i>&nbsp;		this.stage.setScene(scene);</b>
<b class="nc"><i>282</i>&nbsp;		new DragDropTMADataImportListener(this);</b>
<i>283</i>&nbsp;	}
<i>284</i>&nbsp;	
<i>285</i>&nbsp;
<i>286</i>&nbsp;	private void initialize() {
<i>287</i>&nbsp;		
<b class="nc"><i>288</i>&nbsp;		model = new TMATableModel();</b>
<i>289</i>&nbsp;		
<b class="nc"><i>290</i>&nbsp;		groupByIDProperty.addListener((v, o, n) -&gt; refreshTableData());</b>
<i>291</i>&nbsp;
<b class="nc"><i>292</i>&nbsp;		MenuBar menuBar = new MenuBar();</b>
<b class="nc"><i>293</i>&nbsp;		Menu menuFile = new Menu(&quot;File&quot;);</b>
<b class="nc"><i>294</i>&nbsp;		MenuItem miOpen = new MenuItem(&quot;Open...&quot;);</b>
<b class="nc"><i>295</i>&nbsp;		miOpen.setAccelerator(new KeyCodeCombination(KeyCode.O, KeyCombination.SHORTCUT_DOWN));</b>
<b class="nc"><i>296</i>&nbsp;		miOpen.setOnAction(e -&gt; {</b>
<b class="nc"><i>297</i>&nbsp;			File file = Dialogs.getChooser(stage).promptForFile(null, null, &quot;TMA data files&quot;, new String[]{&quot;qptma&quot;});</b>
<b class="nc"><i>298</i>&nbsp;			if (file == null)</b>
<i>299</i>&nbsp;				return;
<b class="nc"><i>300</i>&nbsp;			setInputFile(file);</b>
<i>301</i>&nbsp;		});
<i>302</i>&nbsp;		
<b class="nc"><i>303</i>&nbsp;		MenuItem miSave = new MenuItem(&quot;Save As...&quot;);</b>
<b class="nc"><i>304</i>&nbsp;		miSave.setAccelerator(new KeyCodeCombination(KeyCode.S, KeyCombination.SHORTCUT_DOWN, KeyCombination.SHIFT_DOWN));</b>
<b class="nc"><i>305</i>&nbsp;		miSave.setOnAction(e -&gt; SummaryMeasurementTableCommand.saveTableModel(model, null, Collections.emptyList()));</b>
<i>306</i>&nbsp;		
<i>307</i>&nbsp;		
<b class="nc"><i>308</i>&nbsp;		MenuItem miImportFromImage = new MenuItem(&quot;Import from current image...&quot;);</b>
<b class="nc"><i>309</i>&nbsp;		miImportFromImage.setAccelerator(new KeyCodeCombination(KeyCode.I, KeyCombination.SHORTCUT_DOWN, KeyCombination.SHIFT_DOWN));</b>
<b class="nc"><i>310</i>&nbsp;		miImportFromImage.setOnAction(e -&gt; setTMAEntriesFromOpenImage());</b>
<i>311</i>&nbsp;		
<i>312</i>&nbsp;		
<b class="nc"><i>313</i>&nbsp;		MenuItem miImportFromProject = new MenuItem(&quot;Import from current project... (experimental)&quot;);</b>
<b class="nc"><i>314</i>&nbsp;		miImportFromProject.setAccelerator(new KeyCodeCombination(KeyCode.P, KeyCombination.SHORTCUT_DOWN, KeyCombination.SHIFT_DOWN));</b>
<b class="nc"><i>315</i>&nbsp;		miImportFromProject.setOnAction(e -&gt; setTMAEntriesFromOpenProject());</b>
<i>316</i>&nbsp;		
<i>317</i>&nbsp;		
<b class="nc"><i>318</i>&nbsp;		MenuItem miImportClipboard = new MenuItem(&quot;Import from clipboard...&quot;);</b>
<b class="nc"><i>319</i>&nbsp;		miImportClipboard.setOnAction(e -&gt; {</b>
<b class="nc"><i>320</i>&nbsp;			String text = Clipboard.getSystemClipboard().getString();</b>
<b class="nc"><i>321</i>&nbsp;			if (text == null) {</b>
<b class="nc"><i>322</i>&nbsp;				Dialogs.showErrorMessage(&quot;Import scores&quot;, &quot;Clipboard is empty!&quot;);</b>
<i>323</i>&nbsp;				return;
<i>324</i>&nbsp;			}
<b class="nc"><i>325</i>&nbsp;			int n = importScores(text);</b>
<b class="nc"><i>326</i>&nbsp;			if (n &gt; 0) {</b>
<b class="nc"><i>327</i>&nbsp;				setTMAEntries(new ArrayList&lt;&gt;(entriesBase));</b>
<i>328</i>&nbsp;			}
<b class="nc"><i>329</i>&nbsp;			Dialogs.showMessageDialog(&quot;Import scores&quot;, &quot;Number of scores imported: &quot; + n);</b>
<i>330</i>&nbsp;		});
<i>331</i>&nbsp;		
<b class="nc"><i>332</i>&nbsp;		Menu menuEdit = new Menu(&quot;Edit&quot;);</b>
<b class="nc"><i>333</i>&nbsp;		MenuItem miCopy = new MenuItem(&quot;Copy table to clipboard&quot;);</b>
<b class="nc"><i>334</i>&nbsp;		miCopy.setOnAction(e -&gt; {</b>
<b class="nc"><i>335</i>&nbsp;			SummaryMeasurementTableCommand.copyTableContentsToClipboard(model, Collections.emptyList());</b>
<i>336</i>&nbsp;		});
<i>337</i>&nbsp;		
<i>338</i>&nbsp;		
<b class="nc"><i>339</i>&nbsp;		combinedPredicate.addListener((v, o, n) -&gt; {</b>
<i>340</i>&nbsp;			// We want any other changes triggered by this to have happened, 
<i>341</i>&nbsp;			// so that the data has already been updated
<b class="nc"><i>342</i>&nbsp;			Platform.runLater(() -&gt; handleTableContentChange());</b>
<i>343</i>&nbsp;		});
<i>344</i>&nbsp;		
<i>345</i>&nbsp;		// Reset the scores for missing cores - this ensures they will be NaN and not influence subsequent results
<b class="nc"><i>346</i>&nbsp;		MenuItem miResetMissingScores = new MenuItem(&quot;Reset scores for missing cores&quot;);</b>
<b class="nc"><i>347</i>&nbsp;		miResetMissingScores.setOnAction(e -&gt; {</b>
<b class="nc"><i>348</i>&nbsp;			int changes = 0;</b>
<b class="nc"><i>349</i>&nbsp;			for (TMAEntry entry : entriesBase) {</b>
<b class="nc"><i>350</i>&nbsp;				if (!entry.isMissing())</b>
<b class="nc"><i>351</i>&nbsp;					continue;</b>
<b class="nc"><i>352</i>&nbsp;				boolean changed = false;</b>
<b class="nc"><i>353</i>&nbsp;				for (String m : entry.getMeasurementNames().toArray(new String[0])) {</b>
<b class="nc"><i>354</i>&nbsp;					if (!TMASummaryEntry.isSurvivalColumn(m) &amp;&amp; !Double.isNaN(entry.getMeasurementAsDouble(m))) {</b>
<b class="nc"><i>355</i>&nbsp;						entry.putMeasurement(m, null);</b>
<b class="nc"><i>356</i>&nbsp;						changed = true;</b>
<i>357</i>&nbsp;					}
<i>358</i>&nbsp;				}
<b class="nc"><i>359</i>&nbsp;				if (changed)</b>
<b class="nc"><i>360</i>&nbsp;					changes++;</b>
<b class="nc"><i>361</i>&nbsp;			}</b>
<b class="nc"><i>362</i>&nbsp;			if (changes == 0) {</b>
<b class="nc"><i>363</i>&nbsp;				logger.info(&quot;No changes made when resetting scores for missing cores!&quot;);</b>
<i>364</i>&nbsp;				return;
<i>365</i>&nbsp;			}
<b class="nc"><i>366</i>&nbsp;			logger.info(&quot;{} change(s) made when resetting scores for missing cores!&quot;, changes);</b>
<b class="nc"><i>367</i>&nbsp;			table.refresh();</b>
<b class="nc"><i>368</i>&nbsp;			updateSurvivalCurves();</b>
<b class="nc"><i>369</i>&nbsp;			if (scatterPane != null)</b>
<b class="nc"><i>370</i>&nbsp;				scatterPane.updateChart();</b>
<b class="nc"><i>371</i>&nbsp;			if (histogramDisplay != null)</b>
<b class="nc"><i>372</i>&nbsp;				histogramDisplay.refreshHistogram();</b>
<i>373</i>&nbsp;		});
<b class="nc"><i>374</i>&nbsp;		menuEdit.getItems().add(miResetMissingScores);</b>
<i>375</i>&nbsp;		
<i>376</i>&nbsp;		
<i>377</i>&nbsp;
<b class="nc"><i>378</i>&nbsp;		MenuTools.addMenuItems(</b>
<i>379</i>&nbsp;				menuFile,
<i>380</i>&nbsp;				miOpen,
<i>381</i>&nbsp;				miSave,
<i>382</i>&nbsp;				null,
<i>383</i>&nbsp;				miImportClipboard,
<i>384</i>&nbsp;				null,
<i>385</i>&nbsp;				miImportFromImage,
<i>386</i>&nbsp;				miImportFromProject
<i>387</i>&nbsp;				);
<b class="nc"><i>388</i>&nbsp;		menuBar.getMenus().add(menuFile);</b>
<b class="nc"><i>389</i>&nbsp;		menuEdit.getItems().add(miCopy);</b>
<b class="nc"><i>390</i>&nbsp;		menuBar.getMenus().add(menuEdit);</b>
<i>391</i>&nbsp;
<i>392</i>&nbsp;		
<b class="nc"><i>393</i>&nbsp;		menuFile.setOnShowing(e -&gt; {</b>
<b class="nc"><i>394</i>&nbsp;			boolean imageDataAvailable = QuPathGUI.getInstance() != null &amp;&amp; QuPathGUI.getInstance().getImageData() != null &amp;&amp; QuPathGUI.getInstance().getImageData().getHierarchy().getTMAGrid() != null;</b>
<b class="nc"><i>395</i>&nbsp;			miImportFromImage.setDisable(!imageDataAvailable);</b>
<b class="nc"><i>396</i>&nbsp;			boolean projectAvailable = QuPathGUI.getInstance() != null &amp;&amp; QuPathGUI.getInstance().getProject() != null &amp;&amp; !QuPathGUI.getInstance().getProject().getImageList().isEmpty();</b>
<b class="nc"><i>397</i>&nbsp;			miImportFromProject.setDisable(!projectAvailable);</b>
<i>398</i>&nbsp;		});
<i>399</i>&nbsp;		
<i>400</i>&nbsp;		// Double-clicking previously used for comments... but conflicts with tree table expansion
<i>401</i>&nbsp;//		table.setOnMouseClicked(e -&gt; {
<i>402</i>&nbsp;//			if (!e.isPopupTrigger() &amp;&amp; e.getClickCount() &gt; 1)
<i>403</i>&nbsp;//				promptForComment();
<i>404</i>&nbsp;//		});
<i>405</i>&nbsp;		
<b class="nc"><i>406</i>&nbsp;		table.setPlaceholder(new Text(&quot;Drag TMA data folder onto window, or choose File -&gt; Open&quot;));</b>
<b class="nc"><i>407</i>&nbsp;		table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);</b>
<i>408</i>&nbsp;		
<b class="nc"><i>409</i>&nbsp;		BorderPane pane = new BorderPane();</b>
<b class="nc"><i>410</i>&nbsp;		pane.setTop(menuBar);</b>
<b class="nc"><i>411</i>&nbsp;		menuBar.useSystemMenuBarProperty().bindBidirectional(PathPrefs.useSystemMenubarProperty());</b>
<i>412</i>&nbsp;//		menuBar.setUseSystemMenuBar(true);
<i>413</i>&nbsp;
<i>414</i>&nbsp;		// Create options
<b class="nc"><i>415</i>&nbsp;		ToolBar toolbar = new ToolBar();</b>
<b class="nc"><i>416</i>&nbsp;		Label labelMeasurementMethod = new Label(&quot;Combination method&quot;);</b>
<b class="nc"><i>417</i>&nbsp;		labelMeasurementMethod.setLabelFor(comboMeasurementMethod);</b>
<b class="nc"><i>418</i>&nbsp;		labelMeasurementMethod.setTooltip(new Tooltip(&quot;Method whereby measurements for multiple cores with the same &quot; + TMACoreObject.KEY_UNIQUE_ID + &quot; will be combined&quot;));</b>
<i>419</i>&nbsp;		
<b class="nc"><i>420</i>&nbsp;		CheckBox cbHidePane = new CheckBox(&quot;Hide pane&quot;);</b>
<b class="nc"><i>421</i>&nbsp;		cbHidePane.setSelected(hidePaneProperty.get());</b>
<b class="nc"><i>422</i>&nbsp;		cbHidePane.selectedProperty().bindBidirectional(hidePaneProperty);</b>
<i>423</i>&nbsp;		
<b class="nc"><i>424</i>&nbsp;		CheckBox cbGroupByID = new CheckBox(&quot;Group by ID&quot;);</b>
<b class="nc"><i>425</i>&nbsp;		entriesBase.addListener((Change&lt;? extends TMAEntry&gt; event) -&gt; {</b>
<b class="nc"><i>426</i>&nbsp;			if (!event.getList().stream().anyMatch(e -&gt; e.getMetadataValue(TMACoreObject.KEY_UNIQUE_ID) != null)) {</b>
<b class="nc"><i>427</i>&nbsp;				cbGroupByID.setSelected(false);</b>
<b class="nc"><i>428</i>&nbsp;				cbGroupByID.setDisable(true);</b>
<i>429</i>&nbsp;			} else {
<b class="nc"><i>430</i>&nbsp;				cbGroupByID.setDisable(false);</b>
<i>431</i>&nbsp;			}
<i>432</i>&nbsp;		});
<b class="nc"><i>433</i>&nbsp;		cbGroupByID.setSelected(groupByIDProperty.get());</b>
<b class="nc"><i>434</i>&nbsp;		cbGroupByID.selectedProperty().bindBidirectional(groupByIDProperty);</b>
<i>435</i>&nbsp;		
<b class="nc"><i>436</i>&nbsp;		CheckBox cbUseSelected = new CheckBox(&quot;Use selection only&quot;);</b>
<b class="nc"><i>437</i>&nbsp;		cbUseSelected.selectedProperty().bindBidirectional(useSelectedProperty);</b>
<i>438</i>&nbsp;		
<b class="nc"><i>439</i>&nbsp;		CheckBox cbSkipMissing = new CheckBox(&quot;Hide missing cores&quot;);</b>
<b class="nc"><i>440</i>&nbsp;		cbSkipMissing.selectedProperty().bindBidirectional(skipMissingCoresProperty);</b>
<b class="nc"><i>441</i>&nbsp;		skipMissingCoresProperty.addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>442</i>&nbsp;			table.refresh();</b>
<b class="nc"><i>443</i>&nbsp;			updateSurvivalCurves();</b>
<b class="nc"><i>444</i>&nbsp;			if (histogramDisplay != null)</b>
<b class="nc"><i>445</i>&nbsp;				histogramDisplay.refreshHistogram();</b>
<b class="nc"><i>446</i>&nbsp;			updateSurvivalCurves();</b>
<b class="nc"><i>447</i>&nbsp;			if (scatterPane != null)</b>
<b class="nc"><i>448</i>&nbsp;				scatterPane.updateChart();</b>
<i>449</i>&nbsp;		});
<i>450</i>&nbsp;		
<b class="nc"><i>451</i>&nbsp;		toolbar.getItems().addAll(</b>
<i>452</i>&nbsp;				labelMeasurementMethod,
<i>453</i>&nbsp;				comboMeasurementMethod,
<i>454</i>&nbsp;				new Separator(Orientation.VERTICAL),
<i>455</i>&nbsp;				cbHidePane,
<i>456</i>&nbsp;				new Separator(Orientation.VERTICAL),
<i>457</i>&nbsp;				cbGroupByID,
<i>458</i>&nbsp;				new Separator(Orientation.VERTICAL),
<i>459</i>&nbsp;				cbUseSelected,
<i>460</i>&nbsp;				new Separator(Orientation.VERTICAL),
<i>461</i>&nbsp;				cbSkipMissing
<i>462</i>&nbsp;				);
<b class="nc"><i>463</i>&nbsp;		comboMeasurementMethod.getItems().addAll(TMAEntries.MeasurementCombinationMethod.values());</b>
<b class="nc"><i>464</i>&nbsp;		comboMeasurementMethod.getSelectionModel().select(TMAEntries.MeasurementCombinationMethod.MEDIAN);</b>
<b class="nc"><i>465</i>&nbsp;		selectedMeasurementCombinationProperty.addListener((v, o, n) -&gt; table.refresh());</b>
<i>466</i>&nbsp;
<i>467</i>&nbsp;		
<b class="nc"><i>468</i>&nbsp;		ContextMenu popup = new ContextMenu();</b>
<b class="nc"><i>469</i>&nbsp;		MenuItem miSetMissing = new MenuItem(&quot;Set missing&quot;);</b>
<b class="nc"><i>470</i>&nbsp;		miSetMissing.setOnAction(e -&gt; setSelectedMissingStatus(true));</b>
<i>471</i>&nbsp;
<b class="nc"><i>472</i>&nbsp;		MenuItem miSetAvailable = new MenuItem(&quot;Set available&quot;);</b>
<b class="nc"><i>473</i>&nbsp;		miSetAvailable.setOnAction(e -&gt; setSelectedMissingStatus(false));</b>
<i>474</i>&nbsp;		
<b class="nc"><i>475</i>&nbsp;		MenuItem miExpand = new MenuItem(&quot;Expand all&quot;);</b>
<b class="nc"><i>476</i>&nbsp;		miExpand.setOnAction(e -&gt; {</b>
<b class="nc"><i>477</i>&nbsp;			if (table.getRoot() == null)</b>
<i>478</i>&nbsp;				return;
<b class="nc"><i>479</i>&nbsp;			for (TreeItem&lt;?&gt; item : table.getRoot().getChildren()) {</b>
<b class="nc"><i>480</i>&nbsp;				item.setExpanded(true);</b>
<b class="nc"><i>481</i>&nbsp;			}</b>
<i>482</i>&nbsp;		});
<b class="nc"><i>483</i>&nbsp;		MenuItem miCollapse = new MenuItem(&quot;Collapse all&quot;);</b>
<b class="nc"><i>484</i>&nbsp;		miCollapse.setOnAction(e -&gt; {</b>
<b class="nc"><i>485</i>&nbsp;			if (table.getRoot() == null)</b>
<i>486</i>&nbsp;				return;
<b class="nc"><i>487</i>&nbsp;			for (TreeItem&lt;?&gt; item : table.getRoot().getChildren()) {</b>
<b class="nc"><i>488</i>&nbsp;				item.setExpanded(false);</b>
<b class="nc"><i>489</i>&nbsp;			}</b>
<i>490</i>&nbsp;		});
<b class="nc"><i>491</i>&nbsp;		popup.getItems().addAll(</b>
<i>492</i>&nbsp;				miSetMissing,
<i>493</i>&nbsp;				miSetAvailable,
<i>494</i>&nbsp;				new SeparatorMenuItem(),
<i>495</i>&nbsp;				miExpand,
<i>496</i>&nbsp;				miCollapse);
<b class="nc"><i>497</i>&nbsp;		table.setContextMenu(popup);</b>
<i>498</i>&nbsp;		
<b class="nc"><i>499</i>&nbsp;		table.setRowFactory(e -&gt; {</b>
<b class="nc"><i>500</i>&nbsp;			TreeTableRow&lt;TMAEntry&gt; row = new TreeTableRow&lt;&gt;();</b>
<i>501</i>&nbsp;			
<i>502</i>&nbsp;//			// Make rows invisible if they don&#39;t pass the predicate
<i>503</i>&nbsp;//			row.visibleProperty().bind(Bindings.createBooleanBinding(() -&gt; {
<i>504</i>&nbsp;//					TMAEntry entry = row.getItem();
<i>505</i>&nbsp;//					if (entry == null || (entry.isMissing() &amp;&amp; skipMissingCoresProperty.get()))
<i>506</i>&nbsp;//							return false;
<i>507</i>&nbsp;//					return entries.getPredicate() == null || entries.getPredicate().test(entry);
<i>508</i>&nbsp;//					},
<i>509</i>&nbsp;//					skipMissingCoresProperty,
<i>510</i>&nbsp;//					entries.predicateProperty()));
<i>511</i>&nbsp;			
<i>512</i>&nbsp;			// Style rows according to what they contain
<b class="nc"><i>513</i>&nbsp;			row.styleProperty().bind(</b>
<b class="nc"><i>514</i>&nbsp;					Bindings.createStringBinding(</b>
<i>515</i>&nbsp;							() -&gt; {
<b class="nc"><i>516</i>&nbsp;								if (row.isSelected())</b>
<b class="nc"><i>517</i>&nbsp;									return &quot;&quot;;</b>
<b class="nc"><i>518</i>&nbsp;								TMAEntry entry = row.getItem();</b>
<b class="nc"><i>519</i>&nbsp;								if (entry == null || entry instanceof TMASummaryEntry)</b>
<b class="nc"><i>520</i>&nbsp;									return &quot;&quot;;</b>
<b class="nc"><i>521</i>&nbsp;								else if (entry.isMissing())</b>
<b class="nc"><i>522</i>&nbsp;									return &quot;-fx-background-color:rgb(225,225,232)&quot;;				</b>
<i>523</i>&nbsp;								else
<b class="nc"><i>524</i>&nbsp;									return &quot;-fx-background-color:rgb(240,240,245)&quot;;	</b>
<i>525</i>&nbsp;							},
<b class="nc"><i>526</i>&nbsp;							row.itemProperty(),</b>
<b class="nc"><i>527</i>&nbsp;							row.selectedProperty())</b>
<i>528</i>&nbsp;					);
<i>529</i>&nbsp;//			row.itemProperty().addListener((v, o, n) -&gt; {
<i>530</i>&nbsp;//				if (n == null || n instanceof TMASummaryEntry || row.isSelected())
<i>531</i>&nbsp;//					row.setStyle(&quot;&quot;);
<i>532</i>&nbsp;//				else if (n.isMissing())
<i>533</i>&nbsp;//					row.setStyle(&quot;-fx-background-color:rgb(225,225,232)&quot;);				
<i>534</i>&nbsp;//				else
<i>535</i>&nbsp;//					row.setStyle(&quot;-fx-background-color:rgb(240,240,245)&quot;);				
<i>536</i>&nbsp;//			});
<b class="nc"><i>537</i>&nbsp;			return row;</b>
<i>538</i>&nbsp;		});
<i>539</i>&nbsp;		
<i>540</i>&nbsp;		
<b class="nc"><i>541</i>&nbsp;		BorderPane paneTable = new BorderPane();</b>
<b class="nc"><i>542</i>&nbsp;		paneTable.setTop(toolbar);</b>
<b class="nc"><i>543</i>&nbsp;		paneTable.setCenter(table);</b>
<i>544</i>&nbsp;
<b class="nc"><i>545</i>&nbsp;		MasterDetailPane mdTablePane = new MasterDetailPane(Side.RIGHT, paneTable, createSidePane(), true);</b>
<i>546</i>&nbsp;		
<b class="nc"><i>547</i>&nbsp;		mdTablePane.showDetailNodeProperty().bind(</b>
<b class="nc"><i>548</i>&nbsp;				Bindings.createBooleanBinding(() -&gt;</b>
<b class="nc"><i>549</i>&nbsp;				!hidePaneProperty.get() &amp;&amp; !entriesBase.isEmpty(),</b>
<i>550</i>&nbsp;				hidePaneProperty, entriesBase)
<i>551</i>&nbsp;				);
<b class="nc"><i>552</i>&nbsp;		mdTablePane.setDividerPosition(2.0/3.0);</b>
<i>553</i>&nbsp;
<b class="nc"><i>554</i>&nbsp;		pane.setCenter(mdTablePane);</b>
<i>555</i>&nbsp;		
<i>556</i>&nbsp;		
<i>557</i>&nbsp;		
<b class="nc"><i>558</i>&nbsp;		model.getItems().addListener(new ListChangeListener&lt;TMAEntry&gt;() {</b>
<i>559</i>&nbsp;			@Override
<i>560</i>&nbsp;			public void onChanged(ListChangeListener.Change&lt;? extends TMAEntry&gt; c) {
<b class="nc"><i>561</i>&nbsp;				if (histogramDisplay != null)</b>
<b class="nc"><i>562</i>&nbsp;					histogramDisplay.refreshHistogram();</b>
<b class="nc"><i>563</i>&nbsp;				updateSurvivalCurves();</b>
<b class="nc"><i>564</i>&nbsp;				if (scatterPane != null)</b>
<b class="nc"><i>565</i>&nbsp;					scatterPane.updateChart();</b>
<i>566</i>&nbsp;			}
<i>567</i>&nbsp;		});
<i>568</i>&nbsp;		
<i>569</i>&nbsp;		
<b class="nc"><i>570</i>&nbsp;		Label labelPredicate = new Label();</b>
<b class="nc"><i>571</i>&nbsp;		labelPredicate.setPadding(new Insets(5, 5, 5, 5));</b>
<b class="nc"><i>572</i>&nbsp;		labelPredicate.setAlignment(Pos.CENTER);</b>
<i>573</i>&nbsp;//		labelPredicate.setStyle(&quot;-fx-background-color: rgba(20, 120, 20, 0.15);&quot;);
<b class="nc"><i>574</i>&nbsp;		labelPredicate.setStyle(&quot;-fx-background-color: rgba(120, 20, 20, 0.15);&quot;);</b>
<i>575</i>&nbsp;		
<b class="nc"><i>576</i>&nbsp;		labelPredicate.textProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>577</i>&nbsp;			if (n.trim().length() &gt; 0)</b>
<b class="nc"><i>578</i>&nbsp;				pane.setBottom(labelPredicate);</b>
<i>579</i>&nbsp;			else
<b class="nc"><i>580</i>&nbsp;				pane.setBottom(null);</b>
<i>581</i>&nbsp;		});
<b class="nc"><i>582</i>&nbsp;		labelPredicate.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>583</i>&nbsp;		labelPredicate.setMaxHeight(labelPredicate.getPrefHeight());</b>
<b class="nc"><i>584</i>&nbsp;		labelPredicate.setTextAlignment(TextAlignment.CENTER);</b>
<b class="nc"><i>585</i>&nbsp;		predicateMeasurements.addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>586</i>&nbsp;			if (n == null)</b>
<b class="nc"><i>587</i>&nbsp;				labelPredicate.setText(&quot;&quot;);</b>
<b class="nc"><i>588</i>&nbsp;			else if (n instanceof TablePredicate) {</b>
<b class="nc"><i>589</i>&nbsp;				TablePredicate tp = (TablePredicate)n;</b>
<b class="nc"><i>590</i>&nbsp;				if (tp.getOriginalCommand().trim().isEmpty())</b>
<b class="nc"><i>591</i>&nbsp;					labelPredicate.setText(&quot;&quot;);</b>
<i>592</i>&nbsp;				else
<b class="nc"><i>593</i>&nbsp;					labelPredicate.setText(&quot;Predicate: &quot; + tp.getOriginalCommand());</b>
<b class="nc"><i>594</i>&nbsp;			} else</b>
<b class="nc"><i>595</i>&nbsp;				labelPredicate.setText(&quot;Predicate: &quot; + n.toString());</b>
<i>596</i>&nbsp;		});
<i>597</i>&nbsp;//		predicate.set(new TablePredicate(&quot;\&quot;Tumor\&quot; &gt; 100&quot;));
<i>598</i>&nbsp;		
<b class="nc"><i>599</i>&nbsp;		scene = new Scene(pane);</b>
<i>600</i>&nbsp;		
<b class="nc"><i>601</i>&nbsp;		scene.addEventHandler(KeyEvent.KEY_PRESSED, e -&gt; {</b>
<b class="nc"><i>602</i>&nbsp;			KeyCode code = e.getCode();</b>
<b class="nc"><i>603</i>&nbsp;			if ((code == KeyCode.SPACE || code == KeyCode.ENTER) &amp;&amp; entrySelected != null) {</b>
<b class="nc"><i>604</i>&nbsp;				promptForComment();</b>
<i>605</i>&nbsp;				return;
<i>606</i>&nbsp;			}
<i>607</i>&nbsp;		});
<i>608</i>&nbsp;
<i>609</i>&nbsp;	}
<i>610</i>&nbsp;	
<i>611</i>&nbsp;	
<i>612</i>&nbsp;	
<i>613</i>&nbsp;	private void setSelectedMissingStatus(final boolean status) {
<b class="nc"><i>614</i>&nbsp;		for (TreeItem&lt;TMAEntry&gt; item : table.getSelectionModel().getSelectedItems()) {</b>
<b class="nc"><i>615</i>&nbsp;			item.getValue().setMissing(status);</b>
<b class="nc"><i>616</i>&nbsp;		}</b>
<i>617</i>&nbsp;		// Refresh the table data if necessary
<b class="nc"><i>618</i>&nbsp;		if (skipMissingCoresProperty.get()) {</b>
<b class="nc"><i>619</i>&nbsp;			table.getSelectionModel().clearSelection();</b>
<b class="nc"><i>620</i>&nbsp;			refreshTableData();</b>
<i>621</i>&nbsp;		} else
<b class="nc"><i>622</i>&nbsp;			table.refresh();</b>
<i>623</i>&nbsp;	}
<i>624</i>&nbsp;	
<i>625</i>&nbsp;	
<i>626</i>&nbsp;	
<i>627</i>&nbsp;	
<i>628</i>&nbsp;	/**
<i>629</i>&nbsp;	 * Update data due to a change in table content.
<i>630</i>&nbsp;	 */
<i>631</i>&nbsp;	private void handleTableContentChange() {
<b class="nc"><i>632</i>&nbsp;		table.refresh();</b>
<b class="nc"><i>633</i>&nbsp;		model.refreshList();</b>
<b class="nc"><i>634</i>&nbsp;		histogramDisplay.refreshHistogram();</b>
<b class="nc"><i>635</i>&nbsp;		updateSurvivalCurves();</b>
<b class="nc"><i>636</i>&nbsp;		scatterPane.updateChart();</b>
<i>637</i>&nbsp;	}
<i>638</i>&nbsp;	
<i>639</i>&nbsp;	
<i>640</i>&nbsp;	/**
<i>641</i>&nbsp;	 * Get the stage for display.
<i>642</i>&nbsp;	 * @return
<i>643</i>&nbsp;	 */
<i>644</i>&nbsp;	public Stage getStage() {
<b class="nc"><i>645</i>&nbsp;		return stage;</b>
<i>646</i>&nbsp;	}
<i>647</i>&nbsp;	
<i>648</i>&nbsp;	
<i>649</i>&nbsp;	/**
<i>650</i>&nbsp;	 * Depending on the survival type, get the correct (unambiguous) column title for censoring.
<i>651</i>&nbsp;	 * 
<i>652</i>&nbsp;	 * @param survivalColumn
<i>653</i>&nbsp;	 * @return
<i>654</i>&nbsp;	 */
<i>655</i>&nbsp;	static String getRequestedSurvivalCensoredColumn(final String survivalColumn) {
<b class="nc"><i>656</i>&nbsp;		if (TMACoreObject.KEY_OVERALL_SURVIVAL.equals(survivalColumn)) {</b>
<b class="nc"><i>657</i>&nbsp;			return TMACoreObject.KEY_OS_CENSORED;</b>
<b class="nc"><i>658</i>&nbsp;		} else if (TMACoreObject.KEY_RECURRENCE_FREE_SURVIVAL.equals(survivalColumn)) {</b>
<b class="nc"><i>659</i>&nbsp;			return TMACoreObject.KEY_RFS_CENSORED;</b>
<i>660</i>&nbsp;		}
<b class="nc"><i>661</i>&nbsp;		return null;</b>
<i>662</i>&nbsp;	}
<i>663</i>&nbsp;	
<i>664</i>&nbsp;	
<i>665</i>&nbsp;	private String getSurvivalColumn() {
<b class="nc"><i>666</i>&nbsp;		return comboSurvival.getSelectionModel().getSelectedItem();</b>
<i>667</i>&nbsp;	}
<i>668</i>&nbsp;	
<i>669</i>&nbsp;	
<i>670</i>&nbsp;	private void updateSurvivalCurves() {
<b class="nc"><i>671</i>&nbsp;		String colID = null;</b>
<b class="nc"><i>672</i>&nbsp;		String colScore = null;</b>
<b class="nc"><i>673</i>&nbsp;		colCensored = null;</b>
<b class="nc"><i>674</i>&nbsp;		for (String nameOrig : model.getAllNames()) {</b>
<b class="nc"><i>675</i>&nbsp;			if (nameOrig.equals(TMACoreObject.KEY_UNIQUE_ID))</b>
<b class="nc"><i>676</i>&nbsp;				colID = nameOrig;</b>
<i>677</i>&nbsp;//			else if (nameOrig.equals(TMACoreObject.KEY_CENSORED))
<i>678</i>&nbsp;//				colCensored = nameOrig;
<i>679</i>&nbsp;//			else if (!Number.class.isAssignableFrom())
<i>680</i>&nbsp;//				continue;
<i>681</i>&nbsp;			else  {
<b class="nc"><i>682</i>&nbsp;				if (nameOrig.trim().length() == 0 || !model.getMeasurementNames().contains(nameOrig))</b>
<b class="nc"><i>683</i>&nbsp;					continue;</b>
<b class="nc"><i>684</i>&nbsp;				String name = nameOrig.toLowerCase();</b>
<b class="nc"><i>685</i>&nbsp;				if (name.equals(&quot;h-score&quot;))</b>
<b class="nc"><i>686</i>&nbsp;					colScore = nameOrig;</b>
<b class="nc"><i>687</i>&nbsp;				else if (name.equals(&quot;positive %&quot;) &amp;&amp; colScore == null)</b>
<b class="nc"><i>688</i>&nbsp;					colScore = nameOrig;</b>
<i>689</i>&nbsp;			}
<b class="nc"><i>690</i>&nbsp;		}</b>
<i>691</i>&nbsp;		
<i>692</i>&nbsp;		// Check for a column with the exact requested name
<b class="nc"><i>693</i>&nbsp;		String colCensoredRequested = null;</b>
<b class="nc"><i>694</i>&nbsp;		String colSurvival = getSurvivalColumn();</b>
<b class="nc"><i>695</i>&nbsp;		if (colSurvival != null) {</b>
<b class="nc"><i>696</i>&nbsp;			colCensoredRequested = getRequestedSurvivalCensoredColumn(colSurvival);</b>
<b class="nc"><i>697</i>&nbsp;			if (model.getAllNames().contains(colCensoredRequested))</b>
<b class="nc"><i>698</i>&nbsp;				colCensored = colCensoredRequested;</b>
<i>699</i>&nbsp;			// Check for a general &#39;censored&#39; column... less secure since it doesn&#39;t specify OS or RFS (but helps with backwards-compatibility)
<b class="nc"><i>700</i>&nbsp;			else if (model.getAllNames().contains(&quot;Censored&quot;)) {</b>
<b class="nc"><i>701</i>&nbsp;				logger.warn(&quot;Correct censored column for \&quot;{}\&quot; unavailable - should be \&quot;{}\&quot;, but using \&quot;Censored\&quot; column instead&quot;, colSurvival, colCensoredRequested);</b>
<b class="nc"><i>702</i>&nbsp;				colCensored = &quot;Censored&quot;;</b>
<i>703</i>&nbsp;			}
<i>704</i>&nbsp;		}
<b class="nc"><i>705</i>&nbsp;		if (colCensored == null &amp;&amp; colSurvival != null) {</b>
<b class="nc"><i>706</i>&nbsp;			logger.warn(&quot;Unable to find censored column - survival data will be uncensored&quot;);</b>
<i>707</i>&nbsp;		} else
<b class="nc"><i>708</i>&nbsp;			logger.info(&quot;Survival column: {}, Censored column: {}&quot;, colSurvival, colCensored);</b>
<i>709</i>&nbsp;		
<b class="nc"><i>710</i>&nbsp;		colScore = comboMainMeasurement.getSelectionModel().getSelectedItem();</b>
<b class="nc"><i>711</i>&nbsp;		if (colID == null || colSurvival == null || colCensored == null) {// || colScore == null) {</b>
<i>712</i>&nbsp;			// Adjust priority depending on whether we have any data at all..
<b class="nc"><i>713</i>&nbsp;			if (!model.getItems().isEmpty())</b>
<b class="nc"><i>714</i>&nbsp;				logger.warn(&quot;No survival data found!&quot;);</b>
<i>715</i>&nbsp;			else
<b class="nc"><i>716</i>&nbsp;				logger.trace(&quot;No entries or survival data available&quot;);</b>
<i>717</i>&nbsp;			return;
<i>718</i>&nbsp;		}
<i>719</i>&nbsp;		
<i>720</i>&nbsp;		// Generate a pseudo TMA core hierarchy
<b class="nc"><i>721</i>&nbsp;		Map&lt;String, List&lt;TMAEntry&gt;&gt; scoreMap = createScoresMap(model.getItems(), colScore, colID);</b>
<i>722</i>&nbsp;		
<i>723</i>&nbsp;//		System.err.println(&quot;Score map size: &quot; + scoreMap.size() + &quot;\tEntries: &quot; + model.getEntries().size());
<i>724</i>&nbsp;		
<b class="nc"><i>725</i>&nbsp;		List&lt;TMACoreObject&gt; cores = new ArrayList&lt;&gt;(scoreMap.size());</b>
<b class="nc"><i>726</i>&nbsp;		double[] scores = new double[15];</b>
<b class="nc"><i>727</i>&nbsp;		for (Entry&lt;String, List&lt;TMAEntry&gt;&gt; entry : scoreMap.entrySet()) {</b>
<i>728</i>&nbsp;
<b class="nc"><i>729</i>&nbsp;			TMACoreObject core = new TMACoreObject();</b>
<b class="nc"><i>730</i>&nbsp;			core.setName(&quot;ID: &quot; + entry.getKey());</b>
<b class="nc"><i>731</i>&nbsp;			MeasurementList ml = core.getMeasurementList();</b>
<b class="nc"><i>732</i>&nbsp;			Arrays.fill(scores, Double.POSITIVE_INFINITY);</b>
<b class="nc"><i>733</i>&nbsp;			List&lt;TMAEntry&gt; list = entry.getValue();</b>
<i>734</i>&nbsp;			// Increase array size, if needed
<b class="nc"><i>735</i>&nbsp;			if (list.size() &gt; scores.length)</b>
<b class="nc"><i>736</i>&nbsp;				scores = new double[list.size()];</b>
<b class="nc"><i>737</i>&nbsp;			for (int i = 0; i &lt; list.size(); i++) {</b>
<b class="nc"><i>738</i>&nbsp;				scores[i] = model.getNumericValue(list.get(i), colScore);</b>
<i>739</i>&nbsp;//				scores[i] = list.get(i).getMeasurement(colScore).doubleValue();
<i>740</i>&nbsp;			}
<b class="nc"><i>741</i>&nbsp;			Arrays.sort(scores);</b>
<b class="nc"><i>742</i>&nbsp;			int n = list.size();</b>
<i>743</i>&nbsp;			double score;
<b class="nc"><i>744</i>&nbsp;			if (n % 2 == 1)</b>
<b class="nc"><i>745</i>&nbsp;				score = scores[n / 2];</b>
<i>746</i>&nbsp;			else
<b class="nc"><i>747</i>&nbsp;				score = (scores[n/2-1] + scores[n/2]) / 2;</b>
<i>748</i>&nbsp;
<b class="nc"><i>749</i>&nbsp;			core.putMetadataValue(TMACoreObject.KEY_UNIQUE_ID, entry.getKey());</b>
<i>750</i>&nbsp;//			System.err.println(&quot;Putting: &quot; + list.get(0).getMeasurement(colSurvival).doubleValue() + &quot; LIST: &quot; + list.size());
<b class="nc"><i>751</i>&nbsp;			ml.putMeasurement(colSurvival, list.get(0).getMeasurementAsDouble(colSurvival));</b>
<b class="nc"><i>752</i>&nbsp;			ml.putMeasurement(colCensoredRequested, list.get(0).getMeasurementAsDouble(colCensored));</b>
<b class="nc"><i>753</i>&nbsp;			if (colScore != null)</b>
<b class="nc"><i>754</i>&nbsp;				ml.putMeasurement(colScore, score);</b>
<i>755</i>&nbsp;
<b class="nc"><i>756</i>&nbsp;			cores.add(core);</b>
<i>757</i>&nbsp;			
<i>758</i>&nbsp;//			logger.info(entry.getKey() + &quot;\t&quot; + score);
<b class="nc"><i>759</i>&nbsp;		}</b>
<i>760</i>&nbsp;
<b class="nc"><i>761</i>&nbsp;		TMAGrid grid = DefaultTMAGrid.create(cores, 1);</b>
<b class="nc"><i>762</i>&nbsp;		PathObjectHierarchy hierarchy = new PathObjectHierarchy();</b>
<b class="nc"><i>763</i>&nbsp;		hierarchy.setTMAGrid(grid);</b>
<b class="nc"><i>764</i>&nbsp;		kmDisplay.setHierarchy(hierarchy, colSurvival, colCensoredRequested);</b>
<b class="nc"><i>765</i>&nbsp;		kmDisplay.setScoreColumn(comboMainMeasurement.getSelectionModel().getSelectedItem());</b>
<i>766</i>&nbsp;//		new KaplanMeierPlotTMA.KaplanMeierDisplay(hierarchy, colScore).show(frame, colScore);
<i>767</i>&nbsp;	}
<i>768</i>&nbsp;	
<i>769</i>&nbsp;	
<i>770</i>&nbsp;	
<i>771</i>&nbsp;	
<i>772</i>&nbsp;	private Pane createSidePane() {
<b class="nc"><i>773</i>&nbsp;		BorderPane pane = new BorderPane();</b>
<i>774</i>&nbsp;		
<b class="nc"><i>775</i>&nbsp;		TabPane tabPane = new TabPane();</b>
<i>776</i>&nbsp;
<b class="nc"><i>777</i>&nbsp;		kmDisplay = new KaplanMeierDisplay(null, null, null, null);</b>
<b class="nc"><i>778</i>&nbsp;		BorderPane paneKaplanMeier = new BorderPane();</b>
<b class="nc"><i>779</i>&nbsp;		paneKaplanMeier.setCenter(kmDisplay.getView());</b>
<b class="nc"><i>780</i>&nbsp;		paneKaplanMeier.setPadding(new Insets(10, 10, 10, 10));</b>
<i>781</i>&nbsp;//		comboMainMeasurement.prefWidthProperty().bind(paneKaplanMeier.widthProperty());
<b class="nc"><i>782</i>&nbsp;		comboMainMeasurement.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>783</i>&nbsp;		comboMainMeasurement.setTooltip(new Tooltip(&quot;Measurement thresholded to create survival curves etc.&quot;));</b>
<i>784</i>&nbsp;
<b class="nc"><i>785</i>&nbsp;		GridPane kmTop = new GridPane();</b>
<b class="nc"><i>786</i>&nbsp;		kmTop.add(new Label(&quot;Score&quot;), 0, 0);</b>
<b class="nc"><i>787</i>&nbsp;		kmTop.add(comboMainMeasurement, 1, 0);</b>
<b class="nc"><i>788</i>&nbsp;		kmTop.add(new Label(&quot;Survival type&quot;), 0, 1);</b>
<b class="nc"><i>789</i>&nbsp;		kmTop.add(comboSurvival, 1, 1);</b>
<b class="nc"><i>790</i>&nbsp;		comboSurvival.setTooltip(new Tooltip(&quot;Specify overall or recurrence-free survival (if applicable)&quot;));</b>
<b class="nc"><i>791</i>&nbsp;		comboSurvival.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>792</i>&nbsp;		GridPane.setHgrow(comboMainMeasurement, Priority.ALWAYS);</b>
<b class="nc"><i>793</i>&nbsp;		GridPane.setHgrow(comboSurvival, Priority.ALWAYS);</b>
<b class="nc"><i>794</i>&nbsp;		kmTop.setHgap(5);</b>
<b class="nc"><i>795</i>&nbsp;		paneKaplanMeier.setTop(kmTop);</b>
<i>796</i>&nbsp;//		kmDisplay.setOrientation(Orientation.VERTICAL);
<i>797</i>&nbsp;		
<b class="nc"><i>798</i>&nbsp;		histogramDisplay = new HistogramDisplay(model, false);</b>
<i>799</i>&nbsp;		
<b class="nc"><i>800</i>&nbsp;		comboMainMeasurement.getSelectionModel().selectedItemProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>801</i>&nbsp;			histogramDisplay.refreshCombo();</b>
<b class="nc"><i>802</i>&nbsp;			histogramDisplay.showHistogram(n);</b>
<b class="nc"><i>803</i>&nbsp;			updateSurvivalCurves();</b>
<i>804</i>&nbsp;		});
<b class="nc"><i>805</i>&nbsp;		comboMeasurementMethod.getSelectionModel().selectedItemProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>806</i>&nbsp;			histogramDisplay.refreshHistogram();</b>
<b class="nc"><i>807</i>&nbsp;			scatterPane.updateChart();</b>
<b class="nc"><i>808</i>&nbsp;			updateSurvivalCurves();</b>
<i>809</i>&nbsp;		});
<b class="nc"><i>810</i>&nbsp;		comboSurvival.getSelectionModel().selectedItemProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>811</i>&nbsp;			updateSurvivalCurves();</b>
<i>812</i>&nbsp;		});
<i>813</i>&nbsp;		
<i>814</i>&nbsp;		
<i>815</i>&nbsp;		
<i>816</i>&nbsp;		
<i>817</i>&nbsp;		
<i>818</i>&nbsp;		// Create a Tab for showing images
<b class="nc"><i>819</i>&nbsp;		BorderPane paneImages = new BorderPane();</b>
<b class="nc"><i>820</i>&nbsp;		CheckBox cbShowOverlay = new CheckBox(&quot;Show overlay&quot;);</b>
<b class="nc"><i>821</i>&nbsp;		imageAvailability.addListener((c, v, n) -&gt; {</b>
<b class="nc"><i>822</i>&nbsp;			if (n == ImageAvailability.OVERLAY_ONLY)</b>
<b class="nc"><i>823</i>&nbsp;				cbShowOverlay.setSelected(true);</b>
<b class="nc"><i>824</i>&nbsp;			else if (n == ImageAvailability.IMAGE_ONLY)</b>
<b class="nc"><i>825</i>&nbsp;				cbShowOverlay.setSelected(false);</b>
<b class="nc"><i>826</i>&nbsp;			cbShowOverlay.setDisable(n != ImageAvailability.BOTH);</b>
<i>827</i>&nbsp;		});
<b class="nc"><i>828</i>&nbsp;		ListView&lt;TMAEntry&gt; listImages = new ListView&lt;&gt;();</b>
<b class="nc"><i>829</i>&nbsp;		listImages.setCellFactory(v -&gt; new ImageListCell(cbShowOverlay.selectedProperty(), imageCache));</b>
<b class="nc"><i>830</i>&nbsp;		listImages.widthProperty().addListener((v, o, n) -&gt; listImages.refresh());</b>
<b class="nc"><i>831</i>&nbsp;		listImages.setStyle(&quot;-fx-control-inner-background-alt: -fx-control-inner-background ;&quot;);</b>
<b class="nc"><i>832</i>&nbsp;		table.getSelectionModel().getSelectedItems().addListener((Change&lt;? extends TreeItem&lt;TMAEntry&gt;&gt; e) -&gt; {</b>
<b class="nc"><i>833</i>&nbsp;			List&lt;TMAEntry&gt; entries = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>834</i>&nbsp;			for (TreeItem&lt;TMAEntry&gt; item : e.getList()) {</b>
<b class="nc"><i>835</i>&nbsp;				if (item.getChildren().isEmpty()) {</b>
<b class="nc"><i>836</i>&nbsp;					if (item.getValue().hasImage() || item.getValue().hasOverlay())</b>
<b class="nc"><i>837</i>&nbsp;						entries.add(item.getValue());</b>
<i>838</i>&nbsp;				} else {
<b class="nc"><i>839</i>&nbsp;					for (TreeItem&lt;TMAEntry&gt; item2 : item.getChildren()) {</b>
<b class="nc"><i>840</i>&nbsp;						if (item2.getValue().hasImage() || item2.getValue().hasOverlay())</b>
<b class="nc"><i>841</i>&nbsp;							entries.add(item2.getValue());</b>
<b class="nc"><i>842</i>&nbsp;					}					</b>
<i>843</i>&nbsp;				}
<b class="nc"><i>844</i>&nbsp;				listImages.getItems().setAll(entries);</b>
<b class="nc"><i>845</i>&nbsp;			}</b>
<i>846</i>&nbsp;		});
<b class="nc"><i>847</i>&nbsp;		cbShowOverlay.setAlignment(Pos.CENTER);</b>
<b class="nc"><i>848</i>&nbsp;		cbShowOverlay.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>849</i>&nbsp;		cbShowOverlay.setPadding(new Insets(5, 5, 5, 5));</b>
<b class="nc"><i>850</i>&nbsp;		cbShowOverlay.selectedProperty().addListener((v, o, n) -&gt; listImages.refresh());</b>
<b class="nc"><i>851</i>&nbsp;		paneImages.setCenter(listImages);</b>
<b class="nc"><i>852</i>&nbsp;		paneImages.setTop(cbShowOverlay);</b>
<i>853</i>&nbsp;		
<i>854</i>&nbsp;		
<i>855</i>&nbsp;		
<i>856</i>&nbsp;		// Determine visibility based upon whether there are any images to show
<i>857</i>&nbsp;//		Tab tabImages = new Tab(&quot;Images&quot;, paneImages);
<i>858</i>&nbsp;		
<i>859</i>&nbsp;		
<b class="nc"><i>860</i>&nbsp;		ScrollPane scrollPane = new ScrollPane(paneKaplanMeier);</b>
<b class="nc"><i>861</i>&nbsp;		scrollPane.setFitToWidth(true);</b>
<b class="nc"><i>862</i>&nbsp;		scrollPane.setFitToHeight(true);</b>
<b class="nc"><i>863</i>&nbsp;		scrollPane.setVbarPolicy(ScrollBarPolicy.AS_NEEDED);</b>
<b class="nc"><i>864</i>&nbsp;		scrollPane.setHbarPolicy(ScrollBarPolicy.AS_NEEDED);</b>
<b class="nc"><i>865</i>&nbsp;		Tab tabSurvival = new Tab(&quot;Survival&quot;, scrollPane);</b>
<b class="nc"><i>866</i>&nbsp;		tabPane.getTabs().addAll(</b>
<b class="nc"><i>867</i>&nbsp;				new Tab(&quot;Table&quot;, getCustomizeTablePane()),</b>
<i>868</i>&nbsp;//				tabImages,
<b class="nc"><i>869</i>&nbsp;				new Tab(&quot;Histogram&quot;, histogramDisplay.getPane()),</b>
<b class="nc"><i>870</i>&nbsp;				new Tab(&quot;Scatterplot&quot;, scatterPane.getPane()),</b>
<i>871</i>&nbsp;				tabSurvival
<i>872</i>&nbsp;				);
<b class="nc"><i>873</i>&nbsp;		tabPane.setTabClosingPolicy(TabClosingPolicy.UNAVAILABLE);</b>
<i>874</i>&nbsp;		
<i>875</i>&nbsp;//		if (imageAvailability.get() != ImageAvailability.NONE)
<i>876</i>&nbsp;//			tabPane.getTabs().add(1, tabImages);
<i>877</i>&nbsp;//		
<i>878</i>&nbsp;//		imageAvailability.addListener((c, v, n) -&gt; {
<i>879</i>&nbsp;//			if (n == ImageAvailability.NONE)
<i>880</i>&nbsp;//				tabPane.getTabs().remove(tabImages);
<i>881</i>&nbsp;//			else if (!tabPane.getTabs().contains(tabImages))
<i>882</i>&nbsp;//				tabPane.getTabs().add(1, tabImages);
<i>883</i>&nbsp;//		});
<i>884</i>&nbsp;		
<i>885</i>&nbsp;//		tabSurvival.visibleProperty().bind(
<i>886</i>&nbsp;//				Bindings.createBooleanBinding(() -&gt; !survivalColumns.isEmpty(), survivalColumns)
<i>887</i>&nbsp;//				);
<i>888</i>&nbsp;
<b class="nc"><i>889</i>&nbsp;		pane.setCenter(tabPane);</b>
<i>890</i>&nbsp;
<b class="nc"><i>891</i>&nbsp;		pane.setMinWidth(350);</b>
<i>892</i>&nbsp;		
<b class="nc"><i>893</i>&nbsp;		return pane;</b>
<i>894</i>&nbsp;	}
<i>895</i>&nbsp;	
<i>896</i>&nbsp;	
<i>897</i>&nbsp;
<i>898</i>&nbsp;	private Pane getCustomizeTablePane() {
<b class="nc"><i>899</i>&nbsp;		TableView&lt;TreeTableColumn&lt;TMAEntry, ?&gt;&gt; tableColumns = new TableView&lt;&gt;();</b>
<b class="nc"><i>900</i>&nbsp;		tableColumns.setPlaceholder(new Text(&quot;No columns available&quot;));</b>
<b class="nc"><i>901</i>&nbsp;		tableColumns.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);</b>
<b class="nc"><i>902</i>&nbsp;		tableColumns.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);</b>
<i>903</i>&nbsp;		
<b class="nc"><i>904</i>&nbsp;		SortedList&lt;TreeTableColumn&lt;TMAEntry, ?&gt;&gt; sortedColumns = new SortedList&lt;&gt;(table.getColumns().filtered(p -&gt; !p.getText().trim().isEmpty()));</b>
<b class="nc"><i>905</i>&nbsp;		sortedColumns.setComparator((c1, c2) -&gt; c1.getText().compareTo(c2.getText()));</b>
<b class="nc"><i>906</i>&nbsp;		tableColumns.setItems(sortedColumns);</b>
<b class="nc"><i>907</i>&nbsp;		sortedColumns.comparatorProperty().bind(tableColumns.comparatorProperty());</b>
<i>908</i>&nbsp;//		sortedColumns.comparatorProperty().bind(tableColumns.comparatorProperty());
<i>909</i>&nbsp;
<i>910</i>&nbsp;		
<b class="nc"><i>911</i>&nbsp;		TableColumn&lt;TreeTableColumn&lt;TMAEntry, ?&gt;, String&gt; columnName = new TableColumn&lt;&gt;(&quot;Column&quot;);</b>
<b class="nc"><i>912</i>&nbsp;		columnName.setCellValueFactory(v -&gt; v.getValue().textProperty());</b>
<b class="nc"><i>913</i>&nbsp;		TableColumn&lt;TreeTableColumn&lt;TMAEntry, ?&gt;, Boolean&gt; columnVisible = new TableColumn&lt;&gt;(&quot;Visible&quot;);</b>
<b class="nc"><i>914</i>&nbsp;		columnVisible.setCellValueFactory(v -&gt; v.getValue().visibleProperty());</b>
<i>915</i>&nbsp;//		columnVisible.setCellValueFactory(col -&gt; {
<i>916</i>&nbsp;//			SimpleBooleanProperty prop = new SimpleBooleanProperty(col.getValue().isVisible());
<i>917</i>&nbsp;//			prop.addListener((v, o, n) -&gt; col.getValue().setVisible(n));
<i>918</i>&nbsp;//			return prop;
<i>919</i>&nbsp;//		});
<b class="nc"><i>920</i>&nbsp;		tableColumns.setEditable(true);</b>
<b class="nc"><i>921</i>&nbsp;		columnVisible.setCellFactory(v -&gt; new CheckBoxTableCell&lt;&gt;());</b>
<b class="nc"><i>922</i>&nbsp;		tableColumns.getColumns().add(columnName);</b>
<b class="nc"><i>923</i>&nbsp;		tableColumns.getColumns().add(columnVisible);</b>
<b class="nc"><i>924</i>&nbsp;		ContextMenu contextMenu = new ContextMenu();</b>
<i>925</i>&nbsp;		
<b class="nc"><i>926</i>&nbsp;		Action actionShowSelected = new Action(&quot;Show selected&quot;, e -&gt; {</b>
<b class="nc"><i>927</i>&nbsp;			for (TreeTableColumn&lt;?, ?&gt; col : tableColumns.getSelectionModel().getSelectedItems()) {</b>
<b class="nc"><i>928</i>&nbsp;				if (col != null)</b>
<b class="nc"><i>929</i>&nbsp;					col.setVisible(true);</b>
<i>930</i>&nbsp;				else {
<i>931</i>&nbsp;					// Not sure why this happens...?
<b class="nc"><i>932</i>&nbsp;					logger.trace(&quot;Selected column is null!&quot;);</b>
<i>933</i>&nbsp;				}
<b class="nc"><i>934</i>&nbsp;			}</b>
<i>935</i>&nbsp;		});
<i>936</i>&nbsp;		
<b class="nc"><i>937</i>&nbsp;		Action actionHideSelected = new Action(&quot;Hide selected&quot;, e -&gt; {</b>
<b class="nc"><i>938</i>&nbsp;			for (TreeTableColumn&lt;?, ?&gt; col : tableColumns.getSelectionModel().getSelectedItems()) {</b>
<b class="nc"><i>939</i>&nbsp;				if (col != null)</b>
<b class="nc"><i>940</i>&nbsp;					col.setVisible(false);</b>
<i>941</i>&nbsp;				else {
<i>942</i>&nbsp;					// Not sure why this happens...?
<b class="nc"><i>943</i>&nbsp;					logger.trace(&quot;Selected column is null!&quot;);</b>
<i>944</i>&nbsp;				}
<b class="nc"><i>945</i>&nbsp;			}</b>
<i>946</i>&nbsp;		});
<i>947</i>&nbsp;		
<b class="nc"><i>948</i>&nbsp;		contextMenu.getItems().addAll(</b>
<b class="nc"><i>949</i>&nbsp;				ActionUtils.createMenuItem(actionShowSelected),</b>
<b class="nc"><i>950</i>&nbsp;				ActionUtils.createMenuItem(actionHideSelected));</b>
<b class="nc"><i>951</i>&nbsp;		tableColumns.setContextMenu(contextMenu);</b>
<b class="nc"><i>952</i>&nbsp;		tableColumns.setTooltip(new Tooltip(&quot;Show or hide table columns - right-click to change multiple columns at once&quot;));</b>
<i>953</i>&nbsp;		
<b class="nc"><i>954</i>&nbsp;		BorderPane paneColumns = new BorderPane(tableColumns);</b>
<b class="nc"><i>955</i>&nbsp;		paneColumns.setBottom(</b>
<b class="nc"><i>956</i>&nbsp;				PaneTools.createColumnGridControls(</b>
<b class="nc"><i>957</i>&nbsp;						ActionUtils.createButton(actionShowSelected),</b>
<b class="nc"><i>958</i>&nbsp;						ActionUtils.createButton(actionHideSelected)</b>
<i>959</i>&nbsp;						)
<i>960</i>&nbsp;				);
<i>961</i>&nbsp;		
<i>962</i>&nbsp;		
<b class="nc"><i>963</i>&nbsp;		VBox paneRows = new VBox();</b>
<i>964</i>&nbsp;		
<i>965</i>&nbsp;		// Create a box to filter on some metadata text
<b class="nc"><i>966</i>&nbsp;		ComboBox&lt;String&gt; comboMetadata = new ComboBox&lt;&gt;();</b>
<b class="nc"><i>967</i>&nbsp;		comboMetadata.setItems(metadataNames);</b>
<b class="nc"><i>968</i>&nbsp;		comboMetadata.getSelectionModel().getSelectedItem();</b>
<b class="nc"><i>969</i>&nbsp;		comboMetadata.setPromptText(&quot;Select column&quot;);</b>
<b class="nc"><i>970</i>&nbsp;		TextField tfFilter = new TextField();</b>
<b class="nc"><i>971</i>&nbsp;		CheckBox cbExact = new CheckBox(&quot;Exact&quot;);</b>
<i>972</i>&nbsp;		// Set listeners
<b class="nc"><i>973</i>&nbsp;		cbExact.selectedProperty().addListener((v, o, n) -&gt; setMetadataTextPredicate(comboMetadata.getSelectionModel().getSelectedItem(), tfFilter.getText(), cbExact.isSelected(), !cbExact.isSelected()));</b>
<b class="nc"><i>974</i>&nbsp;		tfFilter.textProperty().addListener((v, o, n) -&gt; setMetadataTextPredicate(comboMetadata.getSelectionModel().getSelectedItem(), tfFilter.getText(), cbExact.isSelected(), !cbExact.isSelected()));</b>
<b class="nc"><i>975</i>&nbsp;		comboMetadata.getSelectionModel().selectedItemProperty().addListener((v, o, n) -&gt; setMetadataTextPredicate(comboMetadata.getSelectionModel().getSelectedItem(), tfFilter.getText(), cbExact.isSelected(), !cbExact.isSelected()));</b>
<i>976</i>&nbsp;		
<b class="nc"><i>977</i>&nbsp;		GridPane paneMetadata = new GridPane();</b>
<b class="nc"><i>978</i>&nbsp;		paneMetadata.add(comboMetadata, 0, 0);</b>
<b class="nc"><i>979</i>&nbsp;		paneMetadata.add(tfFilter, 1, 0);</b>
<b class="nc"><i>980</i>&nbsp;		paneMetadata.add(cbExact, 2, 0);</b>
<b class="nc"><i>981</i>&nbsp;		paneMetadata.setPadding(new Insets(10, 10, 10, 10));</b>
<b class="nc"><i>982</i>&nbsp;		paneMetadata.setVgap(2);</b>
<b class="nc"><i>983</i>&nbsp;		paneMetadata.setHgap(5);</b>
<b class="nc"><i>984</i>&nbsp;		comboMetadata.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>985</i>&nbsp;		GridPane.setHgrow(tfFilter, Priority.ALWAYS);</b>
<b class="nc"><i>986</i>&nbsp;		GridPane.setFillWidth(comboMetadata, Boolean.TRUE);</b>
<b class="nc"><i>987</i>&nbsp;		GridPane.setFillWidth(tfFilter, Boolean.TRUE);</b>
<i>988</i>&nbsp;		
<b class="nc"><i>989</i>&nbsp;		TitledPane tpMetadata = new TitledPane(&quot;Metadata filter&quot;, paneMetadata);</b>
<b class="nc"><i>990</i>&nbsp;		tpMetadata.setExpanded(false);</b>
<i>991</i>&nbsp;//		tpMetadata.setCollapsible(false);
<b class="nc"><i>992</i>&nbsp;		Tooltip tooltipMetadata = new Tooltip(&quot;Enter text to filter entries according to a selected metadata column&quot;);</b>
<b class="nc"><i>993</i>&nbsp;		Tooltip.install(paneMetadata, tooltipMetadata);</b>
<b class="nc"><i>994</i>&nbsp;		tpMetadata.setTooltip(tooltipMetadata);</b>
<b class="nc"><i>995</i>&nbsp;		paneRows.getChildren().add(tpMetadata);		</b>
<i>996</i>&nbsp;		
<i>997</i>&nbsp;		
<i>998</i>&nbsp;		// Add measurement predicate
<b class="nc"><i>999</i>&nbsp;		TextField tfCommand = new TextField();</b>
<b class="nc"><i>1000</i>&nbsp;		tfCommand.setTooltip(new Tooltip(&quot;Predicate used to filter entries for inclusion&quot;));</b>
<i>1001</i>&nbsp;		
<b class="nc"><i>1002</i>&nbsp;		TextFields.bindAutoCompletion(tfCommand, e -&gt; {</b>
<b class="nc"><i>1003</i>&nbsp;			int ind = tfCommand.getText().lastIndexOf(&quot;\&quot;&quot;);</b>
<b class="nc"><i>1004</i>&nbsp;			if (ind &lt; 0)</b>
<b class="nc"><i>1005</i>&nbsp;				return Collections.emptyList();</b>
<b class="nc"><i>1006</i>&nbsp;			String part = tfCommand.getText().substring(ind+1);</b>
<b class="nc"><i>1007</i>&nbsp;			return measurementNames.stream().filter(n -&gt; n.startsWith(part)).map(n -&gt; &quot;\&quot;&quot; + n + &quot;\&quot; &quot;).collect(Collectors.toList());</b>
<i>1008</i>&nbsp;		});
<i>1009</i>&nbsp;
<b class="nc"><i>1010</i>&nbsp;		String instructions = &quot;Enter a predicate to filter entries.\n&quot; + </b>
<i>1011</i>&nbsp;				&quot;Only entries passing the test will be included in any results.\n&quot; + 
<i>1012</i>&nbsp;				&quot;Examples of predicates include:\n&quot; + 
<i>1013</i>&nbsp;				&quot;    \&quot;Num Tumor\&quot; &gt; 200\n&quot; + 
<i>1014</i>&nbsp;				&quot;    \&quot;Num Tumor\&quot; &gt; 100 &amp;&amp; \&quot;Num Stroma\&quot; &lt; 1000&quot;;
<i>1015</i>&nbsp;//		labelInstructions.setTooltip(new Tooltip(&quot;Note: measurement names must be in \&quot;inverted commands\&quot; and\n&quot; + 
<i>1016</i>&nbsp;//				&quot;&amp;&amp; indicates &#39;and&#39;, while || indicates &#39;or&#39;.&quot;));
<i>1017</i>&nbsp;
<b class="nc"><i>1018</i>&nbsp;		BorderPane paneMeasurementFilter = new BorderPane(tfCommand);</b>
<b class="nc"><i>1019</i>&nbsp;		Label label = new Label(&quot;Predicate: &quot;);</b>
<b class="nc"><i>1020</i>&nbsp;		label.setAlignment(Pos.CENTER);</b>
<b class="nc"><i>1021</i>&nbsp;		label.setMaxHeight(Double.MAX_VALUE);</b>
<b class="nc"><i>1022</i>&nbsp;		paneMeasurementFilter.setLeft(label);</b>
<i>1023</i>&nbsp;		
<b class="nc"><i>1024</i>&nbsp;		Button btnApply = new Button(&quot;Apply&quot;);</b>
<b class="nc"><i>1025</i>&nbsp;		btnApply.setOnAction(e -&gt; {</b>
<b class="nc"><i>1026</i>&nbsp;			TablePredicate predicateNew = new TablePredicate(tfCommand.getText());</b>
<b class="nc"><i>1027</i>&nbsp;			if (predicateNew.isValid()) {</b>
<b class="nc"><i>1028</i>&nbsp;				predicateMeasurements.set(predicateNew);</b>
<i>1029</i>&nbsp;			} else {
<b class="nc"><i>1030</i>&nbsp;				Dialogs.showErrorMessage(&quot;Invalid predicate&quot;, &quot;Current predicate &#39;&quot; + tfCommand.getText() + &quot;&#39; is invalid!&quot;);</b>
<i>1031</i>&nbsp;			}
<b class="nc"><i>1032</i>&nbsp;			e.consume();</b>
<i>1033</i>&nbsp;		});
<b class="nc"><i>1034</i>&nbsp;		TitledPane tpMeasurementFilter = new TitledPane(&quot;Measurement filter&quot;, paneMeasurementFilter);</b>
<b class="nc"><i>1035</i>&nbsp;		tpMeasurementFilter.setExpanded(false);</b>
<b class="nc"><i>1036</i>&nbsp;		Tooltip tooltipInstructions = new Tooltip(instructions);</b>
<b class="nc"><i>1037</i>&nbsp;		tpMeasurementFilter.setTooltip(tooltipInstructions);</b>
<b class="nc"><i>1038</i>&nbsp;		Tooltip.install(paneMeasurementFilter, tooltipInstructions);</b>
<b class="nc"><i>1039</i>&nbsp;		paneMeasurementFilter.setRight(btnApply);</b>
<i>1040</i>&nbsp;		
<b class="nc"><i>1041</i>&nbsp;		paneRows.getChildren().add(tpMeasurementFilter);</b>
<i>1042</i>&nbsp;		
<b class="nc"><i>1043</i>&nbsp;		logger.info(&quot;Predicate set to: {}&quot;, predicateMeasurements.get());</b>
<i>1044</i>&nbsp;		
<i>1045</i>&nbsp;		
<i>1046</i>&nbsp;		
<i>1047</i>&nbsp;		
<b class="nc"><i>1048</i>&nbsp;		VBox pane = new VBox();</b>
<i>1049</i>&nbsp;//		TitledPane tpColumns = new TitledPane(&quot;Select column&quot;, paneColumns);
<i>1050</i>&nbsp;//		tpColumns.setMaxHeight(Double.MAX_VALUE);
<i>1051</i>&nbsp;//		tpColumns.setCollapsible(false);
<b class="nc"><i>1052</i>&nbsp;		pane.getChildren().addAll(</b>
<i>1053</i>&nbsp;				paneColumns,
<i>1054</i>&nbsp;				new Separator(),
<i>1055</i>&nbsp;				paneRows
<i>1056</i>&nbsp;				);
<b class="nc"><i>1057</i>&nbsp;		VBox.setVgrow(paneColumns, Priority.ALWAYS);</b>
<i>1058</i>&nbsp;
<b class="nc"><i>1059</i>&nbsp;		return pane;</b>
<i>1060</i>&nbsp;	}
<i>1061</i>&nbsp;	
<i>1062</i>&nbsp;	
<i>1063</i>&nbsp;	/**
<i>1064</i>&nbsp;	 * Set a filter based on a (single) metadata column.
<i>1065</i>&nbsp;	 * 
<i>1066</i>&nbsp;	 * @param metadataName
<i>1067</i>&nbsp;	 * @param filterText
<i>1068</i>&nbsp;	 * @param exact
<i>1069</i>&nbsp;	 * @param ignoreCase
<i>1070</i>&nbsp;	 */
<i>1071</i>&nbsp;	private void setMetadataTextPredicate(final String metadataName, final String filterText, final boolean exact, final boolean ignoreCase) {
<b class="nc"><i>1072</i>&nbsp;		if (metadataName == null || filterText == null || metadataName.trim().isEmpty() || filterText.trim().isEmpty()) {</b>
<b class="nc"><i>1073</i>&nbsp;			predicateMetadataFilter.set(null);</b>
<i>1074</i>&nbsp;		} else {
<b class="nc"><i>1075</i>&nbsp;			if (ignoreCase) {</b>
<b class="nc"><i>1076</i>&nbsp;				String filterTextLower = filterText.toLowerCase();</b>
<b class="nc"><i>1077</i>&nbsp;				if (exact)</b>
<b class="nc"><i>1078</i>&nbsp;					predicateMetadataFilter.set(t -&gt; t.getMetadataValue(metadataName) != null &amp;&amp; t.getMetadataValue(metadataName).toLowerCase().equals(filterTextLower));</b>
<i>1079</i>&nbsp;				else
<b class="nc"><i>1080</i>&nbsp;					predicateMetadataFilter.set(t -&gt; t.getMetadataValue(metadataName) != null &amp;&amp; t.getMetadataValue(metadataName).toLowerCase().contains(filterTextLower));</b>
<b class="nc"><i>1081</i>&nbsp;			} else if (exact)</b>
<b class="nc"><i>1082</i>&nbsp;				predicateMetadataFilter.set(t -&gt; t.getMetadataValue(metadataName) != null &amp;&amp; t.getMetadataValue(metadataName).equals(filterText));</b>
<i>1083</i>&nbsp;			else
<b class="nc"><i>1084</i>&nbsp;				predicateMetadataFilter.set(t -&gt; t.getMetadataValue(metadataName) != null &amp;&amp; t.getMetadataValue(metadataName).contains(filterText));</b>
<i>1085</i>&nbsp;		}
<i>1086</i>&nbsp;	}
<i>1087</i>&nbsp;	
<i>1088</i>&nbsp;	
<i>1089</i>&nbsp;	
<i>1090</i>&nbsp;	private Map&lt;String, List&lt;TMAEntry&gt;&gt; createScoresMap(final List&lt;TMAEntry&gt; entries, final String colScore, final String colID) {
<i>1091</i>&nbsp;		// Create a map of entries
<b class="nc"><i>1092</i>&nbsp;		Map&lt;String, List&lt;TMAEntry&gt;&gt; scoreMap = new HashMap&lt;&gt;();</b>
<b class="nc"><i>1093</i>&nbsp;		for (TMAEntry entry : entries) {</b>
<b class="nc"><i>1094</i>&nbsp;			Number score = model.getNumericValue(entry, colScore);</b>
<b class="nc"><i>1095</i>&nbsp;			String id = entry.getMetadataValue(colID);</b>
<b class="nc"><i>1096</i>&nbsp;			if (id == null &amp;&amp; entry.getMeasurement(colID) != null)</b>
<b class="nc"><i>1097</i>&nbsp;				id = Double.toString(entry.getMeasurement(colID).doubleValue());</b>
<b class="nc"><i>1098</i>&nbsp;			if (id != null &amp;&amp; score != null &amp;&amp; !Double.isNaN(score.doubleValue())) {</b>
<b class="nc"><i>1099</i>&nbsp;				List&lt;TMAEntry&gt; list = scoreMap.get(id);</b>
<b class="nc"><i>1100</i>&nbsp;				if (list == null) {</b>
<b class="nc"><i>1101</i>&nbsp;					list = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>1102</i>&nbsp;					scoreMap.put(id, list);</b>
<i>1103</i>&nbsp;				}
<b class="nc"><i>1104</i>&nbsp;				list.add(entry);</b>
<i>1105</i>&nbsp;			}
<b class="nc"><i>1106</i>&nbsp;		}</b>
<b class="nc"><i>1107</i>&nbsp;		return scoreMap;</b>
<i>1108</i>&nbsp;	}
<i>1109</i>&nbsp;	
<i>1110</i>&nbsp;	
<i>1111</i>&nbsp;	private void setTMAEntriesFromOpenImage() {
<b class="nc"><i>1112</i>&nbsp;		QuPathGUI qupath = QuPathGUI.getInstance();</b>
<b class="nc"><i>1113</i>&nbsp;		if (qupath == null || qupath.getImageData() == null || qupath.getImageData().getHierarchy().getTMAGrid() == null) {</b>
<b class="nc"><i>1114</i>&nbsp;			Dialogs.showErrorMessage(&quot;Show TMA summary&quot;, &quot;No TMA data available!&quot;);</b>
<i>1115</i>&nbsp;			return;
<i>1116</i>&nbsp;		}
<b class="nc"><i>1117</i>&nbsp;		ImageData&lt;BufferedImage&gt; imageData = qupath.getImageData();</b>
<b class="nc"><i>1118</i>&nbsp;		setTMAEntriesFromImageData(imageData);</b>
<i>1119</i>&nbsp;	}
<i>1120</i>&nbsp;	
<i>1121</i>&nbsp;	
<i>1122</i>&nbsp;	
<i>1123</i>&nbsp;	private void setTMAEntriesFromOpenProject() {
<b class="nc"><i>1124</i>&nbsp;		QuPathGUI qupath = QuPathGUI.getInstance();</b>
<b class="nc"><i>1125</i>&nbsp;		if (qupath == null || qupath.getProject() == null || qupath.getProject().getImageList().isEmpty()) {</b>
<b class="nc"><i>1126</i>&nbsp;			Dialogs.showNoProjectError(&quot;Show TMA summary&quot;);</b>
<i>1127</i>&nbsp;			return;
<i>1128</i>&nbsp;		}
<b class="nc"><i>1129</i>&nbsp;		Project&lt;BufferedImage&gt; project = qupath.getProject();</b>
<i>1130</i>&nbsp;		
<b class="nc"><i>1131</i>&nbsp;		List&lt;TMAEntry&gt; entries = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>1132</i>&nbsp;		for (ProjectImageEntry&lt;BufferedImage&gt; imageEntry : project.getImageList()) {</b>
<b class="nc"><i>1133</i>&nbsp;			if (imageEntry.hasImageData()) {</b>
<i>1134</i>&nbsp;				try {
<b class="nc"><i>1135</i>&nbsp;					ImageData&lt;BufferedImage&gt; imageData = imageEntry.readImageData();</b>
<b class="nc"><i>1136</i>&nbsp;					entries.addAll(getEntriesForTMAData(imageData));</b>
<b class="nc"><i>1137</i>&nbsp;				} catch (IOException e) {</b>
<b class="nc"><i>1138</i>&nbsp;					logger.error(&quot;Unable to read ImageData for {} ({})&quot;, imageEntry.getImageName(), e.getLocalizedMessage());</b>
<b class="nc"><i>1139</i>&nbsp;				}</b>
<i>1140</i>&nbsp;			}
<b class="nc"><i>1141</i>&nbsp;		}</b>
<b class="nc"><i>1142</i>&nbsp;		setTMAEntries(entries);</b>
<b class="nc"><i>1143</i>&nbsp;		stage.setTitle(&quot;TMA Viewer: &quot; + project.getName());</b>
<i>1144</i>&nbsp;	}
<i>1145</i>&nbsp;	
<i>1146</i>&nbsp;	
<i>1147</i>&nbsp;	
<i>1148</i>&nbsp;	private static List&lt;TMAEntry&gt; getEntriesForTMAData(final ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>1149</i>&nbsp;		List&lt;TMAEntry&gt; entriesNew = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>1150</i>&nbsp;		if (imageData.getHierarchy().getTMAGrid() == null)</b>
<b class="nc"><i>1151</i>&nbsp;			return entriesNew;</b>
<b class="nc"><i>1152</i>&nbsp;		ObservableMeasurementTableData data = new ObservableMeasurementTableData();</b>
<b class="nc"><i>1153</i>&nbsp;		data.setImageData(imageData, imageData.getHierarchy().getTMAGrid().getTMACoreList());</b>
<b class="nc"><i>1154</i>&nbsp;		for (TMACoreObject core : imageData.getHierarchy().getTMAGrid().getTMACoreList()) {</b>
<b class="nc"><i>1155</i>&nbsp;			entriesNew.add(TMAEntries.createTMAObjectEntry(imageData, data, core));</b>
<b class="nc"><i>1156</i>&nbsp;		}</b>
<b class="nc"><i>1157</i>&nbsp;		return entriesNew;</b>
<i>1158</i>&nbsp;	}
<i>1159</i>&nbsp;	
<i>1160</i>&nbsp;	
<i>1161</i>&nbsp;	/**
<i>1162</i>&nbsp;	 * Set the TMA entries from the TMACoreObjects of a specific ImageData.
<i>1163</i>&nbsp;	 * 
<i>1164</i>&nbsp;	 * @param imageData
<i>1165</i>&nbsp;	 */
<i>1166</i>&nbsp;	public void setTMAEntriesFromImageData(final ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>1167</i>&nbsp;		setTMAEntries(getEntriesForTMAData(imageData));</b>
<b class="nc"><i>1168</i>&nbsp;		stage.setTitle(&quot;TMA Viewer: &quot; + ServerTools.getDisplayableImageName(imageData.getServer()));</b>
<i>1169</i>&nbsp;	}
<i>1170</i>&nbsp;	
<i>1171</i>&nbsp;
<i>1172</i>&nbsp;	/**
<i>1173</i>&nbsp;	 * Set the input file for the summary viewer.
<i>1174</i>&nbsp;	 * @param file
<i>1175</i>&nbsp;	 */
<i>1176</i>&nbsp;	public void setInputFile(File file) {
<b class="nc"><i>1177</i>&nbsp;		if (file == null)</b>
<i>1178</i>&nbsp;			return;
<i>1179</i>&nbsp;		
<b class="nc"><i>1180</i>&nbsp;		if (file.getName().toLowerCase().endsWith(PathPrefs.getSerializationExtension())) {</b>
<i>1181</i>&nbsp;			try {
<b class="nc"><i>1182</i>&nbsp;				ImageData&lt;BufferedImage&gt; imageData = PathIO.readImageData(file, null, null, BufferedImage.class);</b>
<b class="nc"><i>1183</i>&nbsp;				setTMAEntriesFromImageData(imageData);</b>
<b class="nc"><i>1184</i>&nbsp;			} catch (IOException e) {</b>
<b class="nc"><i>1185</i>&nbsp;				logger.error(&quot;Error reading image data&quot;, e);</b>
<b class="nc"><i>1186</i>&nbsp;			}</b>
<i>1187</i>&nbsp;			return;
<i>1188</i>&nbsp;		}
<i>1189</i>&nbsp;
<b class="nc"><i>1190</i>&nbsp;		List&lt;TMAEntry&gt; entriesTemp = new ArrayList&lt;&gt;();</b>
<i>1191</i>&nbsp;
<b class="nc"><i>1192</i>&nbsp;		File dir = file.isDirectory() ? file : file.getParentFile();</b>
<i>1193</i>&nbsp;
<b class="nc"><i>1194</i>&nbsp;		for (File fileInput : dir.listFiles()) {</b>
<b class="nc"><i>1195</i>&nbsp;			if (fileInput.isHidden() || fileInput.isDirectory() || !fileInput.getName().toLowerCase().endsWith(&quot;.qptma&quot;))</b>
<b class="nc"><i>1196</i>&nbsp;				continue;</b>
<b class="nc"><i>1197</i>&nbsp;			parseInputFile(fileInput, entriesTemp);</b>
<i>1198</i>&nbsp;		}
<i>1199</i>&nbsp;
<b class="nc"><i>1200</i>&nbsp;		if (entriesTemp.isEmpty()) {</b>
<b class="nc"><i>1201</i>&nbsp;			logger.error(&quot;No data found for &quot; + file.getAbsolutePath());</b>
<i>1202</i>&nbsp;			return;
<i>1203</i>&nbsp;		}
<i>1204</i>&nbsp;		
<b class="nc"><i>1205</i>&nbsp;		setTMAEntries(entriesTemp);</b>
<b class="nc"><i>1206</i>&nbsp;		stage.setTitle(&quot;TMA Results View: &quot; + dir.getName());</b>
<i>1207</i>&nbsp;
<i>1208</i>&nbsp;	}
<i>1209</i>&nbsp;	
<i>1210</i>&nbsp;	
<i>1211</i>&nbsp;	void setTMAEntries(final Collection&lt;TMAEntry&gt; newEntries) {
<i>1212</i>&nbsp;		
<i>1213</i>&nbsp;//		boolean containsSummaries = newEntries.stream().anyMatch(e -&gt; e instanceof TMASummaryEntry);
<i>1214</i>&nbsp;		
<i>1215</i>&nbsp;		// Turn off use-selected - can be crashy when replacing entries
<b class="nc"><i>1216</i>&nbsp;		if (!newEntries.equals(entriesBase)) {</b>
<b class="nc"><i>1217</i>&nbsp;			useSelectedProperty.set(false);</b>
<i>1218</i>&nbsp;			
<i>1219</i>&nbsp;			// Reset the cache
<b class="nc"><i>1220</i>&nbsp;			imageCache.clear();</b>
<i>1221</i>&nbsp;			
<i>1222</i>&nbsp;			// Try to load small images in a background thread
<b class="nc"><i>1223</i>&nbsp;			List&lt;TMAEntry&gt; duplicateEntries = new ArrayList&lt;&gt;(newEntries);</b>
<b class="nc"><i>1224</i>&nbsp;			ExecutorService service = Executors.newSingleThreadExecutor();</b>
<b class="nc"><i>1225</i>&nbsp;			service.submit(() -&gt; {</b>
<b class="nc"><i>1226</i>&nbsp;				duplicateEntries.parallelStream().forEach(entry -&gt; {</b>
<b class="nc"><i>1227</i>&nbsp;					imageCache.getImage(entry, maxSmallWidth.get());</b>
<b class="nc"><i>1228</i>&nbsp;					imageCache.getOverlay(entry, maxSmallWidth.get());</b>
<i>1229</i>&nbsp;				});
<i>1230</i>&nbsp;			});
<b class="nc"><i>1231</i>&nbsp;			service.shutdown();</b>
<i>1232</i>&nbsp;			
<i>1233</i>&nbsp;		}
<b class="nc"><i>1234</i>&nbsp;		this.entriesBase.setAll(newEntries);</b>
<i>1235</i>&nbsp;		
<i>1236</i>&nbsp;		// Store the names of any currently hidden columns
<b class="nc"><i>1237</i>&nbsp;		lastHiddenColumns = table.getColumns().stream().filter(c -&gt; !c.isVisible()).map(c -&gt; c.getText()).collect(Collectors.toSet());</b>
<i>1238</i>&nbsp;		
<i>1239</i>&nbsp;//		this.table.getColumns().clear();
<i>1240</i>&nbsp;		
<i>1241</i>&nbsp;//		// Useful for a paper, but not generally...
<i>1242</i>&nbsp;//		int count = 0;
<i>1243</i>&nbsp;//		int nCells = 0;
<i>1244</i>&nbsp;//		int nTumor = 0;
<i>1245</i>&nbsp;//		for (TMAEntry entry : entriesBase) {
<i>1246</i>&nbsp;//			if (!entry.isMissing() &amp;&amp; (predicate.get() == null || predicate.get().test(entry))) {
<i>1247</i>&nbsp;//				count++;
<i>1248</i>&nbsp;//				nCells += (int)(entry.getMeasurement(&quot;Num Tumor&quot;).doubleValue() + entry.getMeasurement(&quot;Num Stroma&quot;).doubleValue());
<i>1249</i>&nbsp;//				nTumor += (int)(entry.getMeasurement(&quot;Num Tumor&quot;).doubleValue());
<i>1250</i>&nbsp;//			}
<i>1251</i>&nbsp;//		}
<i>1252</i>&nbsp;//		System.err.println(String.format(&quot;Num entries:\t%d\tNum tumor:\t%d\tNum cells:\t%d&quot;, count, nTumor, nCells));
<i>1253</i>&nbsp;		
<i>1254</i>&nbsp;		
<i>1255</i>&nbsp;		// Update measurement names
<b class="nc"><i>1256</i>&nbsp;		Set&lt;String&gt; namesMeasurements = new LinkedHashSet&lt;&gt;();</b>
<b class="nc"><i>1257</i>&nbsp;		Set&lt;String&gt; namesMetadata = new LinkedHashSet&lt;&gt;();</b>
<i>1258</i>&nbsp;//		boolean containsSummaries = false;
<b class="nc"><i>1259</i>&nbsp;		for (TMAEntry entry : newEntries) {</b>
<b class="nc"><i>1260</i>&nbsp;			namesMeasurements.addAll(entry.getMeasurementNames());</b>
<b class="nc"><i>1261</i>&nbsp;			namesMetadata.addAll(entry.getMetadataNames());</b>
<i>1262</i>&nbsp;//			containsSummaries = containsSummaries || entry instanceof TMASummaryEntry;
<b class="nc"><i>1263</i>&nbsp;		}</b>
<i>1264</i>&nbsp;		
<i>1265</i>&nbsp;		// Get the available survival columns
<b class="nc"><i>1266</i>&nbsp;		String currentSurvival = getSurvivalColumn();</b>
<b class="nc"><i>1267</i>&nbsp;		survivalColumns.clear();</b>
<b class="nc"><i>1268</i>&nbsp;		if (namesMeasurements.contains(TMACoreObject.KEY_OVERALL_SURVIVAL))</b>
<b class="nc"><i>1269</i>&nbsp;			survivalColumns.add(TMACoreObject.KEY_OVERALL_SURVIVAL);</b>
<b class="nc"><i>1270</i>&nbsp;		if (namesMeasurements.contains(TMACoreObject.KEY_RECURRENCE_FREE_SURVIVAL))</b>
<b class="nc"><i>1271</i>&nbsp;			survivalColumns.add(TMACoreObject.KEY_RECURRENCE_FREE_SURVIVAL);</b>
<b class="nc"><i>1272</i>&nbsp;		if (currentSurvival != null &amp;&amp; survivalColumns.contains(currentSurvival))</b>
<b class="nc"><i>1273</i>&nbsp;			comboSurvival.getSelectionModel().select(currentSurvival);</b>
<b class="nc"><i>1274</i>&nbsp;		else if (!survivalColumns.isEmpty())</b>
<b class="nc"><i>1275</i>&nbsp;			comboSurvival.getSelectionModel().select(survivalColumns.get(0));</b>
<i>1276</i>&nbsp;		
<i>1277</i>&nbsp;//		// Add the count of non-missing cores if we are working with summaries
<i>1278</i>&nbsp;//		if (containsSummaries)
<b class="nc"><i>1279</i>&nbsp;			namesMeasurements.add(&quot;Available cores&quot;);</b>
<i>1280</i>&nbsp;		
<i>1281</i>&nbsp;		// Make sure there are no nulls or other unusable values
<b class="nc"><i>1282</i>&nbsp;		namesMeasurements.remove(null);</b>
<b class="nc"><i>1283</i>&nbsp;		namesMeasurements.remove(&quot;&quot;);</b>
<i>1284</i>&nbsp;//		measurementNames.clear();
<b class="nc"><i>1285</i>&nbsp;		String selectedMainMeasurement = comboMainMeasurement.getSelectionModel().getSelectedItem();</b>
<b class="nc"><i>1286</i>&nbsp;		measurementNames.setAll(namesMeasurements);</b>
<b class="nc"><i>1287</i>&nbsp;		if (namesMeasurements.contains(selectedMainMeasurement))</b>
<b class="nc"><i>1288</i>&nbsp;			comboMainMeasurement.getSelectionModel().select(selectedMainMeasurement);</b>
<i>1289</i>&nbsp;		else {
<b class="nc"><i>1290</i>&nbsp;			namesMeasurements.remove(TMACoreObject.KEY_UNIQUE_ID);</b>
<b class="nc"><i>1291</i>&nbsp;			namesMeasurements.remove(TMACoreObject.KEY_OVERALL_SURVIVAL);</b>
<b class="nc"><i>1292</i>&nbsp;			namesMeasurements.remove(TMACoreObject.KEY_RECURRENCE_FREE_SURVIVAL);</b>
<b class="nc"><i>1293</i>&nbsp;			namesMeasurements.remove(TMACoreObject.KEY_OS_CENSORED);</b>
<b class="nc"><i>1294</i>&nbsp;			namesMeasurements.remove(TMACoreObject.KEY_RFS_CENSORED);</b>
<b class="nc"><i>1295</i>&nbsp;			namesMeasurements.remove(&quot;Censored&quot;); // For historical reasons when there was only one censored column supported...</b>
<b class="nc"><i>1296</i>&nbsp;			if (!namesMeasurements.isEmpty())</b>
<b class="nc"><i>1297</i>&nbsp;				comboMainMeasurement.getSelectionModel().select(0);</b>
<i>1298</i>&nbsp;		}
<b class="nc"><i>1299</i>&nbsp;		metadataNames.clear();</b>
<b class="nc"><i>1300</i>&nbsp;		metadataNames.addAll(namesMetadata);</b>
<i>1301</i>&nbsp;		
<i>1302</i>&nbsp;		
<b class="nc"><i>1303</i>&nbsp;		refreshTableData();</b>
<i>1304</i>&nbsp;		
<i>1305</i>&nbsp;		// The next time the table is empty, show a different placeholder 
<i>1306</i>&nbsp;		// from the original (which is for loading/import)
<b class="nc"><i>1307</i>&nbsp;		table.setPlaceholder(new Text(&quot;No data&quot;));</b>
<i>1308</i>&nbsp;	}
<i>1309</i>&nbsp;
<i>1310</i>&nbsp;	
<i>1311</i>&nbsp;	
<i>1312</i>&nbsp;	
<i>1313</i>&nbsp;	private void refreshTableData() {
<i>1314</i>&nbsp;		
<i>1315</i>&nbsp;//		int nn = 0;
<i>1316</i>&nbsp;//		double nPositive = 0;
<i>1317</i>&nbsp;//		for (TMAEntry entry : entriesBase) {
<i>1318</i>&nbsp;//			if (entry.isMissing())
<i>1319</i>&nbsp;//				continue;
<i>1320</i>&nbsp;//			nPositive += entry.getMeasurementAsDouble(&quot;Num Positive&quot;);
<i>1321</i>&nbsp;//			nn++;
<i>1322</i>&nbsp;//		}
<i>1323</i>&nbsp;//		System.err.println(nPositive + &quot; positive cells across &quot; + nn + &quot; tissue samples&quot;);
<i>1324</i>&nbsp;		
<b class="nc"><i>1325</i>&nbsp;		Collection&lt;? extends TMAEntry&gt; entries = groupByIDProperty.get() ? createSummaryEntries(entriesBase) : entriesBase;</b>
<i>1326</i>&nbsp;
<i>1327</i>&nbsp;		// Ensure that we don&#39;t try to modify a filtered list
<b class="nc"><i>1328</i>&nbsp;		List&lt;TreeTableColumn&lt;TMAEntry, ?&gt;&gt; columns = new ArrayList&lt;&gt;();</b>
<i>1329</i>&nbsp;
<i>1330</i>&nbsp;		// Add an empty column.
<i>1331</i>&nbsp;		// Its purpose is to provide the space needed for the little expansion arrows, to avoid 
<i>1332</i>&nbsp;		// these stealing space from the first interesting column.
<i>1333</i>&nbsp;		// Note: there&#39;s nothing to prevent the user reordering it along with other columns... 
<i>1334</i>&nbsp;		// but hopefully it looks &#39;right&#39; enough where it is that few would try to do that
<b class="nc"><i>1335</i>&nbsp;		TreeTableColumn&lt;TMAEntry, String&gt; columnEmpty = new TreeTableColumn&lt;&gt;(&quot;  &quot;);</b>
<b class="nc"><i>1336</i>&nbsp;		columnEmpty.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;TMAEntry, String&gt;, ObservableValue&lt;String&gt;&gt;() {</b>
<i>1337</i>&nbsp;			@Override
<i>1338</i>&nbsp;			public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;TMAEntry, String&gt; p) {
<b class="nc"><i>1339</i>&nbsp;				return Bindings.createStringBinding(() -&gt; &quot;&quot;);</b>
<i>1340</i>&nbsp;			}
<i>1341</i>&nbsp;		});
<b class="nc"><i>1342</i>&nbsp;		columnEmpty.setSortable(false);</b>
<b class="nc"><i>1343</i>&nbsp;		columnEmpty.setResizable(false);</b>
<b class="nc"><i>1344</i>&nbsp;		columns.add(columnEmpty);</b>
<i>1345</i>&nbsp;
<i>1346</i>&nbsp;		// Check if we have any images or overlays
<b class="nc"><i>1347</i>&nbsp;		boolean hasImages = entries.stream().anyMatch(e -&gt; e.hasImage());</b>
<b class="nc"><i>1348</i>&nbsp;		boolean hasOverlay = entries.stream().anyMatch(e -&gt; e.hasOverlay());</b>
<i>1349</i>&nbsp;
<i>1350</i>&nbsp;		// Add columns to show images, if we have them
<b class="nc"><i>1351</i>&nbsp;		if (hasImages || hasOverlay) {</b>
<b class="nc"><i>1352</i>&nbsp;			TreeTableColumn&lt;TMAEntry, TMAEntry&gt; columnImage = hasImages ? new TreeTableColumn&lt;&gt;(&quot;Thumbnail&quot;) : null;</b>
<b class="nc"><i>1353</i>&nbsp;			TreeTableColumn&lt;TMAEntry, TMAEntry&gt; columnOverlay = hasOverlay ? new TreeTableColumn&lt;&gt;(&quot;Overlay&quot;) : null;</b>
<i>1354</i>&nbsp;
<b class="nc"><i>1355</i>&nbsp;			if (hasImages) {</b>
<b class="nc"><i>1356</i>&nbsp;				columnImage.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;TMAEntry, TMAEntry&gt;, ObservableValue&lt;TMAEntry&gt;&gt;() {</b>
<i>1357</i>&nbsp;					@Override
<i>1358</i>&nbsp;					public ObservableValue&lt;TMAEntry&gt; call(CellDataFeatures&lt;TMAEntry, TMAEntry&gt; p) {
<b class="nc"><i>1359</i>&nbsp;						return p.getValue().valueProperty();</b>
<i>1360</i>&nbsp;					}
<i>1361</i>&nbsp;				});
<b class="nc"><i>1362</i>&nbsp;				columnImage.setCellFactory(c -&gt; new ImageTableCell(imageCache, false));</b>
<b class="nc"><i>1363</i>&nbsp;				columnImage.maxWidthProperty().bind(maxSmallWidth);</b>
<b class="nc"><i>1364</i>&nbsp;				columnImage.widthProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>1365</i>&nbsp;					if (n.doubleValue() == columnImage.getPrefWidth())</b>
<i>1366</i>&nbsp;						return;
<b class="nc"><i>1367</i>&nbsp;					if (hasOverlay)</b>
<b class="nc"><i>1368</i>&nbsp;						columnOverlay.setPrefWidth(n.doubleValue());</b>
<b class="nc"><i>1369</i>&nbsp;					table.refresh();</b>
<i>1370</i>&nbsp;				});
<b class="nc"><i>1371</i>&nbsp;				columns.add(columnImage);</b>
<i>1372</i>&nbsp;			}
<i>1373</i>&nbsp;
<b class="nc"><i>1374</i>&nbsp;			if (hasOverlay) {</b>
<b class="nc"><i>1375</i>&nbsp;				columnOverlay.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;TMAEntry, TMAEntry&gt;, ObservableValue&lt;TMAEntry&gt;&gt;() {</b>
<i>1376</i>&nbsp;					@Override
<i>1377</i>&nbsp;					public ObservableValue&lt;TMAEntry&gt; call(CellDataFeatures&lt;TMAEntry, TMAEntry&gt; p) {
<b class="nc"><i>1378</i>&nbsp;						return p.getValue().valueProperty();</b>
<i>1379</i>&nbsp;					}
<i>1380</i>&nbsp;				});
<b class="nc"><i>1381</i>&nbsp;				columnOverlay.setCellFactory(c -&gt; new ImageTableCell(imageCache, true));</b>
<b class="nc"><i>1382</i>&nbsp;				columnOverlay.maxWidthProperty().bind(maxSmallWidth);</b>
<b class="nc"><i>1383</i>&nbsp;				columnOverlay.widthProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>1384</i>&nbsp;					if (n.doubleValue() == columnOverlay.getPrefWidth())</b>
<i>1385</i>&nbsp;						return;
<b class="nc"><i>1386</i>&nbsp;					columnImage.setPrefWidth(n.doubleValue());</b>
<b class="nc"><i>1387</i>&nbsp;					if (hasImages)</b>
<b class="nc"><i>1388</i>&nbsp;						table.refresh();</b>
<i>1389</i>&nbsp;				});
<b class="nc"><i>1390</i>&nbsp;				columns.add(columnOverlay);</b>
<i>1391</i>&nbsp;			}
<i>1392</i>&nbsp;		}
<i>1393</i>&nbsp;
<i>1394</i>&nbsp;
<i>1395</i>&nbsp;		// Update image availability
<b class="nc"><i>1396</i>&nbsp;		if (hasImages) {</b>
<b class="nc"><i>1397</i>&nbsp;			if (hasOverlay)</b>
<b class="nc"><i>1398</i>&nbsp;				imageAvailability.set(ImageAvailability.BOTH);</b>
<i>1399</i>&nbsp;			else
<b class="nc"><i>1400</i>&nbsp;				imageAvailability.set(ImageAvailability.IMAGE_ONLY);</b>
<b class="nc"><i>1401</i>&nbsp;		} else if (hasOverlay) {</b>
<b class="nc"><i>1402</i>&nbsp;			imageAvailability.set(ImageAvailability.OVERLAY_ONLY);</b>
<i>1403</i>&nbsp;		} else
<b class="nc"><i>1404</i>&nbsp;			imageAvailability.set(ImageAvailability.NONE);</b>
<i>1405</i>&nbsp;
<i>1406</i>&nbsp;
<i>1407</i>&nbsp;
<b class="nc"><i>1408</i>&nbsp;		for (String name : model.getAllNames()) {</b>
<b class="nc"><i>1409</i>&nbsp;			if (model.getMeasurementNames().contains(name)) {</b>
<b class="nc"><i>1410</i>&nbsp;				TreeTableColumn&lt;TMAEntry, Number&gt; column = new TreeTableColumn&lt;&gt;(name);</b>
<b class="nc"><i>1411</i>&nbsp;				column.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;TMAEntry, Number&gt;, ObservableValue&lt;Number&gt;&gt;() {</b>
<i>1412</i>&nbsp;					@Override
<i>1413</i>&nbsp;					public ObservableValue&lt;Number&gt; call(CellDataFeatures&lt;TMAEntry, Number&gt; p) {
<b class="nc"><i>1414</i>&nbsp;						double value = p.getValue() == null ? Double.NaN : model.getNumericValue(p.getValue().getValue(), name);</b>
<b class="nc"><i>1415</i>&nbsp;						return new SimpleDoubleProperty(value);</b>
<i>1416</i>&nbsp;					}
<i>1417</i>&nbsp;				});
<b class="nc"><i>1418</i>&nbsp;				column.setCellFactory(c -&gt; new NumericTreeTableCell&lt;&gt;());</b>
<b class="nc"><i>1419</i>&nbsp;				columns.add(column);</b>
<b class="nc"><i>1420</i>&nbsp;			} else {</b>
<b class="nc"><i>1421</i>&nbsp;				TreeTableColumn&lt;TMAEntry, Object&gt; column = new TreeTableColumn&lt;&gt;(name);</b>
<b class="nc"><i>1422</i>&nbsp;				column.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;TMAEntry, Object&gt;, ObservableValue&lt;Object&gt;&gt;() {</b>
<i>1423</i>&nbsp;					@Override
<i>1424</i>&nbsp;					public ObservableValue&lt;Object&gt; call(CellDataFeatures&lt;TMAEntry, Object&gt; p) {
<b class="nc"><i>1425</i>&nbsp;						return new SimpleObjectProperty&lt;&gt;(p.getValue() == null ? null : model.getStringValue(p.getValue().getValue(), name));</b>
<i>1426</i>&nbsp;					}
<i>1427</i>&nbsp;				});
<b class="nc"><i>1428</i>&nbsp;				column.setCellFactory(c -&gt; new CenteredTreeTableCell&lt;&gt;());</b>
<b class="nc"><i>1429</i>&nbsp;				columns.add(column);</b>
<i>1430</i>&nbsp;			}
<b class="nc"><i>1431</i>&nbsp;		}</b>
<i>1432</i>&nbsp;		
<i>1433</i>&nbsp;		// Set the column visibility depending upon whether they were hidden previously
<b class="nc"><i>1434</i>&nbsp;		columns.stream().forEach(c -&gt; c.setVisible(!lastHiddenColumns.contains(c.getText())));</b>
<i>1435</i>&nbsp;		
<i>1436</i>&nbsp;		// Set columns for table
<b class="nc"><i>1437</i>&nbsp;		table.getColumns().setAll(columns);</b>
<i>1438</i>&nbsp;		
<i>1439</i>&nbsp;		// Set new root for table
<b class="nc"><i>1440</i>&nbsp;		TreeItem&lt;TMAEntry&gt; root = new RootTreeItem(entries, combinedPredicate);</b>
<b class="nc"><i>1441</i>&nbsp;		table.setShowRoot(false);</b>
<b class="nc"><i>1442</i>&nbsp;		table.setRoot(root);</b>
<i>1443</i>&nbsp;		
<b class="nc"><i>1444</i>&nbsp;		model.refreshList();</b>
<i>1445</i>&nbsp;	}
<i>1446</i>&nbsp;	
<i>1447</i>&nbsp;	
<i>1448</i>&nbsp;	
<i>1449</i>&nbsp;	static class RootTreeItem extends TreeItem&lt;TMAEntry&gt; implements ChangeListener&lt;Predicate&lt;TMAEntry&gt;&gt; {
<i>1450</i>&nbsp;		
<b class="nc"><i>1451</i>&nbsp;		private List&lt;TreeItem&lt;TMAEntry&gt;&gt; entries = new ArrayList&lt;&gt;();</b>
<i>1452</i>&nbsp;		private ObservableValue&lt;Predicate&lt;TMAEntry&gt;&gt; combinedPredicate;
<i>1453</i>&nbsp;		
<i>1454</i>&nbsp;		RootTreeItem(final Collection&lt;? extends TMAEntry&gt; entries, final ObservableValue&lt;Predicate&lt;TMAEntry&gt;&gt; combinedPredicate) {
<b class="nc"><i>1455</i>&nbsp;			super(null);</b>
<b class="nc"><i>1456</i>&nbsp;			for (TMAEntry entry : entries) {</b>
<b class="nc"><i>1457</i>&nbsp;				if (entry instanceof TMASummaryEntry)</b>
<b class="nc"><i>1458</i>&nbsp;					this.entries.add(new SummaryTreeItem((TMASummaryEntry)entry));</b>
<i>1459</i>&nbsp;				else
<b class="nc"><i>1460</i>&nbsp;					this.entries.add(new TreeItem&lt;&gt;(entry));					</b>
<b class="nc"><i>1461</i>&nbsp;			}</b>
<b class="nc"><i>1462</i>&nbsp;			this.combinedPredicate = combinedPredicate;</b>
<b class="nc"><i>1463</i>&nbsp;			this.combinedPredicate.addListener(new WeakChangeListener&lt;&gt;(this));</b>
<b class="nc"><i>1464</i>&nbsp;			updateChildren();</b>
<i>1465</i>&nbsp;		}
<i>1466</i>&nbsp;		
<i>1467</i>&nbsp;		private void updateChildren() {
<b class="nc"><i>1468</i>&nbsp;			ArrayList&lt;TreeItem&lt;TMAEntry&gt;&gt; children = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>1469</i>&nbsp;			for (TreeItem&lt;TMAEntry&gt; entry : entries) {</b>
<b class="nc"><i>1470</i>&nbsp;				if (entry instanceof SummaryTreeItem) {</b>
<b class="nc"><i>1471</i>&nbsp;					SummaryTreeItem summaryItem = (SummaryTreeItem)entry;</b>
<b class="nc"><i>1472</i>&nbsp;					summaryItem.updateChildren();</b>
<b class="nc"><i>1473</i>&nbsp;					if (!summaryItem.getChildren().isEmpty())</b>
<b class="nc"><i>1474</i>&nbsp;						children.add(summaryItem);</b>
<b class="nc"><i>1475</i>&nbsp;				} else if (combinedPredicate.getValue().test(entry.getValue()))</b>
<b class="nc"><i>1476</i>&nbsp;					children.add(entry);</b>
<b class="nc"><i>1477</i>&nbsp;			}</b>
<b class="nc"><i>1478</i>&nbsp;			super.getChildren().setAll(children);</b>
<i>1479</i>&nbsp;		}
<i>1480</i>&nbsp;
<i>1481</i>&nbsp;		@Override
<i>1482</i>&nbsp;		public void changed(ObservableValue&lt;? extends Predicate&lt;TMAEntry&gt;&gt; observable,
<i>1483</i>&nbsp;				Predicate&lt;TMAEntry&gt; oldValue, Predicate&lt;TMAEntry&gt; newValue) {
<b class="nc"><i>1484</i>&nbsp;			updateChildren();</b>
<i>1485</i>&nbsp;		}
<i>1486</i>&nbsp;		
<i>1487</i>&nbsp;	}
<i>1488</i>&nbsp;	
<i>1489</i>&nbsp;	static class SummaryTreeItem extends TreeItem&lt;TMAEntry&gt; {
<i>1490</i>&nbsp;		
<i>1491</i>&nbsp;		private TMASummaryEntry entry;
<i>1492</i>&nbsp;		
<i>1493</i>&nbsp;		SummaryTreeItem(final TMASummaryEntry entry) {
<b class="nc"><i>1494</i>&nbsp;			super(entry);</b>
<b class="nc"><i>1495</i>&nbsp;			this.entry = entry;</b>
<b class="nc"><i>1496</i>&nbsp;			updateChildren();</b>
<i>1497</i>&nbsp;		}
<i>1498</i>&nbsp;		
<i>1499</i>&nbsp;		private void updateChildren() {
<b class="nc"><i>1500</i>&nbsp;			ArrayList&lt;TreeItem&lt;TMAEntry&gt;&gt; children = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>1501</i>&nbsp;			for (TMAEntry subEntry : entry.getEntries())</b>
<b class="nc"><i>1502</i>&nbsp;				children.add(new TreeItem&lt;&gt;(subEntry));</b>
<b class="nc"><i>1503</i>&nbsp;			super.getChildren().setAll(children);</b>
<i>1504</i>&nbsp;		}
<i>1505</i>&nbsp;		
<i>1506</i>&nbsp;	}
<i>1507</i>&nbsp;	
<i>1508</i>&nbsp;//	class SummaryTreeItem extends TreeItem&lt;TMAEntry&gt; implements ChangeListener&lt;Predicate&lt;? super TMAEntry&gt;&gt; {
<i>1509</i>&nbsp;//		
<i>1510</i>&nbsp;//		private TMASummaryEntry entry;
<i>1511</i>&nbsp;//		
<i>1512</i>&nbsp;//		SummaryTreeItem(final TMASummaryEntry entry) {
<i>1513</i>&nbsp;//			super(entry);
<i>1514</i>&nbsp;//			this.entry = entry;
<i>1515</i>&nbsp;//			combinedPredicate.addListener(new WeakChangeListener&lt;Predicate&lt;? super TMAEntry&gt;&gt;(this));
<i>1516</i>&nbsp;//			updateChildren();
<i>1517</i>&nbsp;//		}
<i>1518</i>&nbsp;//		
<i>1519</i>&nbsp;//		private void updateChildren() {
<i>1520</i>&nbsp;//			ArrayList&lt;TreeItem&lt;TMAEntry&gt;&gt; children = new ArrayList&lt;&gt;();
<i>1521</i>&nbsp;//			for (TMAEntry subEntry : entry.getEntries())
<i>1522</i>&nbsp;//				children.add(new TreeItem&lt;&gt;(subEntry));
<i>1523</i>&nbsp;//			super.getChildren().setAll(children);
<i>1524</i>&nbsp;//		}
<i>1525</i>&nbsp;//
<i>1526</i>&nbsp;//		@Override
<i>1527</i>&nbsp;//		public void changed(ObservableValue&lt;? extends Predicate&lt;? super TMAEntry&gt;&gt; observable,
<i>1528</i>&nbsp;//				Predicate&lt;? super TMAEntry&gt; oldValue, Predicate&lt;? super TMAEntry&gt; newValue) {
<i>1529</i>&nbsp;//			updateChildren();
<i>1530</i>&nbsp;//		}
<i>1531</i>&nbsp;//		
<i>1532</i>&nbsp;//	}
<i>1533</i>&nbsp;	
<i>1534</i>&nbsp;	
<i>1535</i>&nbsp;	
<i>1536</i>&nbsp;	/**
<i>1537</i>&nbsp;	 * Create summaries entries by grouping according to Unique ID.
<i>1538</i>&nbsp;	 * 
<i>1539</i>&nbsp;	 * @param entries
<i>1540</i>&nbsp;	 * @return
<i>1541</i>&nbsp;	 */
<i>1542</i>&nbsp;	private Collection&lt;? extends TMAEntry&gt; createSummaryEntries(final List&lt;? extends TMAEntry&gt; entries) {
<b class="nc"><i>1543</i>&nbsp;		Map&lt;String, TMASummaryEntry&gt; summaryEntryMap = new TreeMap&lt;&gt;();</b>
<b class="nc"><i>1544</i>&nbsp;		int maxSummaryLength = 0;</b>
<b class="nc"><i>1545</i>&nbsp;		for (TMAEntry entry : entries) {</b>
<b class="nc"><i>1546</i>&nbsp;			String id = entry.getMetadataValue(TMACoreObject.KEY_UNIQUE_ID);</b>
<b class="nc"><i>1547</i>&nbsp;			if (id == null &amp;&amp; entry.getMeasurement(TMACoreObject.KEY_UNIQUE_ID) != null)</b>
<b class="nc"><i>1548</i>&nbsp;				id = entry.getMeasurement(TMACoreObject.KEY_UNIQUE_ID).toString();</b>
<b class="nc"><i>1549</i>&nbsp;			if (id == null || id.trim().length() == 0) {</b>
<b class="nc"><i>1550</i>&nbsp;				if (!&quot;True&quot;.equals(entry.getMetadataValue(MISSING_COLUMN)))</b>
<b class="nc"><i>1551</i>&nbsp;					logger.trace(&quot;No ID found for {}&quot;, entry);</b>
<i>1552</i>&nbsp;				continue;
<i>1553</i>&nbsp;			}
<b class="nc"><i>1554</i>&nbsp;			TMASummaryEntry summary = summaryEntryMap.get(id);</b>
<b class="nc"><i>1555</i>&nbsp;			if (summary == null) {</b>
<b class="nc"><i>1556</i>&nbsp;				summary = new TMASummaryEntry(selectedMeasurementCombinationProperty, skipMissingCoresProperty, combinedPredicate);</b>
<b class="nc"><i>1557</i>&nbsp;				summaryEntryMap.put(id, summary);</b>
<i>1558</i>&nbsp;			}
<b class="nc"><i>1559</i>&nbsp;			summary.addEntry(entry);</b>
<b class="nc"><i>1560</i>&nbsp;			maxSummaryLength = Math.max(maxSummaryLength, summary.getEntries().size());</b>
<b class="nc"><i>1561</i>&nbsp;		}</b>
<i>1562</i>&nbsp;		
<i>1563</i>&nbsp;		// If we don&#39;t have any summaries, just return the original entries
<b class="nc"><i>1564</i>&nbsp;		if (summaryEntryMap.isEmpty() || maxSummaryLength &lt;= 1)</b>
<b class="nc"><i>1565</i>&nbsp;			return entries;</b>
<b class="nc"><i>1566</i>&nbsp;		return summaryEntryMap.values();</b>
<i>1567</i>&nbsp;	}
<i>1568</i>&nbsp;	
<i>1569</i>&nbsp;	
<i>1570</i>&nbsp;	
<i>1571</i>&nbsp;	private void parseInputFile(File file, List&lt;TMAEntry&gt; entries) {
<i>1572</i>&nbsp;		
<b class="nc"><i>1573</i>&nbsp;		int nEntries = entries.size();</b>
<i>1574</i>&nbsp;
<b class="nc"><i>1575</i>&nbsp;		String serverPath = null;</b>
<i>1576</i>&nbsp;		try {
<b class="nc"><i>1577</i>&nbsp;			Scanner scanner = new Scanner(file);</b>
<b class="nc"><i>1578</i>&nbsp;			serverPath = scanner.nextLine().trim();</b>
<b class="nc"><i>1579</i>&nbsp;			scanner.close();</b>
<b class="nc"><i>1580</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>1581</i>&nbsp;			logger.error(&quot;Error parsing input file&quot;, e);</b>
<b class="nc"><i>1582</i>&nbsp;		}</b>
<b class="nc"><i>1583</i>&nbsp;		if (serverPath == null) { // || !(new File(serverPath).exists())) {</b>
<b class="nc"><i>1584</i>&nbsp;			logger.error(&quot;Unable to find a server with path &quot; + serverPath + &quot; - cannot parse &quot; + file.getAbsolutePath());</b>
<i>1585</i>&nbsp;			return;
<i>1586</i>&nbsp;		}		
<i>1587</i>&nbsp;
<b class="nc"><i>1588</i>&nbsp;		File dirData = new File(file.getAbsolutePath() + &quot;.data&quot;);</b>
<i>1589</i>&nbsp;		
<i>1590</i>&nbsp;		try {
<b class="nc"><i>1591</i>&nbsp;			File fileResults = getTMAResultsFile(dirData);</b>
<b class="nc"><i>1592</i>&nbsp;			if (fileResults == null) {</b>
<b class="nc"><i>1593</i>&nbsp;				logger.error(&quot;No results file found for {}&quot;, dirData.getAbsolutePath());</b>
<i>1594</i>&nbsp;				return;
<i>1595</i>&nbsp;			}
<b class="nc"><i>1596</i>&nbsp;			Map&lt;String, List&lt;String&gt;&gt; csvData = TMAScoreImporter.readCSV(fileResults);</b>
<b class="nc"><i>1597</i>&nbsp;			if (csvData.isEmpty()) {</b>
<b class="nc"><i>1598</i>&nbsp;				logger.warn(&quot;Results file empty: {}&quot;, fileResults.getAbsolutePath());</b>
<i>1599</i>&nbsp;				return;
<i>1600</i>&nbsp;			}
<i>1601</i>&nbsp;			
<i>1602</i>&nbsp;			// Identify metadata and numeric columns
<b class="nc"><i>1603</i>&nbsp;			Map&lt;String, List&lt;String&gt;&gt; metadataColumns = new LinkedHashMap&lt;&gt;();</b>
<b class="nc"><i>1604</i>&nbsp;			Map&lt;String, double[]&gt; measurementColumns = new LinkedHashMap&lt;&gt;();</b>
<b class="nc"><i>1605</i>&nbsp;			List&lt;String&gt; idColumn = csvData.remove(TMACoreObject.KEY_UNIQUE_ID);</b>
<b class="nc"><i>1606</i>&nbsp;			if (idColumn != null) {</b>
<b class="nc"><i>1607</i>&nbsp;				metadataColumns.put(TMACoreObject.KEY_UNIQUE_ID, idColumn);</b>
<i>1608</i>&nbsp;				
<i>1609</i>&nbsp;				// Make sure IDs are trimmed
<b class="nc"><i>1610</i>&nbsp;				if (trimUniqueIDs) {</b>
<b class="nc"><i>1611</i>&nbsp;					for (int i = 0; i &lt; idColumn.size(); i++)</b>
<b class="nc"><i>1612</i>&nbsp;						idColumn.set(i, idColumn.get(i) == null ? null : idColumn.get(i).trim());</b>
<i>1613</i>&nbsp;				}
<i>1614</i>&nbsp;			}
<b class="nc"><i>1615</i>&nbsp;			List&lt;String&gt; nameColumn = csvData.remove(&quot;Name&quot;);</b>
<b class="nc"><i>1616</i>&nbsp;			if (nameColumn == null)</b>
<b class="nc"><i>1617</i>&nbsp;				nameColumn = csvData.remove(&quot;Object&quot;);</b>
<i>1618</i>&nbsp;			// Handle &#39;missing-ness&#39; separately from general metadata
<b class="nc"><i>1619</i>&nbsp;			List&lt;String&gt; missingColumn = csvData.remove(MISSING_COLUMN);</b>
<b class="nc"><i>1620</i>&nbsp;			int n = idColumn == null ? 0 : idColumn.size(); //csvData.values().iterator().next().size();</b>
<b class="nc"><i>1621</i>&nbsp;			for (Entry&lt;String, List&lt;String&gt;&gt; entry : csvData.entrySet()) {</b>
<b class="nc"><i>1622</i>&nbsp;				List&lt;String&gt; list = entry.getValue();</b>
<b class="nc"><i>1623</i>&nbsp;				n = list.size();</b>
<b class="nc"><i>1624</i>&nbsp;				double[] values = TMAScoreImporter.parseNumeric(list, true);</b>
<b class="nc"><i>1625</i>&nbsp;				if (values == null || GeneralTools.numNaNs(values) == list.size())</b>
<b class="nc"><i>1626</i>&nbsp;					metadataColumns.put(entry.getKey(), list);</b>
<i>1627</i>&nbsp;				else
<b class="nc"><i>1628</i>&nbsp;					measurementColumns.put(entry.getKey(), values);</b>
<b class="nc"><i>1629</i>&nbsp;			}</b>
<i>1630</i>&nbsp;			
<b class="nc"><i>1631</i>&nbsp;			for (int i = 0; i &lt; n; i++) {</b>
<i>1632</i>&nbsp;				// Don&#39;t permit &#39;NaN&#39; as an ID
<b class="nc"><i>1633</i>&nbsp;				if (idColumn != null &amp;&amp; &quot;NaN&quot;.equals(idColumn.get(i)))</b>
<b class="nc"><i>1634</i>&nbsp;					continue;</b>
<b class="nc"><i>1635</i>&nbsp;				String name = nameColumn == null ? idColumn.get(i) : nameColumn.get(i);</b>
<b class="nc"><i>1636</i>&nbsp;				boolean missing = missingColumn != null &amp;&amp; &quot;True&quot;.equals(missingColumn.get(i));</b>
<b class="nc"><i>1637</i>&nbsp;				File fileImage = new File(dirData, name + &quot;.jpg&quot;);</b>
<b class="nc"><i>1638</i>&nbsp;				File fileOverlayImage = new File(dirData, name + &quot;-overlay.jpg&quot;);</b>
<b class="nc"><i>1639</i>&nbsp;				if (!fileOverlayImage.exists())</b>
<b class="nc"><i>1640</i>&nbsp;					fileOverlayImage = new File(dirData, name + &quot;-overlay.png&quot;);</b>
<b class="nc"><i>1641</i>&nbsp;				TMAEntry entry = TMAEntries.createDefaultTMAEntry(serverPath, fileImage.getAbsolutePath(), fileOverlayImage.getAbsolutePath(), name, missing);</b>
<b class="nc"><i>1642</i>&nbsp;				for (Entry&lt;String, List&lt;String&gt;&gt; temp : metadataColumns.entrySet()) {</b>
<b class="nc"><i>1643</i>&nbsp;					entry.putMetadata(temp.getKey(), temp.getValue().get(i));</b>
<b class="nc"><i>1644</i>&nbsp;				}</b>
<b class="nc"><i>1645</i>&nbsp;				for (Entry&lt;String, double[]&gt; temp : measurementColumns.entrySet()) {</b>
<b class="nc"><i>1646</i>&nbsp;					entry.putMeasurement(temp.getKey(), temp.getValue()[i]);</b>
<b class="nc"><i>1647</i>&nbsp;				}</b>
<b class="nc"><i>1648</i>&nbsp;				entries.add(entry);</b>
<i>1649</i>&nbsp;			}
<b class="nc"><i>1650</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>1651</i>&nbsp;			logger.error(&quot;Error parsing input file &quot; + file, e);</b>
<b class="nc"><i>1652</i>&nbsp;		}</b>
<i>1653</i>&nbsp;
<b class="nc"><i>1654</i>&nbsp;		logger.info(&quot;Parsed &quot; + (entries.size() - nEntries) + &quot; from &quot; + file.getName() + &quot; (&quot; + entries.size() + &quot; total)&quot;);</b>
<i>1655</i>&nbsp;	}
<i>1656</i>&nbsp;
<i>1657</i>&nbsp;
<i>1658</i>&nbsp;	private File getTMAResultsFile(File dir) {
<b class="nc"><i>1659</i>&nbsp;		for (File file : dir.listFiles())</b>
<b class="nc"><i>1660</i>&nbsp;			if ((file.getName().startsWith(&quot;TMA results&quot;) || file.getName().startsWith(&quot;TMA_results&quot;)) &amp;&amp; file.getName().endsWith(&quot;.txt&quot;))</b>
<b class="nc"><i>1661</i>&nbsp;				return file;</b>
<b class="nc"><i>1662</i>&nbsp;		return null;</b>
<i>1663</i>&nbsp;	}
<i>1664</i>&nbsp;
<i>1665</i>&nbsp;
<i>1666</i>&nbsp;
<i>1667</i>&nbsp;	private class TMATableModel implements PathTableData&lt;TMAEntry&gt; {
<i>1668</i>&nbsp;		
<b class="nc"><i>1669</i>&nbsp;		private ObservableList&lt;TMAEntry&gt; list = FXCollections.observableArrayList();</b>
<i>1670</i>&nbsp;		
<b class="nc"><i>1671</i>&nbsp;		TMATableModel() {</b>
<b class="nc"><i>1672</i>&nbsp;			useSelectedProperty.addListener((v, o, n) -&gt; refreshList());</b>
<b class="nc"><i>1673</i>&nbsp;			table.getSelectionModel().getSelectedItems().addListener(new ListChangeListener&lt;TreeItem&lt;TMAEntry&gt;&gt;() {</b>
<i>1674</i>&nbsp;				@Override
<i>1675</i>&nbsp;				public void onChanged(ListChangeListener.Change&lt;? extends TreeItem&lt;TMAEntry&gt;&gt; c) {
<b class="nc"><i>1676</i>&nbsp;					if (useSelectedProperty.get())</b>
<b class="nc"><i>1677</i>&nbsp;						refreshList();</b>
<i>1678</i>&nbsp;				}
<i>1679</i>&nbsp;			});
<b class="nc"><i>1680</i>&nbsp;			refreshList();</b>
<i>1681</i>&nbsp;		}
<i>1682</i>&nbsp;		
<i>1683</i>&nbsp;		private void refreshList() {
<b class="nc"><i>1684</i>&nbsp;			if (table.getRoot() == null)</b>
<b class="nc"><i>1685</i>&nbsp;				list.clear();</b>
<b class="nc"><i>1686</i>&nbsp;			else if (useSelectedProperty.get()) {</b>
<b class="nc"><i>1687</i>&nbsp;				List&lt;TMAEntry&gt; selectedList = table.getSelectionModel().getSelectedItems().stream().map(i -&gt; i.getValue()).collect(Collectors.toList());</b>
<i>1688</i>&nbsp;				// If we have *any* summary entries, then make sure we have *all* summary entries
<b class="nc"><i>1689</i>&nbsp;				if (selectedList.stream().anyMatch(e -&gt; e instanceof TMASummaryEntry))</b>
<b class="nc"><i>1690</i>&nbsp;					selectedList = selectedList.stream().filter(e -&gt; e instanceof TMASummaryEntry).collect(Collectors.toList());</b>
<b class="nc"><i>1691</i>&nbsp;				list.setAll(selectedList);</b>
<b class="nc"><i>1692</i>&nbsp;			} else</b>
<b class="nc"><i>1693</i>&nbsp;				list.setAll(table.getRoot().getChildren().stream().map(i -&gt; i.getValue()).collect(Collectors.toList()));</b>
<i>1694</i>&nbsp;		}
<i>1695</i>&nbsp;		
<i>1696</i>&nbsp;		
<i>1697</i>&nbsp;		@Override
<i>1698</i>&nbsp;		public List&lt;String&gt; getAllNames() {
<b class="nc"><i>1699</i>&nbsp;			List&lt;String&gt; namesList = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>1700</i>&nbsp;			namesList.add(&quot;Image&quot;);</b>
<b class="nc"><i>1701</i>&nbsp;			namesList.add(&quot;Core&quot;);</b>
<b class="nc"><i>1702</i>&nbsp;			namesList.addAll(metadataNames);</b>
<b class="nc"><i>1703</i>&nbsp;			namesList.addAll(measurementNames);</b>
<b class="nc"><i>1704</i>&nbsp;			namesList.add(&quot;Comment&quot;);</b>
<b class="nc"><i>1705</i>&nbsp;			return namesList;</b>
<i>1706</i>&nbsp;		}
<i>1707</i>&nbsp;
<i>1708</i>&nbsp;		@Override
<i>1709</i>&nbsp;		public String getStringValue(TMAEntry entry, String column) {
<b class="nc"><i>1710</i>&nbsp;			return getStringValue(entry, column, -1);</b>
<i>1711</i>&nbsp;		}
<i>1712</i>&nbsp;
<i>1713</i>&nbsp;		@Override
<i>1714</i>&nbsp;		public String getStringValue(TMAEntry entry, String column, int decimalPlaces) {
<b class="nc"><i>1715</i>&nbsp;			if (&quot;Image&quot;.equals(column))</b>
<b class="nc"><i>1716</i>&nbsp;				return entry.getImageName();</b>
<b class="nc"><i>1717</i>&nbsp;			if (&quot;Core&quot;.equals(column))</b>
<b class="nc"><i>1718</i>&nbsp;				return entry.getName();</b>
<b class="nc"><i>1719</i>&nbsp;			if (&quot;Comment&quot;.equals(column))</b>
<b class="nc"><i>1720</i>&nbsp;				return entry.getComment();</b>
<i>1721</i>&nbsp;//			if (&quot;Non missing&quot;.equals(column))
<i>1722</i>&nbsp;//				return entry instanceof TMASummaryEntry ? Integer.toString(((TMASummaryEntry)entry).nNonMissingEntries()) : &quot;&quot;;
<b class="nc"><i>1723</i>&nbsp;			if (metadataNames.contains(column))</b>
<b class="nc"><i>1724</i>&nbsp;				return entry.getMetadataValue(column);</b>
<b class="nc"><i>1725</i>&nbsp;			double val = getNumericValue(entry, column);</b>
<b class="nc"><i>1726</i>&nbsp;			if (Double.isNaN(val))</b>
<b class="nc"><i>1727</i>&nbsp;				return &quot;NaN&quot;;</b>
<b class="nc"><i>1728</i>&nbsp;			return GeneralTools.formatNumber(getNumericValue(entry, column), 4);</b>
<i>1729</i>&nbsp;		}
<i>1730</i>&nbsp;
<i>1731</i>&nbsp;		@Override
<i>1732</i>&nbsp;		public List&lt;String&gt; getMeasurementNames() {
<b class="nc"><i>1733</i>&nbsp;			return measurementNames;</b>
<i>1734</i>&nbsp;		}
<i>1735</i>&nbsp;
<i>1736</i>&nbsp;		@Override
<i>1737</i>&nbsp;		public double getNumericValue(TMAEntry entry, String column) {
<b class="nc"><i>1738</i>&nbsp;			if (entry == null)</b>
<b class="nc"><i>1739</i>&nbsp;				return Double.NaN;</b>
<b class="nc"><i>1740</i>&nbsp;			if (&quot;Available cores&quot;.equals(column))</b>
<b class="nc"><i>1741</i>&nbsp;				return entry instanceof TMASummaryEntry ? ((TMASummaryEntry)entry).nNonMissingEntries() : Double.NaN;</b>
<b class="nc"><i>1742</i>&nbsp;			Number value = entry.getMeasurement(column);</b>
<b class="nc"><i>1743</i>&nbsp;			return value == null ? Double.NaN : value.doubleValue();</b>
<i>1744</i>&nbsp;		}
<i>1745</i>&nbsp;
<i>1746</i>&nbsp;		@Override
<i>1747</i>&nbsp;		public double[] getDoubleValues(String column) {
<b class="nc"><i>1748</i>&nbsp;			List&lt;TMAEntry&gt; entries = getItems();</b>
<b class="nc"><i>1749</i>&nbsp;			double[] values = new double[entries.size()];</b>
<b class="nc"><i>1750</i>&nbsp;			for (int i = 0; i &lt; entries.size(); i++)</b>
<b class="nc"><i>1751</i>&nbsp;				values[i] = getNumericValue(entries.get(i), column);</b>
<b class="nc"><i>1752</i>&nbsp;			return values;</b>
<i>1753</i>&nbsp;		}
<i>1754</i>&nbsp;
<i>1755</i>&nbsp;		@Override
<i>1756</i>&nbsp;		public ObservableList&lt;TMAEntry&gt; getItems() {
<b class="nc"><i>1757</i>&nbsp;			return list;</b>
<i>1758</i>&nbsp;//			if (useSelectedProperty.get())
<i>1759</i>&nbsp;//				return Collections.unmodifiableList(table.getSelectionModel().getSelectedItems());
<i>1760</i>&nbsp;//			return Collections.unmodifiableList(table.getItems());
<i>1761</i>&nbsp;		}
<i>1762</i>&nbsp;
<i>1763</i>&nbsp;
<i>1764</i>&nbsp;	}
<i>1765</i>&nbsp;
<i>1766</i>&nbsp;
<i>1767</i>&nbsp;	private void promptForComment() {
<b class="nc"><i>1768</i>&nbsp;		String input = Dialogs.showInputDialog( </b>
<i>1769</i>&nbsp;				&quot;Add comment&quot;,
<b class="nc"><i>1770</i>&nbsp;				&quot;Type comment for &quot; + entrySelected.getName() + &quot;(&quot; + entrySelected.getImageName() + &quot;)&quot;, entrySelected.getComment());</b>
<b class="nc"><i>1771</i>&nbsp;		if (input == null)</b>
<i>1772</i>&nbsp;			return;
<b class="nc"><i>1773</i>&nbsp;		entrySelected.setComment(input);</b>
<b class="nc"><i>1774</i>&nbsp;		table.refresh();</b>
<i>1775</i>&nbsp;	}
<i>1776</i>&nbsp;	
<i>1777</i>&nbsp;	class ScatterPane {
<i>1778</i>&nbsp;		
<b class="nc"><i>1779</i>&nbsp;		private BorderPane pane = new BorderPane();</b>
<b class="nc"><i>1780</i>&nbsp;		private ComboBox&lt;String&gt; comboScatterMainMeasurement = new ComboBox&lt;&gt;();</b>
<b class="nc"><i>1781</i>&nbsp;		private ComboBox&lt;String&gt; comboScatterSecondaryMeasurement = new ComboBox&lt;&gt;();</b>
<i>1782</i>&nbsp;		
<b class="nc"><i>1783</i>&nbsp;		private NumberAxis xAxis = new NumberAxis();</b>
<b class="nc"><i>1784</i>&nbsp;		private NumberAxis yAxis = new NumberAxis();</b>
<b class="nc"><i>1785</i>&nbsp;		private ScatterChart&lt;Number, Number&gt; chart = new ScatterChart&lt;&gt;(xAxis, yAxis);</b>
<i>1786</i>&nbsp;		
<b class="nc"><i>1787</i>&nbsp;		private TableView&lt;DoubleProperty&gt; tableScatter = new TableView&lt;&gt;();</b>
<i>1788</i>&nbsp;		
<b class="nc"><i>1789</i>&nbsp;		ScatterPane() {</b>
<b class="nc"><i>1790</i>&nbsp;			comboScatterMainMeasurement.setItems(measurementNames);</b>
<b class="nc"><i>1791</i>&nbsp;			comboScatterSecondaryMeasurement.setItems(measurementNames);</b>
<i>1792</i>&nbsp;			
<b class="nc"><i>1793</i>&nbsp;			comboMainMeasurement.getSelectionModel().selectedItemProperty().addListener((v, o, n) -&gt; comboScatterMainMeasurement.getSelectionModel().select(n));</b>
<b class="nc"><i>1794</i>&nbsp;			comboScatterMainMeasurement.getSelectionModel().selectedItemProperty().addListener((v, o, n) -&gt; comboMainMeasurement.getSelectionModel().select(n));</b>
<i>1795</i>&nbsp;			
<b class="nc"><i>1796</i>&nbsp;			comboScatterMainMeasurement.getSelectionModel().selectedItemProperty().addListener((v, o, n) -&gt; updateChart());</b>
<b class="nc"><i>1797</i>&nbsp;			comboScatterSecondaryMeasurement.getSelectionModel().selectedItemProperty().addListener((v, o, n) -&gt; updateChart());</b>
<i>1798</i>&nbsp;			
<b class="nc"><i>1799</i>&nbsp;			GridPane topGrid = new GridPane();</b>
<b class="nc"><i>1800</i>&nbsp;			Label label = new Label(&quot;Main measurement&quot;);</b>
<b class="nc"><i>1801</i>&nbsp;			label.minWidthProperty().bind(label.prefWidthProperty());</b>
<b class="nc"><i>1802</i>&nbsp;			topGrid.add(label, 0, 0);</b>
<b class="nc"><i>1803</i>&nbsp;			topGrid.add(comboScatterMainMeasurement, 1, 0);</b>
<b class="nc"><i>1804</i>&nbsp;			label = new Label(&quot;Secondary measurement&quot;);</b>
<b class="nc"><i>1805</i>&nbsp;			label.minWidthProperty().bind(label.prefWidthProperty());</b>
<b class="nc"><i>1806</i>&nbsp;			topGrid.add(label, 0, 1);</b>
<b class="nc"><i>1807</i>&nbsp;			topGrid.add(comboScatterSecondaryMeasurement, 1, 1);</b>
<b class="nc"><i>1808</i>&nbsp;			topGrid.setHgap(5);</b>
<b class="nc"><i>1809</i>&nbsp;			comboScatterMainMeasurement.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>1810</i>&nbsp;			comboScatterSecondaryMeasurement.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>1811</i>&nbsp;			GridPane.setHgrow(comboScatterMainMeasurement, Priority.ALWAYS);</b>
<b class="nc"><i>1812</i>&nbsp;			GridPane.setHgrow(comboScatterSecondaryMeasurement, Priority.ALWAYS);</b>
<b class="nc"><i>1813</i>&nbsp;			topGrid.setPadding(new Insets(5, 10, 5, 10));</b>
<b class="nc"><i>1814</i>&nbsp;			topGrid.prefWidthProperty().bind(pane.widthProperty());</b>
<i>1815</i>&nbsp;			
<i>1816</i>&nbsp;			// Set up table
<b class="nc"><i>1817</i>&nbsp;			TableColumn&lt;DoubleProperty, String&gt; colName = new TableColumn&lt;&gt;(&quot;Name&quot;);</b>
<b class="nc"><i>1818</i>&nbsp;			colName.setCellValueFactory(v -&gt; new SimpleStringProperty(v.getValue().getName()));</b>
<b class="nc"><i>1819</i>&nbsp;			TableColumn&lt;DoubleProperty, String&gt; colValue = new TableColumn&lt;&gt;(&quot;Value&quot;);</b>
<b class="nc"><i>1820</i>&nbsp;			colValue.setCellValueFactory(v -&gt; new SimpleStringProperty(GeneralTools.formatNumber(v.getValue().getValue(), 3)));</b>
<b class="nc"><i>1821</i>&nbsp;			tableScatter.getColumns().add(colName);</b>
<b class="nc"><i>1822</i>&nbsp;			tableScatter.getColumns().add(colValue);</b>
<b class="nc"><i>1823</i>&nbsp;			tableScatter.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);</b>
<b class="nc"><i>1824</i>&nbsp;			tableScatter.setPrefHeight(25*8);</b>
<i>1825</i>&nbsp;			
<b class="nc"><i>1826</i>&nbsp;			pane.setTop(topGrid);</b>
<b class="nc"><i>1827</i>&nbsp;			pane.setCenter(chart);</b>
<b class="nc"><i>1828</i>&nbsp;			pane.setBottom(tableScatter);</b>
<i>1829</i>&nbsp;			
<i>1830</i>&nbsp;			
<i>1831</i>&nbsp;			// Make it possible to navigate around the chart
<b class="nc"><i>1832</i>&nbsp;			ChartTools.makeChartInteractive(chart, xAxis, yAxis);</b>
<b class="nc"><i>1833</i>&nbsp;			ChartTools.addChartExportMenu(chart, null);</b>
<i>1834</i>&nbsp;		}
<i>1835</i>&nbsp;		
<i>1836</i>&nbsp;		
<i>1837</i>&nbsp;		
<i>1838</i>&nbsp;		
<i>1839</i>&nbsp;		public Pane getPane() {
<b class="nc"><i>1840</i>&nbsp;			return pane;</b>
<i>1841</i>&nbsp;		}
<i>1842</i>&nbsp;		
<i>1843</i>&nbsp;		
<i>1844</i>&nbsp;		private void updateChart() {
<b class="nc"><i>1845</i>&nbsp;			String xMeasurement = comboScatterMainMeasurement.getSelectionModel().getSelectedItem();</b>
<b class="nc"><i>1846</i>&nbsp;			String yMeasurement = comboScatterSecondaryMeasurement.getSelectionModel().getSelectedItem();</b>
<i>1847</i>&nbsp;			
<b class="nc"><i>1848</i>&nbsp;			double[] x = model.getDoubleValues(xMeasurement);</b>
<b class="nc"><i>1849</i>&nbsp;			double[] y = model.getDoubleValues(yMeasurement);</b>
<b class="nc"><i>1850</i>&nbsp;			int count = 0;</b>
<i>1851</i>&nbsp;			
<b class="nc"><i>1852</i>&nbsp;			List&lt;TMAEntry&gt; entries = model.getItems();</b>
<b class="nc"><i>1853</i>&nbsp;			ObservableList&lt;XYChart.Data&lt;Number, Number&gt;&gt; data = FXCollections.observableArrayList();</b>
<b class="nc"><i>1854</i>&nbsp;			for (int i = 0; i &lt; x.length; i++) {</b>
<b class="nc"><i>1855</i>&nbsp;				double xx = x[i];</b>
<b class="nc"><i>1856</i>&nbsp;				double yy = y[i];</b>
<b class="nc"><i>1857</i>&nbsp;				if (Double.isNaN(xx) || Double.isNaN(yy))</b>
<b class="nc"><i>1858</i>&nbsp;					continue;</b>
<i>1859</i>&nbsp;				
<i>1860</i>&nbsp;				// Adding jitter (but need to consider axis scaling)
<i>1861</i>&nbsp;//				xx = xx + Math.random()/5;
<i>1862</i>&nbsp;//				yy = yy + Math.random()/5;
<i>1863</i>&nbsp;				
<b class="nc"><i>1864</i>&nbsp;				XYChart.Data&lt;Number, Number&gt; item = new XYChart.Data&lt;&gt;(xx, yy, entries.get(i));</b>
<b class="nc"><i>1865</i>&nbsp;				data.add(item);</b>
<i>1866</i>&nbsp;				
<i>1867</i>&nbsp;				// Shift values back to replace any NaNs
<b class="nc"><i>1868</i>&nbsp;				x[count] = xx;</b>
<b class="nc"><i>1869</i>&nbsp;				y[count] = yy;</b>
<b class="nc"><i>1870</i>&nbsp;				count++;</b>
<i>1871</i>&nbsp;			}
<b class="nc"><i>1872</i>&nbsp;			if (chart.getData().isEmpty())</b>
<b class="nc"><i>1873</i>&nbsp;				chart.getData().add(new XYChart.Series&lt;&gt;(data));</b>
<i>1874</i>&nbsp;			else
<b class="nc"><i>1875</i>&nbsp;				chart.getData().get(0).setData(data);</b>
<i>1876</i>&nbsp;			
<b class="nc"><i>1877</i>&nbsp;			for (XYChart.Data&lt;Number, Number&gt; element : data) {</b>
<b class="nc"><i>1878</i>&nbsp;				Node node = element.getNode();</b>
<b class="nc"><i>1879</i>&nbsp;				Object value = element.getExtraValue();</b>
<b class="nc"><i>1880</i>&nbsp;				if (value instanceof TMAEntry) {</b>
<b class="nc"><i>1881</i>&nbsp;					TMAEntry entry = (TMAEntry)value;</b>
<b class="nc"><i>1882</i>&nbsp;					if (entry.getMeasurement(colCensored) != null &amp;&amp; entry.getMeasurement(colCensored).doubleValue() == 1)</b>
<b class="nc"><i>1883</i>&nbsp;						node.setStyle(&quot;&quot;</b>
<i>1884</i>&nbsp;							+ &quot;-fx-background-color: rgb(60, 200, 60, 0.75); &quot;
<i>1885</i>&nbsp;							+ &quot;-fx-opacity: 0.5;&quot;
<i>1886</i>&nbsp;							+ &quot;&quot;);
<i>1887</i>&nbsp;					else {
<b class="nc"><i>1888</i>&nbsp;						node.setStyle(&quot;&quot;</b>
<i>1889</i>&nbsp;								+ &quot;-fx-opacity: 0.75;&quot;
<i>1890</i>&nbsp;								+ &quot;&quot;);
<i>1891</i>&nbsp;					}
<b class="nc"><i>1892</i>&nbsp;					node.setOnMouseClicked(e -&gt; {</b>
<i>1893</i>&nbsp;						// Only clear selection if selection isn&#39;t used for display
<b class="nc"><i>1894</i>&nbsp;						if (!useSelectedProperty.get())</b>
<b class="nc"><i>1895</i>&nbsp;							table.getSelectionModel().clearSelection();</b>
<i>1896</i>&nbsp;						
<i>1897</i>&nbsp;						// Select the item
<b class="nc"><i>1898</i>&nbsp;						TreeItem&lt;TMAEntry&gt; item = getItem(table.getRoot(), entry);</b>
<b class="nc"><i>1899</i>&nbsp;						if (item != null) {</b>
<b class="nc"><i>1900</i>&nbsp;							item.setExpanded(true);</b>
<i>1901</i>&nbsp;//							if (item.getParent() != null)
<i>1902</i>&nbsp;//								item.getParent().setExpanded(true);
<b class="nc"><i>1903</i>&nbsp;							table.getSelectionModel().select(item);</b>
<b class="nc"><i>1904</i>&nbsp;							table.layout();</b>
<b class="nc"><i>1905</i>&nbsp;							int ind = table.getSelectionModel().getSelectedIndex();</b>
<b class="nc"><i>1906</i>&nbsp;							if (ind &gt;= 0) {</b>
<b class="nc"><i>1907</i>&nbsp;								table.scrollTo(ind);</b>
<i>1908</i>&nbsp;							}
<i>1909</i>&nbsp;						}
<i>1910</i>&nbsp;					});
<i>1911</i>&nbsp;				}
<b class="nc"><i>1912</i>&nbsp;				DropShadow dropShadow = new DropShadow();</b>
<b class="nc"><i>1913</i>&nbsp;				Node nodeFinal = node;</b>
<b class="nc"><i>1914</i>&nbsp;				nodeFinal.hoverProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>1915</i>&nbsp;					nodeFinal.setEffect(n ? dropShadow : null);</b>
<i>1916</i>&nbsp;				});
<b class="nc"><i>1917</i>&nbsp;			}</b>
<i>1918</i>&nbsp;			
<b class="nc"><i>1919</i>&nbsp;			xAxis.setLabel(xMeasurement);</b>
<b class="nc"><i>1920</i>&nbsp;			yAxis.setLabel(yMeasurement);</b>
<b class="nc"><i>1921</i>&nbsp;			chart.setLegendVisible(false);</b>
<i>1922</i>&nbsp;			
<i>1923</i>&nbsp;			
<i>1924</i>&nbsp;			// Try to update table data
<b class="nc"><i>1925</i>&nbsp;			if (count == 0) {</b>
<b class="nc"><i>1926</i>&nbsp;				tableScatter.getItems().clear();</b>
<i>1927</i>&nbsp;				return;
<i>1928</i>&nbsp;			}
<b class="nc"><i>1929</i>&nbsp;			int len = x.length;</b>
<b class="nc"><i>1930</i>&nbsp;			int nNanX = GeneralTools.numNaNs(x);</b>
<b class="nc"><i>1931</i>&nbsp;			int nNanY = GeneralTools.numNaNs(y);</b>
<b class="nc"><i>1932</i>&nbsp;			if (count &lt; x.length) {</b>
<b class="nc"><i>1933</i>&nbsp;				x = Arrays.copyOf(x, count);</b>
<b class="nc"><i>1934</i>&nbsp;				y = Arrays.copyOf(y, count);</b>
<i>1935</i>&nbsp;			}
<b class="nc"><i>1936</i>&nbsp;			tableScatter.getItems().setAll(</b>
<i>1937</i>&nbsp;					new SimpleDoubleProperty(null, &quot;Total &#39;&quot; + xMeasurement + &quot;&#39;&quot;, len - nNanX),
<i>1938</i>&nbsp;					new SimpleDoubleProperty(null, &quot;Total &#39;&quot; + yMeasurement + &quot;&#39;&quot;, len - nNanY),
<b class="nc"><i>1939</i>&nbsp;					new SimpleDoubleProperty(null, String.format(&quot;Total &#39;%s&#39; &amp; &#39;%s&#39;&quot;, xMeasurement, yMeasurement), count)</b>
<i>1940</i>&nbsp;					);
<b class="nc"><i>1941</i>&nbsp;			if (count &gt; 1) {</b>
<b class="nc"><i>1942</i>&nbsp;				double pearsons = new PearsonsCorrelation().correlation(x, y);</b>
<b class="nc"><i>1943</i>&nbsp;				double spearmans = new SpearmansCorrelation().correlation(x, y);</b>
<b class="nc"><i>1944</i>&nbsp;				tableScatter.getItems().addAll(</b>
<i>1945</i>&nbsp;						new SimpleDoubleProperty(null, &quot;Pearson&#39;s correlation coefficient&quot;, pearsons),
<i>1946</i>&nbsp;						new SimpleDoubleProperty(null, &quot;Spearman&#39;s correlation coefficient&quot;, spearmans)
<i>1947</i>&nbsp;						);
<i>1948</i>&nbsp;			}
<i>1949</i>&nbsp;			
<i>1950</i>&nbsp;		}
<i>1951</i>&nbsp;		
<i>1952</i>&nbsp;	}
<i>1953</i>&nbsp;	
<i>1954</i>&nbsp;	
<i>1955</i>&nbsp;	/**
<i>1956</i>&nbsp;	 * Recursively search for a TreeItem, based upon the TMAEntry it represents.
<i>1957</i>&nbsp;	 * 
<i>1958</i>&nbsp;	 * @param item
<i>1959</i>&nbsp;	 * @param entry
<i>1960</i>&nbsp;	 * @return
<i>1961</i>&nbsp;	 */
<i>1962</i>&nbsp;	private TreeItem&lt;TMAEntry&gt; getItem(final TreeItem&lt;TMAEntry&gt; item, final TMAEntry entry) {
<b class="nc"><i>1963</i>&nbsp;		if (item == null)</b>
<b class="nc"><i>1964</i>&nbsp;			return null;</b>
<b class="nc"><i>1965</i>&nbsp;		if (item.getValue() == entry)</b>
<b class="nc"><i>1966</i>&nbsp;			return item;</b>
<b class="nc"><i>1967</i>&nbsp;		for (TreeItem&lt;TMAEntry&gt; item2 : item.getChildren()) {</b>
<b class="nc"><i>1968</i>&nbsp;			TreeItem&lt;TMAEntry&gt; found = getItem(item2, entry);</b>
<b class="nc"><i>1969</i>&nbsp;			if (found != null)</b>
<b class="nc"><i>1970</i>&nbsp;				return found;</b>
<b class="nc"><i>1971</i>&nbsp;		}</b>
<b class="nc"><i>1972</i>&nbsp;		return null;</b>
<i>1973</i>&nbsp;	}
<i>1974</i>&nbsp;	
<i>1975</i>&nbsp;	
<i>1976</i>&nbsp;	
<i>1977</i>&nbsp;	private int importScores(final String text) {
<b class="nc"><i>1978</i>&nbsp;		Map&lt;String, List&lt;String&gt;&gt; data = TMAScoreImporter.readCSV(text);</b>
<b class="nc"><i>1979</i>&nbsp;		List&lt;String&gt; idColumn = data.remove(TMACoreObject.KEY_UNIQUE_ID);</b>
<b class="nc"><i>1980</i>&nbsp;		if (idColumn == null) {</b>
<b class="nc"><i>1981</i>&nbsp;			Dialogs.showErrorMessage(&quot;Import TMA data&quot;, &quot;No &#39;&quot; + TMACoreObject.KEY_UNIQUE_ID + &quot;&#39; column found!&quot;);</b>
<b class="nc"><i>1982</i>&nbsp;			return 0;</b>
<i>1983</i>&nbsp;		}
<i>1984</i>&nbsp;		// Nothing left to import...
<b class="nc"><i>1985</i>&nbsp;		if (data.isEmpty())</b>
<b class="nc"><i>1986</i>&nbsp;			return 0;</b>
<i>1987</i>&nbsp;		
<i>1988</i>&nbsp;		// Get the numeric columns, if possible
<b class="nc"><i>1989</i>&nbsp;		Map&lt;String, double[]&gt; dataNumeric = new HashMap&lt;&gt;();</b>
<b class="nc"><i>1990</i>&nbsp;		for (String key : data.keySet().toArray(new String[0])) {</b>
<b class="nc"><i>1991</i>&nbsp;			double[] vals = TMAScoreImporter.parseNumeric(data.get(key), true);</b>
<b class="nc"><i>1992</i>&nbsp;			if (vals != null &amp;&amp; GeneralTools.numNaNs(vals) != vals.length) {</b>
<b class="nc"><i>1993</i>&nbsp;				dataNumeric.put(key, vals);</b>
<b class="nc"><i>1994</i>&nbsp;				data.remove(key);</b>
<i>1995</i>&nbsp;			}
<i>1996</i>&nbsp;		}
<i>1997</i>&nbsp;		
<i>1998</i>&nbsp;		// Loop through IDs, adding values where needed
<b class="nc"><i>1999</i>&nbsp;		int counter = 0;</b>
<b class="nc"><i>2000</i>&nbsp;		for (int i = 0; i &lt; idColumn.size(); i++) {</b>
<b class="nc"><i>2001</i>&nbsp;			boolean matched = false;</b>
<b class="nc"><i>2002</i>&nbsp;			String id = idColumn.get(i);</b>
<b class="nc"><i>2003</i>&nbsp;			if (id == null) {</b>
<b class="nc"><i>2004</i>&nbsp;				logger.debug(&quot;Skipping missing ID&quot;);</b>
<b class="nc"><i>2005</i>&nbsp;				continue;</b>
<i>2006</i>&nbsp;			}
<b class="nc"><i>2007</i>&nbsp;			for (TMAEntry entry : entriesBase) {</b>
<b class="nc"><i>2008</i>&nbsp;				if (id.equals(entry.getMetadataValue(TMACoreObject.KEY_UNIQUE_ID))) {</b>
<b class="nc"><i>2009</i>&nbsp;					matched = true;</b>
<b class="nc"><i>2010</i>&nbsp;					for (Entry&lt;String, double[]&gt; dataEntry : dataNumeric.entrySet()) {</b>
<b class="nc"><i>2011</i>&nbsp;						entry.putMeasurement(dataEntry.getKey(), dataEntry.getValue()[i]);</b>
<b class="nc"><i>2012</i>&nbsp;					}</b>
<b class="nc"><i>2013</i>&nbsp;					for (Entry&lt;String, List&lt;String&gt;&gt; dataEntry : data.entrySet()) {</b>
<b class="nc"><i>2014</i>&nbsp;						entry.putMetadata(dataEntry.getKey(), dataEntry.getValue().get(i));</b>
<b class="nc"><i>2015</i>&nbsp;					}</b>
<b class="nc"><i>2016</i>&nbsp;					counter++;</b>
<i>2017</i>&nbsp;				}
<b class="nc"><i>2018</i>&nbsp;			}</b>
<b class="nc"><i>2019</i>&nbsp;			if (!matched)</b>
<b class="nc"><i>2020</i>&nbsp;				logger.warn(&quot;No match for ID: &quot; + id);</b>
<i>2021</i>&nbsp;		}
<i>2022</i>&nbsp;		
<b class="nc"><i>2023</i>&nbsp;		Optional&lt;TMAEntry&gt; objectEntry = entriesBase.stream().filter(t -&gt; t instanceof TMAObjectEntry).findAny();</b>
<b class="nc"><i>2024</i>&nbsp;		if (objectEntry.isPresent()) {</b>
<b class="nc"><i>2025</i>&nbsp;			Dialogs.showInfoNotification(&quot;TMA data update&quot;, &quot;TMA cores updated!&quot;);</b>
<i>2026</i>&nbsp;		}
<i>2027</i>&nbsp;		
<b class="nc"><i>2028</i>&nbsp;		return counter;</b>
<i>2029</i>&nbsp;	}
<i>2030</i>&nbsp;	
<i>2031</i>&nbsp;		
<i>2032</i>&nbsp;	
<i>2033</i>&nbsp;	/**
<i>2034</i>&nbsp;	 * This is admittedly not the most beautiful or safe way to deal with an arbitrary predicate,
<i>2035</i>&nbsp;	 * but a bit of sanity-checking &amp; cleanup hopefully avoids the security risk of running a full Javascript 
<i>2036</i>&nbsp;	 * engine as a glorified expression parser.
<i>2037</i>&nbsp;	 * 
<i>2038</i>&nbsp;	 * Its use is to filter out particular TMAEntries, so they don&#39;t contribute to any summaries.
<i>2039</i>&nbsp;	 */
<i>2040</i>&nbsp;	static class TablePredicate implements Predicate&lt;TMAEntry&gt; {
<i>2041</i>&nbsp;		
<i>2042</i>&nbsp;		final String commandOriginal;
<i>2043</i>&nbsp;		final String command;
<b class="nc"><i>2044</i>&nbsp;		final SimpleBindings bindings = new SimpleBindings();</b>
<i>2045</i>&nbsp;		final ScriptEngine engine;
<b class="nc"><i>2046</i>&nbsp;		private boolean lastEvaluationSucceeded = true;</b>
<b class="nc"><i>2047</i>&nbsp;		private boolean isValid = false;</b>
<i>2048</i>&nbsp;		
<b class="nc"><i>2049</i>&nbsp;		TablePredicate(final String predicate) {</b>
<i>2050</i>&nbsp;			// Predicates are only allowed to contain quoted strings (converted to measurement value requests) 
<i>2051</i>&nbsp;			// as well as operators or parentheses
<b class="nc"><i>2052</i>&nbsp;			this.commandOriginal = predicate;</b>
<b class="nc"><i>2053</i>&nbsp;			String quotedRegex = &quot;\&quot;([^\&quot;]*)\&quot;&quot;;</b>
<b class="nc"><i>2054</i>&nbsp;			String test = predicate.replaceAll(quotedRegex, &quot;&quot;);</b>
<b class="nc"><i>2055</i>&nbsp;			isValid = test.replaceAll(&quot;[ ()+-&lt;&gt;=*/&amp;|!]&quot;, &quot;&quot;).trim().isEmpty(); // Check we don&#39;t have invalid characters</b>
<i>2056</i>&nbsp;			
<b class="nc"><i>2057</i>&nbsp;			if (isValid) {</b>
<b class="nc"><i>2058</i>&nbsp;				this.command = predicate.replaceAll(quotedRegex, &quot;entry.getMeasurementAsDouble(\&quot;$1\&quot;)&quot;).trim();</b>
<i>2059</i>&nbsp;			}
<i>2060</i>&nbsp;			else
<b class="nc"><i>2061</i>&nbsp;				this.command = null;</b>
<i>2062</i>&nbsp;			
<i>2063</i>&nbsp;			
<b class="nc"><i>2064</i>&nbsp;			ScriptEngineManager manager = new ScriptEngineManager();</b>
<b class="nc"><i>2065</i>&nbsp;	        engine = manager.getEngineByName(&quot;JavaScript&quot;);</b>
<b class="nc"><i>2066</i>&nbsp;	        engine.setBindings(bindings, ScriptContext.GLOBAL_SCOPE);</b>
<i>2067</i>&nbsp;		}
<i>2068</i>&nbsp;
<i>2069</i>&nbsp;		@Override
<i>2070</i>&nbsp;		public boolean test(TMAEntry entry) {
<b class="nc"><i>2071</i>&nbsp;			if (!isValid)</b>
<b class="nc"><i>2072</i>&nbsp;				throw new RuntimeException(&quot;Cannot run invalid predicate! Original command: &quot; + commandOriginal);</b>
<i>2073</i>&nbsp;			
<i>2074</i>&nbsp;			// If nothing is included, accept everything
<b class="nc"><i>2075</i>&nbsp;			if (this.command.isEmpty())</b>
<b class="nc"><i>2076</i>&nbsp;				return true;</b>
<i>2077</i>&nbsp;			// Run script to deal with predicate if required
<b class="nc"><i>2078</i>&nbsp;			bindings.put(&quot;entry&quot;, entry);</b>
<i>2079</i>&nbsp;			try {
<b class="nc"><i>2080</i>&nbsp;				Object result = engine.eval(command);</b>
<b class="nc"><i>2081</i>&nbsp;				lastEvaluationSucceeded = result instanceof Boolean;</b>
<b class="nc"><i>2082</i>&nbsp;				return Boolean.TRUE.equals(result);</b>
<b class="nc"><i>2083</i>&nbsp;			} catch (ScriptException e) {</b>
<b class="nc"><i>2084</i>&nbsp;				lastEvaluationSucceeded = false;</b>
<b class="nc"><i>2085</i>&nbsp;				logger.error(&quot;Error evaluating {} for {}: {}&quot;, command, entry, e.getLocalizedMessage());</b>
<b class="nc"><i>2086</i>&nbsp;				return false;</b>
<i>2087</i>&nbsp;			}
<i>2088</i>&nbsp;		}
<i>2089</i>&nbsp;		
<i>2090</i>&nbsp;		public String getOriginalCommand() {
<b class="nc"><i>2091</i>&nbsp;			return commandOriginal;</b>
<i>2092</i>&nbsp;		}
<i>2093</i>&nbsp;
<i>2094</i>&nbsp;		public String getCommand() {
<b class="nc"><i>2095</i>&nbsp;			return command;</b>
<i>2096</i>&nbsp;		}
<i>2097</i>&nbsp;		
<i>2098</i>&nbsp;		public boolean isValid() {
<b class="nc"><i>2099</i>&nbsp;			return isValid;</b>
<i>2100</i>&nbsp;		}
<i>2101</i>&nbsp;
<i>2102</i>&nbsp;		public boolean lastEvaluationSucceeded() {
<b class="nc"><i>2103</i>&nbsp;			return lastEvaluationSucceeded;</b>
<i>2104</i>&nbsp;		}
<i>2105</i>&nbsp;		
<i>2106</i>&nbsp;		@Override
<i>2107</i>&nbsp;		public String toString() {
<b class="nc"><i>2108</i>&nbsp;			return getCommand();</b>
<i>2109</i>&nbsp;		}
<i>2110</i>&nbsp;		
<i>2111</i>&nbsp;	}
<i>2112</i>&nbsp;	
<i>2113</i>&nbsp;	
<i>2114</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2021-01-25 09:46</div>
</div>
</body>
</html>
