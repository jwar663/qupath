


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: QuPathGUI</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">qupath.lib.gui</a> ]
</div>

<h1>Coverage Summary for Class: QuPathGUI (qupath.lib.gui)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">QuPathGUI</td>
<td class="coverageStat">
  <span class="percent">
    52.7%
  </span>
  <span class="absValue">
    (89/ 169)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.7%
  </span>
  <span class="absValue">
    (631/ 1674)
  </span>
</td>
</tr>
  <tr>
    <td class="name">QuPathGUI$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathGUI$DefaultActions</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (73/ 73)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathGUI$MultiviewManager</td>
<td class="coverageStat">
  <span class="percent">
    36.7%
  </span>
  <span class="absValue">
    (11/ 30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    24.9%
  </span>
  <span class="absValue">
    (64/ 257)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathGUI$MultiviewManager$SplitPaneGrid</td>
<td class="coverageStat">
  <span class="percent">
    13.3%
  </span>
  <span class="absValue">
    (2/ 15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (11/ 99)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathGUI$ScrollEventPanningFilter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.9%
  </span>
  <span class="absValue">
    (7/ 47)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    47.9%
  </span>
  <span class="absValue">
    (105/ 219)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.5%
  </span>
  <span class="absValue">
    (787/ 2157)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*-
<i>2</i>&nbsp; * #%L
<i>3</i>&nbsp; * This file is part of QuPath.
<i>4</i>&nbsp; * %%
<i>5</i>&nbsp; * Copyright (C) 2014 - 2016 The Queen&#39;s University of Belfast, Northern Ireland
<i>6</i>&nbsp; * Contact: IP Management (ipmanagement@qub.ac.uk)
<i>7</i>&nbsp; * Copyright (C) 2018 - 2020 QuPath developers, The University of Edinburgh
<i>8</i>&nbsp; * %%
<i>9</i>&nbsp; * QuPath is free software: you can redistribute it and/or modify
<i>10</i>&nbsp; * it under the terms of the GNU General Public License as
<i>11</i>&nbsp; * published by the Free Software Foundation, either version 3 of the
<i>12</i>&nbsp; * License, or (at your option) any later version.
<i>13</i>&nbsp; * 
<i>14</i>&nbsp; * QuPath is distributed in the hope that it will be useful,
<i>15</i>&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
<i>16</i>&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<i>17</i>&nbsp; * GNU General Public License for more details.
<i>18</i>&nbsp; * 
<i>19</i>&nbsp; * You should have received a copy of the GNU General Public License 
<i>20</i>&nbsp; * along with QuPath.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
<i>21</i>&nbsp; * #L%
<i>22</i>&nbsp; */
<i>23</i>&nbsp;
<i>24</i>&nbsp;package qupath.lib.gui;
<i>25</i>&nbsp;
<i>26</i>&nbsp;import java.awt.Desktop;
<i>27</i>&nbsp;import java.awt.Shape;
<i>28</i>&nbsp;import java.awt.geom.AffineTransform;
<i>29</i>&nbsp;import java.awt.geom.Area;
<i>30</i>&nbsp;import java.awt.image.BufferedImage;
<i>31</i>&nbsp;import java.io.ByteArrayInputStream;
<i>32</i>&nbsp;import java.io.ByteArrayOutputStream;
<i>33</i>&nbsp;import java.io.File;
<i>34</i>&nbsp;import java.io.FileNotFoundException;
<i>35</i>&nbsp;import java.io.IOException;
<i>36</i>&nbsp;import java.io.InputStream;
<i>37</i>&nbsp;import java.io.ObjectInputStream;
<i>38</i>&nbsp;import java.io.ObjectOutputStream;
<i>39</i>&nbsp;import java.lang.Thread.UncaughtExceptionHandler;
<i>40</i>&nbsp;import java.net.URI;
<i>41</i>&nbsp;import java.net.URISyntaxException;
<i>42</i>&nbsp;import java.net.URLDecoder;
<i>43</i>&nbsp;import java.nio.charset.StandardCharsets;
<i>44</i>&nbsp;import java.nio.file.Files;
<i>45</i>&nbsp;import java.nio.file.Path;
<i>46</i>&nbsp;import java.nio.file.Paths;
<i>47</i>&nbsp;import java.nio.file.StandardCopyOption;
<i>48</i>&nbsp;import java.text.SimpleDateFormat;
<i>49</i>&nbsp;import java.util.ArrayList;
<i>50</i>&nbsp;import java.util.Arrays;
<i>51</i>&nbsp;import java.util.Collection;
<i>52</i>&nbsp;import java.util.Collections;
<i>53</i>&nbsp;import java.util.Comparator;
<i>54</i>&nbsp;import java.util.Date;
<i>55</i>&nbsp;import java.util.HashMap;
<i>56</i>&nbsp;import java.util.HashSet;
<i>57</i>&nbsp;import java.util.Iterator;
<i>58</i>&nbsp;import java.util.LinkedHashSet;
<i>59</i>&nbsp;import java.util.List;
<i>60</i>&nbsp;import java.util.Locale;
<i>61</i>&nbsp;import java.util.Map;
<i>62</i>&nbsp;import java.util.ServiceLoader;
<i>63</i>&nbsp;import java.util.Set;
<i>64</i>&nbsp;import java.util.Optional;
<i>65</i>&nbsp;import java.util.Locale.Category;
<i>66</i>&nbsp;import java.util.concurrent.ExecutorCompletionService;
<i>67</i>&nbsp;import java.util.concurrent.ExecutorService;
<i>68</i>&nbsp;import java.util.concurrent.Executors;
<i>69</i>&nbsp;import java.util.function.Consumer;
<i>70</i>&nbsp;import java.util.stream.Collectors;
<i>71</i>&nbsp;
<i>72</i>&nbsp;import javax.imageio.ImageIO;
<i>73</i>&nbsp;import javax.script.ScriptException;
<i>74</i>&nbsp;import javax.swing.SwingUtilities;
<i>75</i>&nbsp;
<i>76</i>&nbsp;import org.controlsfx.control.action.Action;
<i>77</i>&nbsp;import org.controlsfx.control.action.ActionUtils;
<i>78</i>&nbsp;import org.slf4j.Logger;
<i>79</i>&nbsp;import org.slf4j.LoggerFactory;
<i>80</i>&nbsp;
<i>81</i>&nbsp;import javafx.application.HostServices;
<i>82</i>&nbsp;import javafx.application.Platform;
<i>83</i>&nbsp;import javafx.beans.binding.Bindings;
<i>84</i>&nbsp;import javafx.beans.binding.BooleanBinding;
<i>85</i>&nbsp;import javafx.beans.binding.StringBinding;
<i>86</i>&nbsp;import javafx.beans.property.BooleanProperty;
<i>87</i>&nbsp;import javafx.beans.property.ObjectProperty;
<i>88</i>&nbsp;import javafx.beans.property.ReadOnlyBooleanProperty;
<i>89</i>&nbsp;import javafx.beans.property.ReadOnlyObjectProperty;
<i>90</i>&nbsp;import javafx.beans.property.SimpleBooleanProperty;
<i>91</i>&nbsp;import javafx.beans.property.SimpleObjectProperty;
<i>92</i>&nbsp;import javafx.collections.FXCollections;
<i>93</i>&nbsp;import javafx.collections.ListChangeListener;
<i>94</i>&nbsp;import javafx.collections.ListChangeListener.Change;
<i>95</i>&nbsp;import javafx.collections.ObservableList;
<i>96</i>&nbsp;import javafx.embed.swing.JFXPanel;
<i>97</i>&nbsp;import javafx.embed.swing.SwingFXUtils;
<i>98</i>&nbsp;import javafx.event.ActionEvent;
<i>99</i>&nbsp;import javafx.event.Event;
<i>100</i>&nbsp;import javafx.event.EventHandler;
<i>101</i>&nbsp;import javafx.geometry.Insets;
<i>102</i>&nbsp;import javafx.geometry.Orientation;
<i>103</i>&nbsp;import javafx.geometry.Pos;
<i>104</i>&nbsp;import javafx.geometry.Rectangle2D;
<i>105</i>&nbsp;import javafx.scene.Cursor;
<i>106</i>&nbsp;import javafx.scene.Node;
<i>107</i>&nbsp;import javafx.scene.Parent;
<i>108</i>&nbsp;import javafx.scene.Scene;
<i>109</i>&nbsp;import javafx.scene.control.ButtonBar.ButtonData;
<i>110</i>&nbsp;import javafx.scene.control.ButtonType;
<i>111</i>&nbsp;import javafx.scene.control.CheckBox;
<i>112</i>&nbsp;import javafx.scene.control.CheckMenuItem;
<i>113</i>&nbsp;import javafx.scene.control.ContextMenu;
<i>114</i>&nbsp;import javafx.scene.control.Dialog;
<i>115</i>&nbsp;import javafx.scene.control.Label;
<i>116</i>&nbsp;import javafx.scene.control.ListView;
<i>117</i>&nbsp;import javafx.scene.control.Menu;
<i>118</i>&nbsp;import javafx.scene.control.MenuBar;
<i>119</i>&nbsp;import javafx.scene.control.MenuItem;
<i>120</i>&nbsp;import javafx.scene.control.RadioMenuItem;
<i>121</i>&nbsp;import javafx.scene.control.SeparatorMenuItem;
<i>122</i>&nbsp;import javafx.scene.control.SplitPane;
<i>123</i>&nbsp;import javafx.scene.control.SplitPane.Divider;
<i>124</i>&nbsp;import javafx.scene.control.Tab;
<i>125</i>&nbsp;import javafx.scene.control.TabPane;
<i>126</i>&nbsp;import javafx.scene.control.TabPane.TabClosingPolicy;
<i>127</i>&nbsp;import javafx.scene.control.TableView;
<i>128</i>&nbsp;import javafx.scene.control.TextArea;
<i>129</i>&nbsp;import javafx.scene.control.TextInputControl;
<i>130</i>&nbsp;import javafx.scene.control.TitledPane;
<i>131</i>&nbsp;import javafx.scene.control.ToggleGroup;
<i>132</i>&nbsp;import javafx.scene.control.ToolBar;
<i>133</i>&nbsp;import javafx.scene.control.TreeTableView;
<i>134</i>&nbsp;import javafx.scene.control.TreeView;
<i>135</i>&nbsp;import javafx.scene.control.Alert.AlertType;
<i>136</i>&nbsp;import javafx.scene.effect.DropShadow;
<i>137</i>&nbsp;import javafx.scene.image.Image;
<i>138</i>&nbsp;import javafx.scene.image.ImageView;
<i>139</i>&nbsp;import javafx.scene.input.KeyCode;
<i>140</i>&nbsp;import javafx.scene.input.KeyCodeCombination;
<i>141</i>&nbsp;import javafx.scene.input.KeyCombination;
<i>142</i>&nbsp;import javafx.scene.input.KeyEvent;
<i>143</i>&nbsp;import javafx.scene.input.MouseEvent;
<i>144</i>&nbsp;import javafx.scene.input.RotateEvent;
<i>145</i>&nbsp;import javafx.scene.input.ScrollEvent;
<i>146</i>&nbsp;import javafx.scene.input.ZoomEvent;
<i>147</i>&nbsp;import javafx.scene.layout.Border;
<i>148</i>&nbsp;import javafx.scene.layout.BorderPane;
<i>149</i>&nbsp;import javafx.scene.layout.BorderStroke;
<i>150</i>&nbsp;import javafx.scene.layout.BorderStrokeStyle;
<i>151</i>&nbsp;import javafx.scene.layout.Region;
<i>152</i>&nbsp;import javafx.scene.layout.StackPane;
<i>153</i>&nbsp;import javafx.scene.paint.Color;
<i>154</i>&nbsp;import javafx.scene.shape.Ellipse;
<i>155</i>&nbsp;import javafx.scene.shape.Rectangle;
<i>156</i>&nbsp;import javafx.scene.text.Font;
<i>157</i>&nbsp;import javafx.stage.Screen;
<i>158</i>&nbsp;import javafx.stage.Stage;
<i>159</i>&nbsp;import javafx.stage.WindowEvent;
<i>160</i>&nbsp;import javafx.util.Duration;
<i>161</i>&nbsp;import jfxtras.scene.menu.CirclePopupMenu;
<i>162</i>&nbsp;import qupath.lib.common.GeneralTools;
<i>163</i>&nbsp;import qupath.lib.common.ThreadTools;
<i>164</i>&nbsp;import qupath.lib.gui.ActionTools.ActionAccelerator;
<i>165</i>&nbsp;import qupath.lib.gui.ActionTools.ActionDescription;
<i>166</i>&nbsp;import qupath.lib.gui.ActionTools.ActionIcon;
<i>167</i>&nbsp;import qupath.lib.gui.commands.BrightnessContrastCommand;
<i>168</i>&nbsp;import qupath.lib.gui.commands.Commands;
<i>169</i>&nbsp;import qupath.lib.gui.commands.CountingPanelCommand;
<i>170</i>&nbsp;import qupath.lib.gui.commands.LogViewerCommand;
<i>171</i>&nbsp;import qupath.lib.gui.commands.ProjectCommands;
<i>172</i>&nbsp;import qupath.lib.gui.commands.TMACommands;
<i>173</i>&nbsp;import qupath.lib.gui.dialogs.Dialogs;
<i>174</i>&nbsp;import qupath.lib.gui.dialogs.ParameterPanelFX;
<i>175</i>&nbsp;import qupath.lib.gui.dialogs.Dialogs.DialogButton;
<i>176</i>&nbsp;import qupath.lib.gui.extensions.QuPathExtension;
<i>177</i>&nbsp;import qupath.lib.gui.images.stores.DefaultImageRegionStore;
<i>178</i>&nbsp;import qupath.lib.gui.images.stores.ImageRegionStoreFactory;
<i>179</i>&nbsp;import qupath.lib.gui.logging.LogManager;
<i>180</i>&nbsp;import qupath.lib.gui.panes.AnnotationPane;
<i>181</i>&nbsp;import qupath.lib.gui.panes.ImageDetailsPane;
<i>182</i>&nbsp;import qupath.lib.gui.panes.PathObjectHierarchyView;
<i>183</i>&nbsp;import qupath.lib.gui.panes.PreferencePane;
<i>184</i>&nbsp;import qupath.lib.gui.panes.ProjectBrowser;
<i>185</i>&nbsp;import qupath.lib.gui.panes.SelectedMeasurementTableView;
<i>186</i>&nbsp;import qupath.lib.gui.panes.WorkflowCommandLogView;
<i>187</i>&nbsp;import qupath.lib.gui.plugins.ParameterDialogWrapper;
<i>188</i>&nbsp;import qupath.lib.gui.plugins.PluginRunnerFX;
<i>189</i>&nbsp;import qupath.lib.gui.prefs.PathPrefs;
<i>190</i>&nbsp;import qupath.lib.gui.prefs.PathPrefs.ImageTypeSetting;
<i>191</i>&nbsp;import qupath.lib.gui.prefs.QuPathStyleManager;
<i>192</i>&nbsp;import qupath.lib.gui.scripting.ScriptEditor;
<i>193</i>&nbsp;import qupath.lib.gui.scripting.DefaultScriptEditor.Language;
<i>194</i>&nbsp;import qupath.lib.gui.tools.ColorToolsFX;
<i>195</i>&nbsp;import qupath.lib.gui.tools.CommandFinderTools;
<i>196</i>&nbsp;import qupath.lib.gui.tools.GuiTools;
<i>197</i>&nbsp;import qupath.lib.gui.tools.MenuTools;
<i>198</i>&nbsp;import qupath.lib.gui.tools.IconFactory.PathIcons;
<i>199</i>&nbsp;import qupath.lib.gui.viewer.DragDropFileImportListener;
<i>200</i>&nbsp;import qupath.lib.gui.viewer.OverlayOptions;
<i>201</i>&nbsp;import qupath.lib.gui.viewer.QuPathViewer;
<i>202</i>&nbsp;import qupath.lib.gui.viewer.QuPathViewerListener;
<i>203</i>&nbsp;import qupath.lib.gui.viewer.QuPathViewerPlus;
<i>204</i>&nbsp;import qupath.lib.gui.viewer.ViewerPlusDisplayOptions;
<i>205</i>&nbsp;import qupath.lib.gui.viewer.OverlayOptions.DetectionDisplayMode;
<i>206</i>&nbsp;import qupath.lib.gui.viewer.tools.PathTool;
<i>207</i>&nbsp;import qupath.lib.gui.viewer.tools.PathTools;
<i>208</i>&nbsp;import qupath.lib.images.ImageData;
<i>209</i>&nbsp;import qupath.lib.images.ImageData.ImageType;
<i>210</i>&nbsp;import qupath.lib.images.servers.ImageServer;
<i>211</i>&nbsp;import qupath.lib.images.servers.ImageServerBuilder;
<i>212</i>&nbsp;import qupath.lib.images.servers.ImageServerBuilder.ServerBuilder;
<i>213</i>&nbsp;import qupath.lib.images.servers.ImageServerBuilder.UriImageSupport;
<i>214</i>&nbsp;import qupath.lib.images.servers.ImageServerProvider;
<i>215</i>&nbsp;import qupath.lib.images.servers.ImageServers;
<i>216</i>&nbsp;import qupath.lib.images.servers.ServerTools;
<i>217</i>&nbsp;import qupath.lib.io.PathIO;
<i>218</i>&nbsp;import qupath.lib.objects.PathAnnotationObject;
<i>219</i>&nbsp;import qupath.lib.objects.PathObject;
<i>220</i>&nbsp;import qupath.lib.objects.PathObjectTools;
<i>221</i>&nbsp;import qupath.lib.objects.PathObjects;
<i>222</i>&nbsp;import qupath.lib.objects.TMACoreObject;
<i>223</i>&nbsp;import qupath.lib.objects.classes.PathClass;
<i>224</i>&nbsp;import qupath.lib.objects.classes.PathClassFactory;
<i>225</i>&nbsp;import qupath.lib.objects.hierarchy.PathObjectHierarchy;
<i>226</i>&nbsp;import qupath.lib.objects.hierarchy.TMAGrid;
<i>227</i>&nbsp;import qupath.lib.plugins.AbstractPluginRunner;
<i>228</i>&nbsp;import qupath.lib.plugins.PathInteractivePlugin;
<i>229</i>&nbsp;import qupath.lib.plugins.PathPlugin;
<i>230</i>&nbsp;import qupath.lib.plugins.parameters.ParameterList;
<i>231</i>&nbsp;import qupath.lib.projects.Project;
<i>232</i>&nbsp;import qupath.lib.projects.ProjectIO;
<i>233</i>&nbsp;import qupath.lib.projects.ProjectImageEntry;
<i>234</i>&nbsp;import qupath.lib.projects.Projects;
<i>235</i>&nbsp;import qupath.lib.roi.RoiTools;
<i>236</i>&nbsp;import qupath.lib.roi.interfaces.ROI;
<i>237</i>&nbsp;import qupath.lib.gui.scripting.DefaultScriptEditor;
<i>238</i>&nbsp;
<i>239</i>&nbsp;
<i>240</i>&nbsp;
<i>241</i>&nbsp;/**
<i>242</i>&nbsp; * Main GUI for QuPath, written using JavaFX.
<i>243</i>&nbsp; * 
<i>244</i>&nbsp; * @author Pete Bankhead
<i>245</i>&nbsp; *
<i>246</i>&nbsp; */
<i>247</i>&nbsp;public class QuPathGUI {
<i>248</i>&nbsp;	
<b class="fc"><i>249</i>&nbsp;	private final static Logger logger = LoggerFactory.getLogger(QuPathGUI.class);</b>
<i>250</i>&nbsp;	
<i>251</i>&nbsp;	private static QuPathGUI instance;
<i>252</i>&nbsp;	
<b class="fc"><i>253</i>&nbsp;	private ScriptEditor scriptEditor = null;</b>
<i>254</i>&nbsp;	
<i>255</i>&nbsp;	// For development... don&#39;t run update check if running from a directory (rather than a Jar)
<b class="fc"><i>256</i>&nbsp;	private boolean disableAutoUpdateCheck = new File(qupath.lib.gui.QuPathGUI.class.getProtectionDomain().getCodeSource().getLocation().getFile()).isDirectory();</b>
<i>257</i>&nbsp;	
<b class="fc"><i>258</i>&nbsp;	private static ExtensionClassLoader extensionClassLoader = new ExtensionClassLoader();</b>
<b class="fc"><i>259</i>&nbsp;	private ServiceLoader&lt;QuPathExtension&gt; extensionLoader = ServiceLoader.load(QuPathExtension.class, extensionClassLoader);</b>
<i>260</i>&nbsp;	
<b class="fc"><i>261</i>&nbsp;	private ObjectProperty&lt;PathTool&gt; selectedToolProperty = new SimpleObjectProperty&lt;&gt;(PathTools.MOVE);</b>
<b class="fc"><i>262</i>&nbsp;	private ObservableList&lt;PathTool&gt; tools = FXCollections.observableArrayList(</b>
<i>263</i>&nbsp;			PathTools.MOVE, PathTools.RECTANGLE, PathTools.ELLIPSE, PathTools.LINE, PathTools.POLYGON, PathTools.POLYLINE, PathTools.BRUSH, PathTools.POINTS
<i>264</i>&nbsp;			);
<i>265</i>&nbsp;	
<b class="fc"><i>266</i>&nbsp;	private BooleanProperty selectedToolLocked = new SimpleBooleanProperty(false);</b>
<i>267</i>&nbsp;	
<i>268</i>&nbsp;	// ExecutorServices for single &amp; multiple threads
<b class="fc"><i>269</i>&nbsp;	private Map&lt;Object, ExecutorService&gt; mapSingleThreadPools = new HashMap&lt;&gt;();</b>
<b class="fc"><i>270</i>&nbsp;	private ExecutorService poolMultipleThreads = Executors.newFixedThreadPool(Math.max(2, Runtime.getRuntime().availableProcessors()), ThreadTools.createThreadFactory(&quot;qupath-shared-&quot;, false));	</b>
<i>271</i>&nbsp;	
<b class="fc"><i>272</i>&nbsp;	private Map&lt;PathTool, Action&gt; toolActions = new HashMap&lt;&gt;();</b>
<i>273</i>&nbsp;	
<i>274</i>&nbsp;	/**
<i>275</i>&nbsp;	 * Preferred size for toolbar icons.
<i>276</i>&nbsp;	 */
<i>277</i>&nbsp;	final public static int TOOLBAR_ICON_SIZE = 16;
<i>278</i>&nbsp;
<i>279</i>&nbsp;	MultiviewManager viewerManager;
<i>280</i>&nbsp;	
<b class="fc"><i>281</i>&nbsp;	private ObjectProperty&lt;Project&lt;BufferedImage&gt;&gt; projectProperty = new SimpleObjectProperty&lt;&gt;();</b>
<i>282</i>&nbsp;	
<i>283</i>&nbsp;	private ProjectBrowser projectBrowser;
<i>284</i>&nbsp;	
<i>285</i>&nbsp;	/**
<i>286</i>&nbsp;	 * Preference panel, which may be used by extensions to add in their on preferences if needed
<i>287</i>&nbsp;	 */
<i>288</i>&nbsp;	private PreferencePane prefsPane;
<i>289</i>&nbsp;	
<i>290</i>&nbsp;	/**
<i>291</i>&nbsp;	 * The current ImageData in the current QuPathViewer
<i>292</i>&nbsp;	 */
<b class="fc"><i>293</i>&nbsp;	private ObjectProperty&lt;ImageData&lt;BufferedImage&gt;&gt; imageDataProperty = new SimpleObjectProperty&lt;&gt;();</b>
<i>294</i>&nbsp;	
<i>295</i>&nbsp;	// Initializing the MenuBar here caused some major trouble (including segfaults) in OSX...
<i>296</i>&nbsp;	private MenuBar menuBar;
<i>297</i>&nbsp;
<b class="fc"><i>298</i>&nbsp;	private BooleanProperty zoomToFit = new SimpleBooleanProperty(false);</b>
<i>299</i>&nbsp;	
<i>300</i>&nbsp;	private BorderPane pane; // Main component, to hold toolbar &amp; splitpane
<b class="fc"><i>301</i>&nbsp;	private TabPane analysisPanel = new TabPane();</b>
<i>302</i>&nbsp;	private Region mainViewerPane;
<i>303</i>&nbsp;	
<b class="fc"><i>304</i>&nbsp;	private ViewerPlusDisplayOptions viewerDisplayOptions = new ViewerPlusDisplayOptions();</b>
<i>305</i>&nbsp;	
<i>306</i>&nbsp;	/**
<i>307</i>&nbsp;	 * Default options used for viewers
<i>308</i>&nbsp;	 */
<b class="fc"><i>309</i>&nbsp;	private OverlayOptions overlayOptions = new OverlayOptions();</b>
<i>310</i>&nbsp;	
<i>311</i>&nbsp;	/**
<i>312</i>&nbsp;	 * Default region store used by viewers for tile caching and repainting
<i>313</i>&nbsp;	 */
<i>314</i>&nbsp;	private DefaultImageRegionStore imageRegionStore;
<i>315</i>&nbsp;
<i>316</i>&nbsp;	private ToolBarComponent toolbar; // Top component
<b class="fc"><i>317</i>&nbsp;	private SplitPane splitPane = new SplitPane(); // Main component</b>
<i>318</i>&nbsp;
<b class="fc"><i>319</i>&nbsp;	private ObservableList&lt;PathClass&gt; availablePathClasses = null;</b>
<i>320</i>&nbsp;	
<i>321</i>&nbsp;	private Stage stage;
<i>322</i>&nbsp;	
<b class="fc"><i>323</i>&nbsp;	private boolean isStandalone = false;</b>
<i>324</i>&nbsp;	private ScriptMenuLoader sharedScriptMenuLoader;
<i>325</i>&nbsp;	
<b class="fc"><i>326</i>&nbsp;	private DragDropFileImportListener dragAndDrop = new DragDropFileImportListener(this);</b>
<i>327</i>&nbsp;	
<i>328</i>&nbsp;	private UndoRedoManager undoRedoManager;
<i>329</i>&nbsp;	
<i>330</i>&nbsp;	private HostServices hostServices;
<i>331</i>&nbsp;	
<i>332</i>&nbsp;	/**
<i>333</i>&nbsp;	 * Keystrokes can be lost on macOS... so ensure these are handled
<i>334</i>&nbsp;	 */
<b class="fc"><i>335</i>&nbsp;	private Map&lt;KeyCombination, Action&gt; comboMap = new HashMap&lt;&gt;();</b>
<i>336</i>&nbsp;	
<b class="fc"><i>337</i>&nbsp;	private ObjectProperty&lt;QuPathViewer&gt; viewerProperty = new SimpleObjectProperty&lt;&gt;();</b>
<i>338</i>&nbsp;	
<b class="fc"><i>339</i>&nbsp;	private BooleanBinding noProject = projectProperty.isNull();</b>
<b class="fc"><i>340</i>&nbsp;	private BooleanBinding noViewer = viewerProperty.isNull();</b>
<b class="fc"><i>341</i>&nbsp;	private BooleanBinding noImageData = imageDataProperty.isNull();</b>
<i>342</i>&nbsp;	
<i>343</i>&nbsp;	
<b class="fc"><i>344</i>&nbsp;	private BooleanProperty scriptRunning = new SimpleBooleanProperty(false);</b>
<i>345</i>&nbsp;	
<i>346</i>&nbsp;	
<i>347</i>&nbsp;	/**
<i>348</i>&nbsp;	 * Create an {@link Action} that depends upon an {@link ImageData}.
<i>349</i>&nbsp;	 * When the action is invoked, it will be passed the current {@link ImageData} as a parameter.
<i>350</i>&nbsp;	 * The action will also be disabled if no image data is present.
<i>351</i>&nbsp;	 * @param command the command to run
<i>352</i>&nbsp;	 * @return an {@link Action} with appropriate properties set
<i>353</i>&nbsp;	 */
<i>354</i>&nbsp;	public Action createImageDataAction(Consumer&lt;ImageData&lt;BufferedImage&gt;&gt; command) {
<b class="fc"><i>355</i>&nbsp;		var action = new Action(e -&gt; {</b>
<b class="nc"><i>356</i>&nbsp;			var imageData = getImageData();</b>
<b class="nc"><i>357</i>&nbsp;			if (imageData == null)</b>
<b class="nc"><i>358</i>&nbsp;				Dialogs.showNoImageError(&quot;No image&quot;);</b>
<i>359</i>&nbsp;			else
<b class="nc"><i>360</i>&nbsp;				command.accept(imageData);</b>
<b class="nc"><i>361</i>&nbsp;		});</b>
<b class="fc"><i>362</i>&nbsp;		action.disabledProperty().bind(noImageData);</b>
<b class="fc"><i>363</i>&nbsp;		return action;</b>
<i>364</i>&nbsp;	}
<i>365</i>&nbsp;	
<i>366</i>&nbsp;	/**
<i>367</i>&nbsp;	 * Create an {@link Action} that depends upon an {@link QuPathViewer}.
<i>368</i>&nbsp;	 * When the action is invoked, it will be passed the current {@link QuPathViewer} as a parameter.
<i>369</i>&nbsp;	 * The action will also be disabled if no viewer is present.
<i>370</i>&nbsp;	 * @param command the command to run
<i>371</i>&nbsp;	 * @return an {@link Action} with appropriate properties set
<i>372</i>&nbsp;	 */
<i>373</i>&nbsp;	Action createViewerAction(Consumer&lt;QuPathViewer&gt; command) {
<b class="fc"><i>374</i>&nbsp;		var action = new Action(e -&gt; {</b>
<b class="nc"><i>375</i>&nbsp;			var viewer = getViewer();</b>
<b class="nc"><i>376</i>&nbsp;			if (viewer == null)</b>
<b class="nc"><i>377</i>&nbsp;				Dialogs.showErrorMessage(&quot;No viewer&quot;, &quot;This command required an active viewer!&quot;);</b>
<i>378</i>&nbsp;			else
<b class="nc"><i>379</i>&nbsp;				command.accept(viewer);</b>
<b class="nc"><i>380</i>&nbsp;		});</b>
<b class="fc"><i>381</i>&nbsp;		action.disabledProperty().bind(noViewer);</b>
<b class="fc"><i>382</i>&nbsp;		return action;</b>
<i>383</i>&nbsp;	}
<i>384</i>&nbsp;	
<i>385</i>&nbsp;	// TODO: Remove this command whenever annotations can be applied more easily
<i>386</i>&nbsp;	private Action createImageDataAction(Consumer&lt;ImageData&lt;BufferedImage&gt;&gt; command, String name) {
<b class="fc"><i>387</i>&nbsp;		var action = createImageDataAction(command);</b>
<b class="fc"><i>388</i>&nbsp;		action.setText(name);</b>
<b class="fc"><i>389</i>&nbsp;		return action;</b>
<i>390</i>&nbsp;	}
<i>391</i>&nbsp;	
<i>392</i>&nbsp;	/**
<i>393</i>&nbsp;	 * Create an {@link Action} that depends upon a {@link Project}.
<i>394</i>&nbsp;	 * When the action is invoked, it will be passed the current {@link Project} as a parameter.
<i>395</i>&nbsp;	 * The action will also be disabled if no image data is present.
<i>396</i>&nbsp;	 * @param command the command to run
<i>397</i>&nbsp;	 * @return an {@link Action} with appropriate properties set
<i>398</i>&nbsp;	 */
<i>399</i>&nbsp;	public Action createProjectAction(Consumer&lt;Project&lt;BufferedImage&gt;&gt; command) {
<b class="fc"><i>400</i>&nbsp;		var action = new Action(e -&gt; {</b>
<b class="nc"><i>401</i>&nbsp;			var project = getProject();</b>
<b class="nc"><i>402</i>&nbsp;			if (project == null)</b>
<b class="nc"><i>403</i>&nbsp;				Dialogs.showNoProjectError(&quot;No project&quot;);</b>
<i>404</i>&nbsp;			else
<b class="nc"><i>405</i>&nbsp;				command.accept(project);</b>
<b class="nc"><i>406</i>&nbsp;		});</b>
<b class="fc"><i>407</i>&nbsp;		action.disabledProperty().bind(noProject);</b>
<b class="fc"><i>408</i>&nbsp;		return action;</b>
<i>409</i>&nbsp;	}
<i>410</i>&nbsp;	
<i>411</i>&nbsp;	/**
<i>412</i>&nbsp;	 * Install the specified actions. It is assumed that these have been configured via {@link ActionTools}, 
<i>413</i>&nbsp;	 * and therefore have sufficient information associated with them (including a menu path).
<i>414</i>&nbsp;	 * @param actions
<i>415</i>&nbsp;	 */
<i>416</i>&nbsp;	public void installActions(Collection&lt;? extends Action&gt; actions) {
<b class="fc"><i>417</i>&nbsp;		installActions(getMenuBar().getMenus(), actions);</b>
<b class="fc"><i>418</i>&nbsp;		actions.stream().forEach(a -&gt; registerAccelerator(a));</b>
<b class="fc"><i>419</i>&nbsp;	}</b>
<i>420</i>&nbsp;	
<i>421</i>&nbsp;	private static void installActions(List&lt;Menu&gt; menus, Collection&lt;? extends Action&gt; actions) {
<i>422</i>&nbsp;		
<b class="fc"><i>423</i>&nbsp;		var menuMap = new HashMap&lt;String, Menu&gt;();</b>
<i>424</i>&nbsp;		
<b class="fc"><i>425</i>&nbsp;		for (var action : actions) {</b>
<b class="fc"><i>426</i>&nbsp;			var menuString = action.getProperties().get(&quot;MENU&quot;);</b>
<b class="fc"><i>427</i>&nbsp;			if (menuString instanceof String) {</b>
<b class="fc"><i>428</i>&nbsp;				var menu = menuMap.computeIfAbsent((String)menuString, s -&gt; MenuTools.getMenu(menus, s, true));</b>
<b class="fc"><i>429</i>&nbsp;				var items = menu.getItems();</b>
<b class="fc"><i>430</i>&nbsp;				var name = action.getText();</b>
<b class="fc"><i>431</i>&nbsp;				var newItem = ActionTools.createMenuItem(action);</b>
<b class="fc"><i>432</i>&nbsp;				if (!(newItem instanceof SeparatorMenuItem)) {</b>
<b class="fc"><i>433</i>&nbsp;					var existing = items.stream().filter(m -&gt; m.getText() != null &amp;&amp; m.getText().equals(name)).findFirst().orElse(null);</b>
<b class="fc"><i>434</i>&nbsp;					if (existing != null) {</b>
<b class="nc"><i>435</i>&nbsp;						logger.warn(&quot;Existing menu item found with name &#39;{}&#39; - this will be replaced&quot;, name);</b>
<b class="nc"><i>436</i>&nbsp;						items.set(items.indexOf(existing), newItem);</b>
<b class="nc"><i>437</i>&nbsp;						continue;</b>
<i>438</i>&nbsp;					}
<b class="fc"><i>439</i>&nbsp;				} else if (items.isEmpty()) {</b>
<i>440</i>&nbsp;					// Don&#39;t add a separator if there is nothing to separate
<b class="fc"><i>441</i>&nbsp;					continue;</b>
<i>442</i>&nbsp;				}
<b class="fc"><i>443</i>&nbsp;				items.add(newItem);</b>
<b class="fc"><i>444</i>&nbsp;			} else {</b>
<b class="nc"><i>445</i>&nbsp;				logger.debug(&quot;Found command without associated menu: {}&quot;, action);</b>
<i>446</i>&nbsp;			}
<b class="fc"><i>447</i>&nbsp;		}</b>
<b class="fc"><i>448</i>&nbsp;	}</b>
<i>449</i>&nbsp;	
<i>450</i>&nbsp;	
<i>451</i>&nbsp;	/**
<i>452</i>&nbsp;	 * Default actions associated with a specific QuPath instance.
<i>453</i>&nbsp;	 * These are useful for generating toolbars and context menus, ensuring that the same actions are used consistently.
<i>454</i>&nbsp;	 */
<i>455</i>&nbsp;	public class DefaultActions {
<i>456</i>&nbsp;		
<i>457</i>&nbsp;		// Zoom actions
<i>458</i>&nbsp;		/**
<i>459</i>&nbsp;		 * Apply &#39;zoom-to-fit&#39; setting to all viewers
<i>460</i>&nbsp;		 */
<b class="fc"><i>461</i>&nbsp;		@ActionIcon(PathIcons.ZOOM_TO_FIT)</b>
<b class="fc"><i>462</i>&nbsp;		public final Action ZOOM_TO_FIT = ActionTools.createSelectableAction(zoomToFit, &quot;Zoom to fit&quot;);</b>
<i>463</i>&nbsp;		
<i>464</i>&nbsp;		// Tool actions
<i>465</i>&nbsp;		/**
<i>466</i>&nbsp;		 * Move tool action
<i>467</i>&nbsp;		 */
<b class="fc"><i>468</i>&nbsp;		@ActionAccelerator(&quot;m&quot;)</b>
<i>469</i>&nbsp;		@ActionDescription(&quot;Move tool, both for moving around the viewer (panning) and moving objects (translation).&quot;)
<b class="fc"><i>470</i>&nbsp;		public final Action MOVE_TOOL = getToolAction(PathTools.MOVE);</b>
<i>471</i>&nbsp;		/**
<i>472</i>&nbsp;		 * Rectangle tool action
<i>473</i>&nbsp;		 */
<b class="fc"><i>474</i>&nbsp;		@ActionAccelerator(&quot;r&quot;)</b>
<i>475</i>&nbsp;		@ActionDescription(&quot;Click and drag to draw a rectangle annotation. Hold down &#39;Shift&#39; to constrain shape to be a square.&quot;)
<b class="fc"><i>476</i>&nbsp;		public final Action RECTANGLE_TOOL = getToolAction(PathTools.RECTANGLE);</b>
<i>477</i>&nbsp;		/**
<i>478</i>&nbsp;		 * Ellipse tool action
<i>479</i>&nbsp;		 */
<b class="fc"><i>480</i>&nbsp;		@ActionAccelerator(&quot;o&quot;)</b>
<i>481</i>&nbsp;		@ActionDescription(&quot;Click and drag to draw an ellipse annotation. Hold down &#39;Shift&#39; to constrain shape to be a circle.&quot;)
<b class="fc"><i>482</i>&nbsp;		public final Action ELLIPSE_TOOL = getToolAction(PathTools.ELLIPSE);</b>
<i>483</i>&nbsp;		/**
<i>484</i>&nbsp;		 * Polygon tool action
<i>485</i>&nbsp;		 */
<b class="fc"><i>486</i>&nbsp;		@ActionAccelerator(&quot;p&quot;)</b>
<i>487</i>&nbsp;		@ActionDescription(&quot;Create a closed polygon annotation, either by clicking individual points (with double-click to end) or clicking and dragging.&quot;)
<b class="fc"><i>488</i>&nbsp;		public final Action POLYGON_TOOL = getToolAction(PathTools.POLYGON);</b>
<i>489</i>&nbsp;		/**
<i>490</i>&nbsp;		 * Polyline tool action
<i>491</i>&nbsp;		 */
<b class="fc"><i>492</i>&nbsp;		@ActionAccelerator(&quot;v&quot;)</b>
<i>493</i>&nbsp;		@ActionDescription(&quot;Create a polyline annotation, either by clicking individual points (with double-click to end) or clicking and dragging.&quot;)
<b class="fc"><i>494</i>&nbsp;		public final Action POLYLINE_TOOL = getToolAction(PathTools.POLYLINE);</b>
<i>495</i>&nbsp;		/**
<i>496</i>&nbsp;		 * Brush tool action
<i>497</i>&nbsp;		 */
<b class="fc"><i>498</i>&nbsp;		@ActionAccelerator(&quot;b&quot;)</b>
<i>499</i>&nbsp;		@ActionDescription(&quot;Click and drag to paint with a brush. &quot;
<i>500</i>&nbsp;				+ &quot;By default, the size of the region being drawn depends upon the zoom level in the viewer.&quot;)
<b class="fc"><i>501</i>&nbsp;		public final Action BRUSH_TOOL = getToolAction(PathTools.BRUSH);</b>
<i>502</i>&nbsp;		/**
<i>503</i>&nbsp;		 * Line tool action
<i>504</i>&nbsp;		 */
<b class="fc"><i>505</i>&nbsp;		@ActionAccelerator(&quot;l&quot;)</b>
<i>506</i>&nbsp;		@ActionDescription(&quot;Click and drag to draw a line annotation.&quot;)
<b class="fc"><i>507</i>&nbsp;		public final Action LINE_TOOL = getToolAction(PathTools.LINE);</b>
<i>508</i>&nbsp;		/**
<i>509</i>&nbsp;		 * Points/counting tool action
<i>510</i>&nbsp;		 */
<b class="fc"><i>511</i>&nbsp;		@ActionAccelerator(&quot;.&quot;)</b>
<i>512</i>&nbsp;		@ActionDescription(&quot;Click to add points to an annotation.&quot;)
<b class="fc"><i>513</i>&nbsp;		public final Action POINTS_TOOL = getToolAction(PathTools.POINTS);</b>
<i>514</i>&nbsp;		
<i>515</i>&nbsp;		/**
<i>516</i>&nbsp;		 * Toggle &#39;selection mode&#39; on/off for all drawing tools.
<i>517</i>&nbsp;		 */
<b class="fc"><i>518</i>&nbsp;		@ActionAccelerator(&quot;shortcut+alt+s&quot;)</b>
<i>519</i>&nbsp;		@ActionIcon(PathIcons.SELECTION_MODE)
<b class="fc"><i>520</i>&nbsp;		public final Action SELECTION_MODE = ActionTools.createSelectableAction(PathPrefs.selectionModeProperty(), &quot;Selection mode&quot;);</b>
<i>521</i>&nbsp;		
<i>522</i>&nbsp;		// Toolbar actions
<i>523</i>&nbsp;		/**
<i>524</i>&nbsp;		 * Show the brightness/contrast dialog.
<i>525</i>&nbsp;		 */
<b class="fc"><i>526</i>&nbsp;		@ActionIcon(PathIcons.CONTRAST)</b>
<i>527</i>&nbsp;		@ActionAccelerator(&quot;shift+c&quot;)
<b class="fc"><i>528</i>&nbsp;		public final Action BRIGHTNESS_CONTRAST = ActionTools.createAction(new BrightnessContrastCommand(QuPathGUI.this), &quot;Brightness/Contrast&quot;);</b>
<i>529</i>&nbsp;		
<i>530</i>&nbsp;		/**
<i>531</i>&nbsp;		 * Toggle the image overview display on the viewers.
<i>532</i>&nbsp;		 */
<b class="fc"><i>533</i>&nbsp;		@ActionIcon(PathIcons.OVERVIEW)</b>
<b class="fc"><i>534</i>&nbsp;		public final Action SHOW_OVERVIEW = ActionTools.createSelectableAction(viewerDisplayOptions.showOverviewProperty(), &quot;Show slide overview&quot;);</b>
<i>535</i>&nbsp;		/**
<i>536</i>&nbsp;		 * Toggle the cursor location display on the viewers.
<i>537</i>&nbsp;		 */
<b class="fc"><i>538</i>&nbsp;		@ActionIcon(PathIcons.LOCATION)</b>
<b class="fc"><i>539</i>&nbsp;		public final Action SHOW_LOCATION = ActionTools.createSelectableAction(viewerDisplayOptions.showLocationProperty(), &quot;Show cursor location&quot;);</b>
<i>540</i>&nbsp;		/**
<i>541</i>&nbsp;		 * Toggle the scalebar display on the viewers.
<i>542</i>&nbsp;		 */
<b class="fc"><i>543</i>&nbsp;		@ActionIcon(PathIcons.SHOW_SCALEBAR)</b>
<b class="fc"><i>544</i>&nbsp;		public final Action SHOW_SCALEBAR = ActionTools.createSelectableAction(viewerDisplayOptions.showScalebarProperty(), &quot;Show scalebar&quot;);</b>
<i>545</i>&nbsp;		/**
<i>546</i>&nbsp;		 * Toggle the counting grid display on the viewers.
<i>547</i>&nbsp;		 */
<b class="fc"><i>548</i>&nbsp;		@ActionIcon(PathIcons.GRID)</b>
<i>549</i>&nbsp;		@ActionAccelerator(&quot;shift+g&quot;)
<b class="fc"><i>550</i>&nbsp;		public final Action SHOW_GRID = ActionTools.createSelectableAction(overlayOptions.showGridProperty(), &quot;Show grid&quot;);</b>
<i>551</i>&nbsp;		/**
<i>552</i>&nbsp;		 * Prompt to set the spacing for the counting grid.
<i>553</i>&nbsp;		 */
<b class="fc"><i>554</i>&nbsp;		public final Action GRID_SPACING = ActionTools.createAction(() -&gt; Commands.promptToSetGridLineSpacing(overlayOptions), &quot;Set grid spacing&quot;);</b>
<i>555</i>&nbsp;		
<i>556</i>&nbsp;		/**
<i>557</i>&nbsp;		 * Show the counting tool dialog. By default, this is connected to setting the points tool to active.
<i>558</i>&nbsp;		 */
<b class="fc"><i>559</i>&nbsp;		public final Action COUNTING_PANEL = ActionTools.createAction(new CountingPanelCommand(QuPathGUI.this), &quot;Counting tool&quot;, PathTools.POINTS.getIcon(), null);</b>
<i>560</i>&nbsp;
<i>561</i>&nbsp;		/**
<i>562</i>&nbsp;		 * Toggle the pixel classification overlay visibility on the viewers.
<i>563</i>&nbsp;		 */
<b class="fc"><i>564</i>&nbsp;		@ActionIcon(PathIcons.PIXEL_CLASSIFICATION)</b>
<i>565</i>&nbsp;		@ActionAccelerator(&quot;c&quot;)
<b class="fc"><i>566</i>&nbsp;		public final Action SHOW_PIXEL_CLASSIFICATION = ActionTools.createSelectableAction(overlayOptions.showPixelClassificationProperty(), &quot;Show pixel classification&quot;);</b>
<i>567</i>&nbsp;			
<i>568</i>&nbsp;		// TMA actions
<i>569</i>&nbsp;		/**
<i>570</i>&nbsp;		 * Add a note to any selected TMA core.
<i>571</i>&nbsp;		 */
<b class="fc"><i>572</i>&nbsp;		private final Action TMA_ADD_NOTE = createImageDataAction(imageData -&gt; TMACommands.promptToAddNoteToSelectedCores(imageData), &quot;Add TMA note&quot;);</b>
<i>573</i>&nbsp;		
<i>574</i>&nbsp;		// Overlay options actions
<i>575</i>&nbsp;		/**
<i>576</i>&nbsp;		 * Request that cells are displayed using their boundary ROI only.
<i>577</i>&nbsp;		 */
<b class="fc"><i>578</i>&nbsp;		@ActionIcon(PathIcons.CELL_ONLY)</b>
<b class="fc"><i>579</i>&nbsp;		public final Action SHOW_CELL_BOUNDARIES = createSelectableCommandAction(new SelectableItem&lt;&gt;(overlayOptions.detectionDisplayModeProperty(), DetectionDisplayMode.BOUNDARIES_ONLY), &quot;Cell boundaries only&quot;);</b>
<i>580</i>&nbsp;		/**
<i>581</i>&nbsp;		 * Request that cells are displayed using their boundary ROI only.
<i>582</i>&nbsp;		 */
<b class="fc"><i>583</i>&nbsp;		@ActionIcon(PathIcons.NUCLEI_ONLY)</b>
<b class="fc"><i>584</i>&nbsp;		public final Action SHOW_CELL_NUCLEI = createSelectableCommandAction(new SelectableItem&lt;&gt;(overlayOptions.detectionDisplayModeProperty(), DetectionDisplayMode.NUCLEI_ONLY), &quot;Nuclei only&quot;);</b>
<i>585</i>&nbsp;		/**
<i>586</i>&nbsp;		 * Request that cells are displayed using both cell and nucleus ROIs.
<i>587</i>&nbsp;		 */
<b class="fc"><i>588</i>&nbsp;		@ActionIcon(PathIcons.CELL_NUCLEI_BOTH)</b>
<b class="fc"><i>589</i>&nbsp;		public final Action SHOW_CELL_BOUNDARIES_AND_NUCLEI = createSelectableCommandAction(new SelectableItem&lt;&gt;(overlayOptions.detectionDisplayModeProperty(), DetectionDisplayMode.NUCLEI_AND_BOUNDARIES), &quot;Nuclei &amp; cell boundaries&quot;);</b>
<i>590</i>&nbsp;		/**
<i>591</i>&nbsp;		 * Request that cells are displayed using their centroids only.
<i>592</i>&nbsp;		 */
<b class="fc"><i>593</i>&nbsp;		@ActionIcon(PathIcons.CENTROIDS_ONLY)</b>
<b class="fc"><i>594</i>&nbsp;		public final Action SHOW_CELL_CENTROIDS = createSelectableCommandAction(new SelectableItem&lt;&gt;(overlayOptions.detectionDisplayModeProperty(), DetectionDisplayMode.CENTROIDS), &quot;Centroids only&quot;);</b>
<i>595</i>&nbsp;
<i>596</i>&nbsp;		/**
<i>597</i>&nbsp;		 * Toggle the display of annotations.
<i>598</i>&nbsp;		 */
<b class="fc"><i>599</i>&nbsp;		@ActionIcon(PathIcons.ANNOTATIONS)</b>
<i>600</i>&nbsp;		@ActionAccelerator(&quot;a&quot;)
<b class="fc"><i>601</i>&nbsp;		public final Action SHOW_ANNOTATIONS = ActionTools.createSelectableAction(overlayOptions.showAnnotationsProperty(), &quot;Show annotations&quot;);</b>
<i>602</i>&nbsp;		
<i>603</i>&nbsp;		/**
<i>604</i>&nbsp;		 * Toggle the display of annotation names.
<i>605</i>&nbsp;		 */
<b class="fc"><i>606</i>&nbsp;		@ActionAccelerator(&quot;n&quot;)</b>
<b class="fc"><i>607</i>&nbsp;		public final Action SHOW_NAMES = ActionTools.createSelectableAction(overlayOptions.showNamesProperty(), &quot;Show names&quot;);</b>
<i>608</i>&nbsp;		
<i>609</i>&nbsp;		/**
<i>610</i>&nbsp;		 * Display annotations filled in.
<i>611</i>&nbsp;		 */
<b class="fc"><i>612</i>&nbsp;		@ActionIcon(PathIcons.ANNOTATIONS_FILL)</b>
<i>613</i>&nbsp;		@ActionAccelerator(&quot;shift+f&quot;)
<b class="fc"><i>614</i>&nbsp;		public final Action FILL_ANNOTATIONS = ActionTools.createSelectableAction(overlayOptions.fillAnnotationsProperty(), &quot;Fill annotations&quot;);	</b>
<i>615</i>&nbsp;		
<i>616</i>&nbsp;		/**
<i>617</i>&nbsp;		 * Toggle the display of TMA cores.
<i>618</i>&nbsp;		 */
<b class="fc"><i>619</i>&nbsp;		@ActionIcon(PathIcons.TMA_GRID)</b>
<i>620</i>&nbsp;		@ActionAccelerator(&quot;g&quot;)
<b class="fc"><i>621</i>&nbsp;		public final Action SHOW_TMA_GRID = ActionTools.createSelectableAction(overlayOptions.showTMAGridProperty(), &quot;Show TMA grid&quot;);</b>
<i>622</i>&nbsp;		/**
<i>623</i>&nbsp;		 * Toggle the display of TMA grid labels.
<i>624</i>&nbsp;		 */
<b class="fc"><i>625</i>&nbsp;		public final Action SHOW_TMA_GRID_LABELS = ActionTools.createSelectableAction(overlayOptions.showTMACoreLabelsProperty(), &quot;Show TMA grid labels&quot;);</b>
<i>626</i>&nbsp;		
<i>627</i>&nbsp;		/**
<i>628</i>&nbsp;		 * Toggle the display of detections.
<i>629</i>&nbsp;		 */
<b class="fc"><i>630</i>&nbsp;		@ActionIcon(PathIcons.DETECTIONS)</b>
<i>631</i>&nbsp;		@ActionAccelerator(&quot;d&quot;)
<b class="fc"><i>632</i>&nbsp;		public final Action SHOW_DETECTIONS = ActionTools.createSelectableAction(overlayOptions.showDetectionsProperty(), &quot;Show detections&quot;);</b>
<i>633</i>&nbsp;		
<i>634</i>&nbsp;		/**
<i>635</i>&nbsp;		 * Display detections filled in.
<i>636</i>&nbsp;		 */
<b class="fc"><i>637</i>&nbsp;		@ActionIcon(PathIcons.DETECTIONS_FILL)</b>
<i>638</i>&nbsp;		@ActionAccelerator(&quot;f&quot;)
<b class="fc"><i>639</i>&nbsp;		public final Action FILL_DETECTIONS = ActionTools.createSelectableAction(overlayOptions.fillDetectionsProperty(), &quot;Fill detections&quot;);	</b>
<i>640</i>&nbsp;		/**
<i>641</i>&nbsp;		 * Display the convex hull of point ROIs.
<i>642</i>&nbsp;		 */
<b class="fc"><i>643</i>&nbsp;		public final Action CONVEX_POINTS = ActionTools.createSelectableAction(PathPrefs.showPointHullsProperty(), &quot;Show point convex hull&quot;);</b>
<i>644</i>&nbsp;		
<i>645</i>&nbsp;		// Viewer actions
<i>646</i>&nbsp;		/**
<i>647</i>&nbsp;		 * Toggle the synchronization of multiple viewers.
<i>648</i>&nbsp;		 */
<b class="fc"><i>649</i>&nbsp;		@ActionAccelerator(&quot;shortcut+alt+s&quot;)</b>
<b class="fc"><i>650</i>&nbsp;		public final Action TOGGLE_SYNCHRONIZE_VIEWERS = ActionTools.createSelectableAction(viewerManager.synchronizeViewersProperty(), &quot;Synchronize viewers&quot;);</b>
<i>651</i>&nbsp;		/**
<i>652</i>&nbsp;		 * Match the resolution of all open viewers.
<i>653</i>&nbsp;		 */
<b class="fc"><i>654</i>&nbsp;		public final Action MATCH_VIEWER_RESOLUTIONS = new Action(&quot;Match viewer resolutions&quot;, e -&gt; viewerManager.matchResolutions());</b>
<i>655</i>&nbsp;		
<i>656</i>&nbsp;		/**
<i>657</i>&nbsp;		 * Show the main log window.
<i>658</i>&nbsp;		 */
<b class="fc"><i>659</i>&nbsp;		@ActionAccelerator(&quot;shortcut+shift+l&quot;)</b>
<b class="fc"><i>660</i>&nbsp;		public final Action SHOW_LOG = ActionTools.createAction(new LogViewerCommand(QuPathGUI.this), &quot;Show log&quot;);</b>
<i>661</i>&nbsp;
<i>662</i>&nbsp;		/**
<i>663</i>&nbsp;		 * Toggle the visibility of the &#39;Analysis pane&#39; in the main viewer.
<i>664</i>&nbsp;		 */
<b class="fc"><i>665</i>&nbsp;		@ActionIcon(PathIcons.MEASURE)</b>
<i>666</i>&nbsp;		@ActionAccelerator(&quot;shift+a&quot;)
<b class="fc"><i>667</i>&nbsp;		public final Action SHOW_ANALYSIS_PANE = createShowAnalysisPaneAction();</b>
<i>668</i>&nbsp;		
<i>669</i>&nbsp;		/**
<i>670</i>&nbsp;		 * Show summary measurement table for TMA cores.
<i>671</i>&nbsp;		 */
<b class="fc"><i>672</i>&nbsp;		@ActionDescription(&quot;Show summary measurements for tissue microarray (TMA) cores&quot;)</b>
<b class="fc"><i>673</i>&nbsp;		public final Action MEASURE_TMA = createImageDataAction(imageData -&gt; Commands.showTMAMeasurementTable(QuPathGUI.this, imageData), &quot;Show TMA measurements&quot;);</b>
<i>674</i>&nbsp;		
<i>675</i>&nbsp;		/**
<i>676</i>&nbsp;		 * Show summary measurement table for annotations.
<i>677</i>&nbsp;		 */
<b class="fc"><i>678</i>&nbsp;		@ActionDescription(&quot;Show summary measurements for annotation objects&quot;)</b>
<b class="fc"><i>679</i>&nbsp;		public final Action MEASURE_ANNOTATIONS = createImageDataAction(imageData -&gt; Commands.showAnnotationMeasurementTable(QuPathGUI.this, imageData), &quot;Show annotation measurements&quot;);</b>
<i>680</i>&nbsp;		
<i>681</i>&nbsp;		/**
<i>682</i>&nbsp;		 * Show summary measurement table for detections.
<i>683</i>&nbsp;		 */
<b class="fc"><i>684</i>&nbsp;		@ActionDescription(&quot;Show summary measurements for detection objects&quot;)</b>
<b class="fc"><i>685</i>&nbsp;		public final Action MEASURE_DETECTIONS = createImageDataAction(imageData -&gt; Commands.showDetectionMeasurementTable(QuPathGUI.this, imageData), &quot;Show detection measurements&quot;);</b>
<i>686</i>&nbsp;		
<b class="fc"><i>687</i>&nbsp;		private DefaultActions() {</b>
<i>688</i>&nbsp;			// This has the effect of applying the annotations
<b class="fc"><i>689</i>&nbsp;			ActionTools.getAnnotatedActions(this);</b>
<b class="fc"><i>690</i>&nbsp;		}</b>
<i>691</i>&nbsp;		
<i>692</i>&nbsp;	}
<i>693</i>&nbsp;	
<i>694</i>&nbsp;	private DefaultActions defaultActions;
<i>695</i>&nbsp;	
<i>696</i>&nbsp;	
<i>697</i>&nbsp;	/**
<i>698</i>&nbsp;	 * Get the default actions associated with this QuPath instance.
<i>699</i>&nbsp;	 * @return
<i>700</i>&nbsp;	 */
<i>701</i>&nbsp;	public synchronized DefaultActions getDefaultActions() {
<b class="fc"><i>702</i>&nbsp;		if (defaultActions == null)</b>
<b class="fc"><i>703</i>&nbsp;			defaultActions = new DefaultActions();</b>
<b class="fc"><i>704</i>&nbsp;		return defaultActions;</b>
<i>705</i>&nbsp;	}
<i>706</i>&nbsp;	
<i>707</i>&nbsp;	
<i>708</i>&nbsp;	private Action createShowAnalysisPaneAction() {
<b class="fc"><i>709</i>&nbsp;		return ActionTools.createSelectableAction(showAnalysisPane, &quot;Show analysis panel&quot;);</b>
<i>710</i>&nbsp;	}
<i>711</i>&nbsp;	
<i>712</i>&nbsp;	/**
<i>713</i>&nbsp;	 * A list of all actions currently registered for this GUI.
<i>714</i>&nbsp;	 */
<b class="fc"><i>715</i>&nbsp;	private ObservableList&lt;Action&gt; actions = FXCollections.observableArrayList();</b>
<i>716</i>&nbsp;	
<i>717</i>&nbsp;	/**
<i>718</i>&nbsp;	 * Search for an action based upon its text (name) property.
<i>719</i>&nbsp;	 * @param text the text to search for
<i>720</i>&nbsp;	 * @return the action, if found, or null otherwise
<i>721</i>&nbsp;	 */
<i>722</i>&nbsp;	public Action lookupActionByText(String text) {
<b class="fc"><i>723</i>&nbsp;		var found = actions.stream().filter(p -&gt; text.equals(p.getText())).findFirst().orElse(null);</b>
<b class="fc"><i>724</i>&nbsp;		if (found == null)</b>
<b class="nc"><i>725</i>&nbsp;			logger.warn(&quot;No action called &#39;{}&#39; could be found!&quot;, text);</b>
<b class="fc"><i>726</i>&nbsp;		return found;</b>
<i>727</i>&nbsp;	}
<i>728</i>&nbsp;	
<i>729</i>&nbsp;	/**
<i>730</i>&nbsp;	 * Search for a menu item based upon its path.
<i>731</i>&nbsp;	 * @param menuPath path to the menu item, in the form {@code &quot;Main menu&gt;Submenu&gt;Name}
<i>732</i>&nbsp;	 * @return the menu item corresponding to this path, or null if no menu item is found
<i>733</i>&nbsp;	 */
<i>734</i>&nbsp;	public MenuItem lookupMenuItem(String menuPath) {
<b class="nc"><i>735</i>&nbsp;		var menu = parseMenu(menuPath, &quot;&quot;, false);</b>
<b class="nc"><i>736</i>&nbsp;		if (menu == null)</b>
<b class="nc"><i>737</i>&nbsp;			return null;</b>
<b class="nc"><i>738</i>&nbsp;		var name = parseName(menuPath);</b>
<b class="nc"><i>739</i>&nbsp;		if (name.isEmpty())</b>
<b class="nc"><i>740</i>&nbsp;			return menu;</b>
<b class="nc"><i>741</i>&nbsp;		return menu.getItems().stream().filter(m -&gt; name.equals(m.getText())).findFirst().orElse(null);</b>
<i>742</i>&nbsp;	}
<i>743</i>&nbsp;	
<i>744</i>&nbsp;	
<b class="fc"><i>745</i>&nbsp;	private long lastMousePressedWarning = 0L;</b>
<i>746</i>&nbsp;	
<i>747</i>&nbsp;	
<i>748</i>&nbsp;	/**
<i>749</i>&nbsp;	 * Create a QuPath instance, optionally initializing it with a path to open.
<i>750</i>&nbsp;	 * &lt;p&gt;
<i>751</i>&nbsp;	 * It is also possible to specify that QuPath runs as a standalone application or not.
<i>752</i>&nbsp;	 * The practical difference is that, if a standalone application, QuPath may call System.exit(0)
<i>753</i>&nbsp;	 * when its window is closed; otherwise, it must not for fear or bringing the host application with it.
<i>754</i>&nbsp;	 * &lt;p&gt;
<i>755</i>&nbsp;	 * If QuPath is launched, for example, from a running Fiji instance then isStandalone should be false.
<i>756</i>&nbsp;	 * 
<i>757</i>&nbsp;	 * @param services host services available during startup; may be null, but required for some functionality (e.g. opening a webpage in the host browser)
<i>758</i>&nbsp;	 * @param stage a stage to use for the main QuPath window (may be null)
<i>759</i>&nbsp;	 * @param path path of an image, project or data file to open (may be null)
<i>760</i>&nbsp;	 * @param isStandalone true if QuPath should be run as a standalone application
<i>761</i>&nbsp;	 * @param startupQuietly true if QuPath should start up without showing any messages or dialogs
<i>762</i>&nbsp;	 */
<i>763</i>&nbsp;	QuPathGUI(final HostServices services, final Stage stage, final String path, final boolean isStandalone, final boolean startupQuietly) {
<b class="fc"><i>764</i>&nbsp;		super();</b>
<i>765</i>&nbsp;		
<b class="fc"><i>766</i>&nbsp;		this.hostServices = services;</b>
<i>767</i>&nbsp;		
<b class="fc"><i>768</i>&nbsp;		if (PathPrefs.doCreateLogFilesProperty().get()) {</b>
<b class="fc"><i>769</i>&nbsp;			File fileLogging = tryToStartLogFile();</b>
<b class="fc"><i>770</i>&nbsp;			if (fileLogging != null) {</b>
<b class="nc"><i>771</i>&nbsp;				logger.info(&quot;Logging to file {}&quot;, fileLogging);</b>
<i>772</i>&nbsp;			} else {
<b class="fc"><i>773</i>&nbsp;				logger.warn(&quot;No directory set for log files! None will be written.&quot;);</b>
<i>774</i>&nbsp;			}
<i>775</i>&nbsp;		}
<i>776</i>&nbsp;		
<b class="fc"><i>777</i>&nbsp;		var buildString = BuildInfo.getInstance().getBuildString();</b>
<b class="fc"><i>778</i>&nbsp;		var version = BuildInfo.getInstance().getVersion();</b>
<b class="fc"><i>779</i>&nbsp;		if (buildString != null)</b>
<b class="nc"><i>780</i>&nbsp;			logger.info(&quot;QuPath build: {}&quot;, buildString);</b>
<b class="fc"><i>781</i>&nbsp;		else if (version != null) {</b>
<b class="fc"><i>782</i>&nbsp;			logger.info(&quot;QuPath version: {}&quot;, version);			</b>
<i>783</i>&nbsp;		} else
<b class="nc"><i>784</i>&nbsp;			logger.warn(&quot;QuPath version unknown!&quot;);						</b>
<i>785</i>&nbsp;		
<b class="fc"><i>786</i>&nbsp;		long startTime = System.currentTimeMillis();</b>
<i>787</i>&nbsp;		
<i>788</i>&nbsp;		// Set up cache
<b class="fc"><i>789</i>&nbsp;		imageRegionStore = ImageRegionStoreFactory.createImageRegionStore(QuPathGUI.getTileCacheSizeBytes());</b>
<i>790</i>&nbsp;		
<b class="fc"><i>791</i>&nbsp;		PathPrefs.tileCachePercentageProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>792</i>&nbsp;			imageRegionStore.getCache().clear();</b>
<b class="nc"><i>793</i>&nbsp;		});</b>
<i>794</i>&nbsp;		
<b class="fc"><i>795</i>&nbsp;		ImageServerProvider.setCache(imageRegionStore.getCache(), BufferedImage.class);</b>
<i>796</i>&nbsp;		
<b class="fc"><i>797</i>&nbsp;		this.stage = stage;</b>
<b class="fc"><i>798</i>&nbsp;		this.isStandalone = isStandalone;</b>
<i>799</i>&nbsp;		
<b class="fc"><i>800</i>&nbsp;		menuBar = new MenuBar(</b>
<b class="fc"><i>801</i>&nbsp;				Arrays.asList(&quot;File&quot;, &quot;Edit&quot;, &quot;Tools&quot;, &quot;View&quot;, &quot;Objects&quot;, &quot;TMA&quot;, &quot;Measure&quot;, &quot;Automate&quot;, &quot;Analyze&quot;, &quot;Classify&quot;, &quot;Extensions&quot;, &quot;Help&quot;)</b>
<b class="fc"><i>802</i>&nbsp;				.stream().map(Menu::new).toArray(Menu[]::new)</b>
<i>803</i>&nbsp;				);
<i>804</i>&nbsp;		
<b class="fc"><i>805</i>&nbsp;		actions.addListener((ListChangeListener.Change&lt;? extends Action&gt; c) -&gt; {</b>
<b class="fc"><i>806</i>&nbsp;			while (c.next()) {</b>
<b class="fc"><i>807</i>&nbsp;				if (c.wasPermutated()) {</b>
<b class="nc"><i>808</i>&nbsp;					logger.warn(&quot;Menu permutations not supported!&quot;);</b>
<b class="fc"><i>809</i>&nbsp;				} else if (c.wasRemoved() ) {</b>
<b class="nc"><i>810</i>&nbsp;					logger.warn(&quot;Menu item removal not supported!&quot;);					</b>
<b class="fc"><i>811</i>&nbsp;				} else if (c.wasAdded() ) {</b>
<b class="fc"><i>812</i>&nbsp;					installActions(c.getAddedSubList());					</b>
<i>813</i>&nbsp;				}
<i>814</i>&nbsp;			}
<b class="fc"><i>815</i>&nbsp;		});</b>
<b class="fc"><i>816</i>&nbsp;		setupToolsMenu(getMenu(&quot;Tools&quot;, true));</b>
<i>817</i>&nbsp;		
<i>818</i>&nbsp;		// Prepare for image name masking
<b class="fc"><i>819</i>&nbsp;		projectProperty.addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>820</i>&nbsp;			if (n != null)</b>
<b class="nc"><i>821</i>&nbsp;				n.setMaskImageNames(PathPrefs.maskImageNamesProperty().get());</b>
<b class="nc"><i>822</i>&nbsp;			refreshTitle();</b>
<b class="nc"><i>823</i>&nbsp;		});</b>
<b class="fc"><i>824</i>&nbsp;		PathPrefs.maskImageNamesProperty().addListener(((v, o, n) -&gt; {</b>
<b class="nc"><i>825</i>&nbsp;			var currentProject = getProject();</b>
<b class="nc"><i>826</i>&nbsp;			if (currentProject != null) {</b>
<b class="nc"><i>827</i>&nbsp;				currentProject.setMaskImageNames(n);</b>
<i>828</i>&nbsp;			}
<b class="nc"><i>829</i>&nbsp;		}));</b>
<i>830</i>&nbsp;		
<i>831</i>&nbsp;		// Create preferences panel
<b class="fc"><i>832</i>&nbsp;		prefsPane = new PreferencePane();</b>
<i>833</i>&nbsp;		
<i>834</i>&nbsp;		// Set the number of threads at an early stage...
<b class="fc"><i>835</i>&nbsp;		AbstractPluginRunner.setNumThreadsRequested(PathPrefs.numCommandThreadsProperty().get());</b>
<b class="fc"><i>836</i>&nbsp;		PathPrefs.numCommandThreadsProperty().addListener(o -&gt; AbstractPluginRunner.setNumThreadsRequested(PathPrefs.numCommandThreadsProperty().get()));</b>
<i>837</i>&nbsp;		
<i>838</i>&nbsp;		// Activate the log at an early stage
<i>839</i>&nbsp;		// TODO: NEED TO TURN ON LOG!
<i>840</i>&nbsp;//		Action actionLog = createAction(GUIActions.SHOW_LOG);
<i>841</i>&nbsp;		
<i>842</i>&nbsp;		// Turn off the use of ImageIODiskCache (it causes some trouble)
<b class="fc"><i>843</i>&nbsp;		ImageIO.setUseCache(false);</b>
<i>844</i>&nbsp;		
<i>845</i>&nbsp;		// Initialize available classes
<b class="fc"><i>846</i>&nbsp;		initializePathClasses();</b>
<i>847</i>&nbsp;		
<b class="fc"><i>848</i>&nbsp;		logger.trace(&quot;Time to tools: {} ms&quot;, (System.currentTimeMillis() - startTime));</b>
<i>849</i>&nbsp;		
<i>850</i>&nbsp;		// Initialize all tools
<i>851</i>&nbsp;//		initializeTools();
<i>852</i>&nbsp;
<i>853</i>&nbsp;		// Initialize main GUI
<i>854</i>&nbsp;//		initializeMainComponent();
<i>855</i>&nbsp;		
<i>856</i>&nbsp;		// Set this as the current instance
<b class="fc"><i>857</i>&nbsp;		if (instance == null || instance.getStage() == null || !instance.getStage().isShowing())</b>
<b class="fc"><i>858</i>&nbsp;			instance = this;</b>
<i>859</i>&nbsp;		
<i>860</i>&nbsp;		// Ensure the user is notified of any errors from now on
<b class="fc"><i>861</i>&nbsp;		Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {</b>
<i>862</i>&nbsp;			@Override
<i>863</i>&nbsp;			public void uncaughtException(Thread t, Throwable e) {
<b class="nc"><i>864</i>&nbsp;				Dialogs.showErrorNotification(&quot;QuPath exception&quot;, e);</b>
<b class="nc"><i>865</i>&nbsp;				if (defaultActions.SHOW_LOG != null)</b>
<b class="nc"><i>866</i>&nbsp;					defaultActions.SHOW_LOG.handle(null);</b>
<i>867</i>&nbsp;				// Try to reclaim any memory we can
<b class="nc"><i>868</i>&nbsp;				if (e instanceof OutOfMemoryError) {</b>
<b class="nc"><i>869</i>&nbsp;					getViewer().getImageRegionStore().clearCache(false, false);</b>
<i>870</i>&nbsp;				}
<b class="nc"><i>871</i>&nbsp;			}</b>
<i>872</i>&nbsp;		});
<i>873</i>&nbsp;		
<i>874</i>&nbsp;		
<b class="fc"><i>875</i>&nbsp;		logger.trace(&quot;Time to main component: {} ms&quot;, (System.currentTimeMillis() - startTime));</b>
<i>876</i>&nbsp;
<b class="fc"><i>877</i>&nbsp;		BorderPane pane = new BorderPane();</b>
<b class="fc"><i>878</i>&nbsp;		pane.setCenter(initializeMainComponent());</b>
<i>879</i>&nbsp;		
<b class="fc"><i>880</i>&nbsp;		logger.trace(&quot;Time to menu: {} ms&quot;, (System.currentTimeMillis() - startTime));</b>
<i>881</i>&nbsp;		
<b class="fc"><i>882</i>&nbsp;		initializingMenus.set(true);</b>
<b class="fc"><i>883</i>&nbsp;		menuBar.useSystemMenuBarProperty().bindBidirectional(PathPrefs.useSystemMenubarProperty());</b>
<b class="fc"><i>884</i>&nbsp;		pane.setTop(menuBar);</b>
<i>885</i>&nbsp;		
<i>886</i>&nbsp;		Scene scene;
<i>887</i>&nbsp;		try {
<b class="fc"><i>888</i>&nbsp;			Rectangle2D bounds = Screen.getPrimary().getVisualBounds();</b>
<b class="fc"><i>889</i>&nbsp;			scene = new Scene(pane, bounds.getWidth()*0.8, bounds.getHeight()*0.8);</b>
<b class="nc"><i>890</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>891</i>&nbsp;			logger.debug(&quot;Unable to set stage size using primary screen {}&quot;, Screen.getPrimary());</b>
<b class="nc"><i>892</i>&nbsp;			scene = new Scene(pane, 1000, 600);</b>
<b class="fc"><i>893</i>&nbsp;		}</b>
<i>894</i>&nbsp;		
<b class="fc"><i>895</i>&nbsp;		splitPane.setDividerPosition(0, 400/scene.getWidth());</b>
<i>896</i>&nbsp;		
<b class="fc"><i>897</i>&nbsp;		logger.trace(&quot;Time to scene: {} ms&quot;, (System.currentTimeMillis() - startTime));</b>
<i>898</i>&nbsp;		
<b class="fc"><i>899</i>&nbsp;		stage.setScene(scene);</b>
<i>900</i>&nbsp;
<i>901</i>&nbsp;		// Remove this to only accept drag-and-drop into a viewer
<b class="fc"><i>902</i>&nbsp;		dragAndDrop.setupTarget(scene);</b>
<b class="fc"><i>903</i>&nbsp;		TMACommands.installDragAndDropHandler(this);</b>
<i>904</i>&nbsp;		
<b class="fc"><i>905</i>&nbsp;		stage.setOnCloseRequest(e -&gt; {</b>
<i>906</i>&nbsp;			
<b class="fc"><i>907</i>&nbsp;			Set&lt;QuPathViewer&gt; unsavedViewers = new LinkedHashSet&lt;&gt;();</b>
<b class="fc"><i>908</i>&nbsp;			for (QuPathViewer viewer : viewerManager.getViewers()) {</b>
<b class="fc"><i>909</i>&nbsp;				if (viewer.getImageData() != null &amp;&amp; viewer.getImageData().isChanged())</b>
<b class="fc"><i>910</i>&nbsp;					unsavedViewers.add(viewer);</b>
<b class="fc"><i>911</i>&nbsp;			}</b>
<b class="fc"><i>912</i>&nbsp;			if (!unsavedViewers.isEmpty()) {</b>
<b class="fc"><i>913</i>&nbsp;				if (unsavedViewers.size() == 1) {</b>
<b class="fc"><i>914</i>&nbsp;					if (!viewerManager.closeViewer(&quot;Quit QuPath&quot;, unsavedViewers.iterator().next())) {</b>
<b class="nc"><i>915</i>&nbsp;						logger.trace(&quot;Pressed no to close viewer!&quot;);</b>
<b class="nc"><i>916</i>&nbsp;						e.consume();</b>
<b class="nc"><i>917</i>&nbsp;						return;</b>
<i>918</i>&nbsp;					}
<b class="nc"><i>919</i>&nbsp;				} else if (!Dialogs.showYesNoDialog(&quot;Quit QuPath&quot;, &quot;Are you sure you want to quit?\n\nUnsaved changes in &quot; + unsavedViewers.size() + &quot; viewers will be lost.&quot;)) {</b>
<b class="nc"><i>920</i>&nbsp;					logger.trace(&quot;Pressed no to quit window!&quot;);</b>
<b class="nc"><i>921</i>&nbsp;					e.consume();</b>
<b class="nc"><i>922</i>&nbsp;					return;</b>
<i>923</i>&nbsp;				}
<i>924</i>&nbsp;			}
<i>925</i>&nbsp;			// Could uncomment this to sync the project - but we should be careful to avoid excessive synchronization
<i>926</i>&nbsp;			// (and it may already be synchronied when saving the image data)
<b class="fc"><i>927</i>&nbsp;			var project = getProject();</b>
<b class="fc"><i>928</i>&nbsp;			if (project != null) {</b>
<i>929</i>&nbsp;				try {
<b class="nc"><i>930</i>&nbsp;					project.syncChanges();</b>
<b class="nc"><i>931</i>&nbsp;				} catch (IOException ex) {</b>
<b class="nc"><i>932</i>&nbsp;					logger.error(&quot;Error syncing project: &quot; + ex.getLocalizedMessage(), e);</b>
<b class="nc"><i>933</i>&nbsp;				}</b>
<i>934</i>&nbsp;			}
<i>935</i>&nbsp;			
<i>936</i>&nbsp;			// Check if there is a script running
<b class="fc"><i>937</i>&nbsp;			if (scriptRunning.get()) {</b>
<b class="nc"><i>938</i>&nbsp;				if (!Dialogs.showYesNoDialog(&quot;Quit QuPath&quot;, &quot;A script is currently running! Quit anyway?&quot;)) {</b>
<b class="nc"><i>939</i>&nbsp;					logger.trace(&quot;Pressed no to quit window with script running!&quot;);</b>
<b class="nc"><i>940</i>&nbsp;					e.consume();</b>
<b class="nc"><i>941</i>&nbsp;					return;</b>
<i>942</i>&nbsp;				}
<i>943</i>&nbsp;			}
<i>944</i>&nbsp;			
<i>945</i>&nbsp;			// Stop any painter requests
<b class="fc"><i>946</i>&nbsp;			if (imageRegionStore != null)</b>
<b class="fc"><i>947</i>&nbsp;				imageRegionStore.close();</b>
<i>948</i>&nbsp;			
<i>949</i>&nbsp;			// Save the PathClasses
<b class="fc"><i>950</i>&nbsp;			savePathClasses();</b>
<i>951</i>&nbsp;			
<i>952</i>&nbsp;			// Flush the preferences
<b class="fc"><i>953</i>&nbsp;			if (!PathPrefs.savePreferences())</b>
<b class="nc"><i>954</i>&nbsp;				logger.error(&quot;Error saving preferences&quot;);</b>
<i>955</i>&nbsp;			
<i>956</i>&nbsp;			// Shut down any pools we know about
<b class="fc"><i>957</i>&nbsp;			poolMultipleThreads.shutdownNow();</b>
<b class="fc"><i>958</i>&nbsp;			for (ExecutorService pool : mapSingleThreadPools.values())</b>
<b class="nc"><i>959</i>&nbsp;				pool.shutdownNow();</b>
<i>960</i>&nbsp;
<i>961</i>&nbsp;			// Shut down all our image servers
<b class="fc"><i>962</i>&nbsp;			for (QuPathViewer v : getViewers()) {</b>
<i>963</i>&nbsp;				try {
<b class="fc"><i>964</i>&nbsp;					if (v.getImageData() != null)</b>
<b class="nc"><i>965</i>&nbsp;						v.getImageData().getServer().close();</b>
<b class="nc"><i>966</i>&nbsp;				} catch (Exception e2) {</b>
<b class="nc"><i>967</i>&nbsp;					logger.warn(&quot;Problem closing server&quot;, e2);</b>
<b class="fc"><i>968</i>&nbsp;				}</b>
<b class="fc"><i>969</i>&nbsp;			}</b>
<i>970</i>&nbsp;
<i>971</i>&nbsp;			// Reset the instance
<b class="fc"><i>972</i>&nbsp;			instance = null;</b>
<i>973</i>&nbsp;			
<i>974</i>&nbsp;			// Exit if running as a standalone application
<b class="fc"><i>975</i>&nbsp;			if (isStandalone()) {</b>
<b class="fc"><i>976</i>&nbsp;				logger.info(&quot;Calling Platform.exit();&quot;);</b>
<b class="fc"><i>977</i>&nbsp;				Platform.exit();</b>
<i>978</i>&nbsp;				// Something of an extreme option... :/
<i>979</i>&nbsp;				// Shouldn&#39;t be needed if we shut down everything properly, but here as a backup just in case... 
<i>980</i>&nbsp;				// (e.g. if ImageJ is running)
<i>981</i>&nbsp;//				logger.info(&quot;Calling System.exit(0);&quot;);
<b class="fc"><i>982</i>&nbsp;				System.exit(0);</b>
<i>983</i>&nbsp;			}
<i>984</i>&nbsp;			
<b class="nc"><i>985</i>&nbsp;		});</b>
<i>986</i>&nbsp;		
<i>987</i>&nbsp;		
<b class="fc"><i>988</i>&nbsp;		logger.debug(&quot;Time to display: {} ms&quot;, (System.currentTimeMillis() - startTime));</b>
<b class="fc"><i>989</i>&nbsp;		stage.show();</b>
<b class="fc"><i>990</i>&nbsp;		logger.trace(&quot;Time to finish display: {} ms&quot;, (System.currentTimeMillis() - startTime));</b>
<b class="fc"><i>991</i>&nbsp;		var ignoreTypes = new HashSet&lt;&gt;(Arrays.asList(MouseEvent.MOUSE_MOVED, MouseEvent.MOUSE_ENTERED, MouseEvent.MOUSE_ENTERED_TARGET, MouseEvent.MOUSE_EXITED, MouseEvent.MOUSE_ENTERED_TARGET));</b>
<b class="fc"><i>992</i>&nbsp;		stage.getScene().addEventFilter(MouseEvent.ANY, e -&gt; {</b>
<b class="fc"><i>993</i>&nbsp;			if (ignoreTypes.contains(e.getEventType()))</b>
<b class="fc"><i>994</i>&nbsp;				return;</b>
<b class="fc"><i>995</i>&nbsp;			if (scriptRunning.get()) {</b>
<b class="nc"><i>996</i>&nbsp;				e.consume();</b>
<i>997</i>&nbsp;				// Show a warning if clicking (but not *too* often)
<b class="nc"><i>998</i>&nbsp;				if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {</b>
<b class="nc"><i>999</i>&nbsp;					long time = System.currentTimeMillis();</b>
<b class="nc"><i>1000</i>&nbsp;					if (time - lastMousePressedWarning &gt; 5000L) {</b>
<b class="nc"><i>1001</i>&nbsp;						Dialogs.showWarningNotification(&quot;Script running&quot;, &quot;Please wait until the current script has finished!&quot;);</b>
<b class="nc"><i>1002</i>&nbsp;						lastMousePressedWarning = time;</b>
<i>1003</i>&nbsp;					}
<i>1004</i>&nbsp;				}
<i>1005</i>&nbsp;			}
<b class="fc"><i>1006</i>&nbsp;		});</b>
<i>1007</i>&nbsp;		
<i>1008</i>&nbsp;		// Ensure spacebar presses are noted, irrespective of which component has the focus
<b class="fc"><i>1009</i>&nbsp;		stage.getScene().addEventFilter(KeyEvent.ANY, e -&gt; {</b>
<b class="nc"><i>1010</i>&nbsp;			if (e.getCode() == KeyCode.SPACE) {</b>
<b class="nc"><i>1011</i>&nbsp;				Boolean pressed = null;</b>
<b class="nc"><i>1012</i>&nbsp;				if (e.getEventType() == KeyEvent.KEY_PRESSED)</b>
<b class="nc"><i>1013</i>&nbsp;					pressed = Boolean.TRUE;</b>
<b class="nc"><i>1014</i>&nbsp;				else if (e.getEventType() == KeyEvent.KEY_RELEASED)</b>
<b class="nc"><i>1015</i>&nbsp;					pressed = Boolean.FALSE;</b>
<b class="nc"><i>1016</i>&nbsp;				if (pressed != null) {</b>
<i>1017</i>&nbsp;					// Set spacebar for only the active viewer (since it results in registering 
<i>1018</i>&nbsp;					// tools, and we don&#39;t want tools to be registered to inactive viewers...)
<b class="nc"><i>1019</i>&nbsp;					var active = viewerManager.getActiveViewer();</b>
<b class="nc"><i>1020</i>&nbsp;					if (active != null)</b>
<b class="nc"><i>1021</i>&nbsp;						active.setSpaceDown(pressed.booleanValue());</b>
<i>1022</i>&nbsp;//					for (QuPathViewer viewer : viewerManager.getOpenViewers()) {
<i>1023</i>&nbsp;//						viewer.setSpaceDown(pressed.booleanValue());
<i>1024</i>&nbsp;//					}
<i>1025</i>&nbsp;				}
<i>1026</i>&nbsp;			}
<b class="nc"><i>1027</i>&nbsp;		});</b>
<i>1028</i>&nbsp;		
<b class="fc"><i>1029</i>&nbsp;		stage.getScene().setOnKeyReleased(e -&gt; {</b>
<i>1030</i>&nbsp;			// It seems if using the system menubar on Mac, we can sometimes need to mop up missed keypresses
<b class="nc"><i>1031</i>&nbsp;			if (e.isConsumed() || e.isShortcutDown() || !(GeneralTools.isMac() &amp;&amp; getMenuBar().isUseSystemMenuBar()) || e.getTarget() instanceof TextInputControl) {</b>
<b class="nc"><i>1032</i>&nbsp;				return;</b>
<i>1033</i>&nbsp;			}
<i>1034</i>&nbsp;			
<b class="nc"><i>1035</i>&nbsp;			for (var entry : comboMap.entrySet()) {</b>
<b class="nc"><i>1036</i>&nbsp;				if (entry.getKey().match(e)) {</b>
<b class="nc"><i>1037</i>&nbsp;					var action = entry.getValue();</b>
<b class="nc"><i>1038</i>&nbsp;					if (ActionTools.isSelectable(action))</b>
<b class="nc"><i>1039</i>&nbsp;						action.setSelected(!action.isSelected());</b>
<i>1040</i>&nbsp;					else
<b class="nc"><i>1041</i>&nbsp;						action.handle(new ActionEvent(e.getSource(), e.getTarget()));</b>
<b class="nc"><i>1042</i>&nbsp;					e.consume();</b>
<b class="nc"><i>1043</i>&nbsp;					return;</b>
<i>1044</i>&nbsp;				}
<b class="nc"><i>1045</i>&nbsp;			}</b>
<i>1046</i>&nbsp;			
<i>1047</i>&nbsp;			// Generic &#39;hiding&#39;
<b class="nc"><i>1048</i>&nbsp;			if (new KeyCodeCombination(KeyCode.H).match(e)) {</b>
<b class="nc"><i>1049</i>&nbsp;				var action = defaultActions.SHOW_DETECTIONS;</b>
<b class="nc"><i>1050</i>&nbsp;				action.setSelected(!action.isSelected());</b>
<b class="nc"><i>1051</i>&nbsp;				action = defaultActions.SHOW_PIXEL_CLASSIFICATION;</b>
<b class="nc"><i>1052</i>&nbsp;				action.setSelected(!action.isSelected());</b>
<b class="nc"><i>1053</i>&nbsp;				e.consume();</b>
<i>1054</i>&nbsp;			}
<i>1055</i>&nbsp;			
<b class="nc"><i>1056</i>&nbsp;		});</b>
<i>1057</i>&nbsp;		
<i>1058</i>&nbsp;		// Install extensions
<b class="fc"><i>1059</i>&nbsp;		refreshExtensions(false);</b>
<i>1060</i>&nbsp;		
<i>1061</i>&nbsp;		// Open an image, if required
<b class="fc"><i>1062</i>&nbsp;		if (path != null)</b>
<b class="nc"><i>1063</i>&nbsp;			openImage(path, false, false);</b>
<i>1064</i>&nbsp;		
<i>1065</i>&nbsp;		// Set the icons
<b class="fc"><i>1066</i>&nbsp;		stage.getIcons().addAll(loadIconList());</b>
<i>1067</i>&nbsp;		
<i>1068</i>&nbsp;		
<i>1069</i>&nbsp;		// Add scripts menu (delayed to here, since it takes a bit longer)
<b class="fc"><i>1070</i>&nbsp;		Menu menuAutomate = getMenu(&quot;Automate&quot;, false);</b>
<b class="fc"><i>1071</i>&nbsp;		ScriptEditor editor = getScriptEditor();</b>
<b class="fc"><i>1072</i>&nbsp;		sharedScriptMenuLoader = new ScriptMenuLoader(&quot;Shared scripts...&quot;, PathPrefs.scriptsPathProperty(), (DefaultScriptEditor)editor);</b>
<i>1073</i>&nbsp;		
<i>1074</i>&nbsp;		// TODO: Reintroduce project scripts
<b class="fc"><i>1075</i>&nbsp;		StringBinding projectScriptsPath = Bindings.createStringBinding(() -&gt; {</b>
<b class="fc"><i>1076</i>&nbsp;			var project = getProject();</b>
<b class="fc"><i>1077</i>&nbsp;			if (project == null)</b>
<b class="fc"><i>1078</i>&nbsp;				return null;</b>
<b class="nc"><i>1079</i>&nbsp;			File dir = Projects.getBaseDirectory(project);</b>
<b class="nc"><i>1080</i>&nbsp;			if (dir == null)</b>
<b class="nc"><i>1081</i>&nbsp;				return null;</b>
<b class="nc"><i>1082</i>&nbsp;			return new File(dir, &quot;scripts&quot;).getAbsolutePath();</b>
<i>1083</i>&nbsp;//			return getProjectScriptsDirectory(false).getAbsolutePath();
<i>1084</i>&nbsp;		}, projectProperty);
<b class="fc"><i>1085</i>&nbsp;		var projectScriptMenuLoader = new ScriptMenuLoader(&quot;Project scripts...&quot;, projectScriptsPath, (DefaultScriptEditor)editor);</b>
<b class="fc"><i>1086</i>&nbsp;		projectScriptMenuLoader.getMenu().visibleProperty().bind(</b>
<b class="fc"><i>1087</i>&nbsp;				projectProperty.isNotNull().and(initializingMenus.not())</b>
<i>1088</i>&nbsp;				);
<i>1089</i>&nbsp;		
<b class="fc"><i>1090</i>&nbsp;		StringBinding userScriptsPath = Bindings.createStringBinding(() -&gt; {</b>
<b class="fc"><i>1091</i>&nbsp;			String userPath = PathPrefs.getUserPath();</b>
<b class="fc"><i>1092</i>&nbsp;			File dirScripts = userPath == null ? null : new File(userPath, &quot;scripts&quot;);</b>
<b class="fc"><i>1093</i>&nbsp;			if (dirScripts == null || !dirScripts.isDirectory())</b>
<b class="fc"><i>1094</i>&nbsp;				return null;</b>
<b class="nc"><i>1095</i>&nbsp;			return dirScripts.getAbsolutePath();</b>
<b class="fc"><i>1096</i>&nbsp;		}, PathPrefs.userPathProperty());</b>
<b class="fc"><i>1097</i>&nbsp;		ScriptMenuLoader userScriptMenuLoader = new ScriptMenuLoader(&quot;User scripts...&quot;, userScriptsPath, (DefaultScriptEditor)editor);</b>
<i>1098</i>&nbsp;
<b class="fc"><i>1099</i>&nbsp;		menuAutomate.setOnMenuValidation(e -&gt; {</b>
<b class="nc"><i>1100</i>&nbsp;			sharedScriptMenuLoader.updateMenu();</b>
<b class="nc"><i>1101</i>&nbsp;			projectScriptMenuLoader.updateMenu();</b>
<b class="nc"><i>1102</i>&nbsp;			userScriptMenuLoader.updateMenu();</b>
<b class="nc"><i>1103</i>&nbsp;		});</b>
<i>1104</i>&nbsp;
<b class="fc"><i>1105</i>&nbsp;		if (editor instanceof DefaultScriptEditor) {</b>
<b class="fc"><i>1106</i>&nbsp;			MenuTools.addMenuItems(</b>
<i>1107</i>&nbsp;					menuAutomate,
<i>1108</i>&nbsp;					null,
<b class="fc"><i>1109</i>&nbsp;					sharedScriptMenuLoader.getMenu(),</b>
<b class="fc"><i>1110</i>&nbsp;					userScriptMenuLoader.getMenu(),</b>
<b class="fc"><i>1111</i>&nbsp;					projectScriptMenuLoader.getMenu()</b>
<i>1112</i>&nbsp;					);
<i>1113</i>&nbsp;		}
<i>1114</i>&nbsp;		
<i>1115</i>&nbsp;		// Menus should now be complete - try binding visibility
<b class="fc"><i>1116</i>&nbsp;		initializingMenus.set(false);</b>
<i>1117</i>&nbsp;		try {
<b class="fc"><i>1118</i>&nbsp;			for (var item : MenuTools.getFlattenedMenuItems(menuBar.getMenus(), false)) {</b>
<b class="fc"><i>1119</i>&nbsp;				if (!item.visibleProperty().isBound())</b>
<b class="fc"><i>1120</i>&nbsp;					bindVisibilityForExperimental(item);</b>
<b class="fc"><i>1121</i>&nbsp;			}</b>
<b class="nc"><i>1122</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>1123</i>&nbsp;			logger.warn(&quot;Error binding menu visibility: {}&quot;, e.getLocalizedMessage());</b>
<b class="nc"><i>1124</i>&nbsp;			logger.warn(&quot;&quot;, e);</b>
<b class="fc"><i>1125</i>&nbsp;		}</b>
<i>1126</i>&nbsp;		
<i>1127</i>&nbsp;		// Update the title
<b class="fc"><i>1128</i>&nbsp;		stage.titleProperty().bind(titleBinding);</b>
<i>1129</i>&nbsp;		
<i>1130</i>&nbsp;		// Register all the accelerators
<i>1131</i>&nbsp;		
<i>1132</i>&nbsp;		// Update display
<i>1133</i>&nbsp;		// Requesting the style should be enough to make sure it is called...
<b class="fc"><i>1134</i>&nbsp;		logger.debug(&quot;Selected style: {}&quot;, QuPathStyleManager.selectedStyleProperty().get());</b>
<i>1135</i>&nbsp;				
<b class="fc"><i>1136</i>&nbsp;		long endTime = System.currentTimeMillis();</b>
<b class="fc"><i>1137</i>&nbsp;		logger.debug(&quot;Startup time: {} ms&quot;, (endTime - startTime));</b>
<i>1138</i>&nbsp;		
<i>1139</i>&nbsp;		// Do auto-update check
<b class="fc"><i>1140</i>&nbsp;		if (!disableAutoUpdateCheck &amp;&amp; !startupQuietly)</b>
<b class="nc"><i>1141</i>&nbsp;			checkForUpdate(true);</b>
<i>1142</i>&nbsp;		
<i>1143</i>&nbsp;		// Show a startup message, if we have one
<b class="fc"><i>1144</i>&nbsp;		if (!startupQuietly)</b>
<b class="fc"><i>1145</i>&nbsp;			showStartupMessage();</b>
<i>1146</i>&nbsp;		
<i>1147</i>&nbsp;		// Run startup script, if we can
<i>1148</i>&nbsp;		try {
<b class="fc"><i>1149</i>&nbsp;			runStartupScript();			</b>
<b class="nc"><i>1150</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>1151</i>&nbsp;			logger.error(&quot;Error running startup script&quot;, e);</b>
<b class="fc"><i>1152</i>&nbsp;		}</b>
<i>1153</i>&nbsp;		
<i>1154</i>&nbsp;		
<b class="fc"><i>1155</i>&nbsp;		if (Desktop.isDesktopSupported()) {</b>
<b class="fc"><i>1156</i>&nbsp;			var desktop = Desktop.getDesktop();</b>
<i>1157</i>&nbsp;//			if (desktop.isSupported(java.awt.Desktop.Action.APP_QUIT_STRATEGY)) {
<i>1158</i>&nbsp;//				desktop.setQuitStrategy(QuitStrategy.;
<i>1159</i>&nbsp;//			}
<b class="fc"><i>1160</i>&nbsp;			if (desktop.isSupported(java.awt.Desktop.Action.APP_QUIT_HANDLER)) {</b>
<b class="nc"><i>1161</i>&nbsp;				desktop.setQuitHandler((e, r) -&gt; {</b>
<b class="nc"><i>1162</i>&nbsp;					Platform.runLater(() -&gt; {</b>
<b class="nc"><i>1163</i>&nbsp;						tryToQuit();</b>
<i>1164</i>&nbsp;						// Report that we have cancelled - we&#39;ll quit anyway if the user confirms it,
<i>1165</i>&nbsp;						// but we need to handle this on the Application thread
<b class="nc"><i>1166</i>&nbsp;						r.cancelQuit();</b>
<b class="nc"><i>1167</i>&nbsp;					});</b>
<b class="nc"><i>1168</i>&nbsp;				});</b>
<i>1169</i>&nbsp;			}
<i>1170</i>&nbsp;		}
<b class="fc"><i>1171</i>&nbsp;	}</b>
<i>1172</i>&nbsp;	
<i>1173</i>&nbsp;	
<i>1174</i>&nbsp;	/**
<i>1175</i>&nbsp;	 * Try to start logging to a file.
<i>1176</i>&nbsp;	 * This will only work if &lt;code&gt;PathPrefs.getLoggingPath() != null&lt;/code&gt;.
<i>1177</i>&nbsp;	 * 
<i>1178</i>&nbsp;	 * @return the file that will (attempt to be) used for logging, or &lt;code&gt;null&lt;/code&gt; if no file is to be used.
<i>1179</i>&nbsp;	 */
<i>1180</i>&nbsp;	private static File tryToStartLogFile() {
<b class="fc"><i>1181</i>&nbsp;		String pathLogging = PathPrefs.getLoggingPath();</b>
<b class="fc"><i>1182</i>&nbsp;		if (pathLogging != null) {</b>
<b class="nc"><i>1183</i>&nbsp;			SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd_HH-mm-ss&quot;);</b>
<b class="nc"><i>1184</i>&nbsp;			String name = &quot;qupath-&quot; + dateFormat.format(new Date()) + &quot;.log&quot;;</b>
<b class="nc"><i>1185</i>&nbsp;			File fileLog = new File(pathLogging, name);</b>
<b class="nc"><i>1186</i>&nbsp;			LogManager.logToFile(fileLog);</b>
<b class="nc"><i>1187</i>&nbsp;			return fileLog;</b>
<i>1188</i>&nbsp;		}
<b class="fc"><i>1189</i>&nbsp;		return null;</b>
<i>1190</i>&nbsp;	}
<i>1191</i>&nbsp;	
<i>1192</i>&nbsp;	
<i>1193</i>&nbsp;	/**
<i>1194</i>&nbsp;	 * Set up the tools menu to listen to the available tools.
<i>1195</i>&nbsp;	 * @param menu
<i>1196</i>&nbsp;	 */
<i>1197</i>&nbsp;	private void setupToolsMenu(Menu menu) {
<b class="fc"><i>1198</i>&nbsp;		tools.addListener((Change&lt;? extends PathTool&gt; c) -&gt; refreshToolsMenu(tools, menu));</b>
<b class="fc"><i>1199</i>&nbsp;	}</b>
<i>1200</i>&nbsp;	
<i>1201</i>&nbsp;	private void refreshToolsMenu(List&lt;PathTool&gt; tools, Menu menu) {
<b class="fc"><i>1202</i>&nbsp;		menu.getItems().setAll(tools.stream().map(t -&gt; ActionTools.createCheckMenuItem(getToolAction(t))).collect(Collectors.toList()));</b>
<b class="fc"><i>1203</i>&nbsp;	}</b>
<i>1204</i>&nbsp;	
<i>1205</i>&nbsp;	
<i>1206</i>&nbsp;	private void showStartupMessage() {
<b class="fc"><i>1207</i>&nbsp;		File fileStartup = new File(&quot;STARTUP.md&quot;);</b>
<b class="fc"><i>1208</i>&nbsp;		if (!fileStartup.exists()) {</b>
<b class="fc"><i>1209</i>&nbsp;			fileStartup = new File(&quot;app&quot;, fileStartup.getName());</b>
<b class="fc"><i>1210</i>&nbsp;			if (!fileStartup.exists()) {</b>
<b class="fc"><i>1211</i>&nbsp;				logger.trace(&quot;No startup file found in {}&quot;, fileStartup.getAbsolutePath());</b>
<b class="fc"><i>1212</i>&nbsp;				return;</b>
<i>1213</i>&nbsp;			}
<i>1214</i>&nbsp;		}
<i>1215</i>&nbsp;		try {
<b class="nc"><i>1216</i>&nbsp;			TextArea textArea = new TextArea();</b>
<b class="nc"><i>1217</i>&nbsp;			String text = GeneralTools.readFileAsString(fileStartup.getAbsolutePath());</b>
<b class="nc"><i>1218</i>&nbsp;			textArea.setText(text);</b>
<b class="nc"><i>1219</i>&nbsp;			textArea.setWrapText(true);</b>
<b class="nc"><i>1220</i>&nbsp;			textArea.setEditable(false);</b>
<b class="nc"><i>1221</i>&nbsp;			Platform.runLater(() -&gt; {</b>
<b class="nc"><i>1222</i>&nbsp;				Stage stage = new Stage();</b>
<b class="nc"><i>1223</i>&nbsp;				stage.setTitle(&quot;QuPath&quot;);</b>
<b class="nc"><i>1224</i>&nbsp;				stage.initOwner(getStage());</b>
<b class="nc"><i>1225</i>&nbsp;				Scene scene = new Scene(textArea);</b>
<b class="nc"><i>1226</i>&nbsp;				textArea.setPrefHeight(500);</b>
<b class="nc"><i>1227</i>&nbsp;				stage.setScene(scene);</b>
<b class="nc"><i>1228</i>&nbsp;				textArea.addEventHandler(MouseEvent.MOUSE_CLICKED, e -&gt; {</b>
<b class="nc"><i>1229</i>&nbsp;					if (e.getClickCount() == 2)</b>
<b class="nc"><i>1230</i>&nbsp;						stage.hide();</b>
<b class="nc"><i>1231</i>&nbsp;				});</b>
<b class="nc"><i>1232</i>&nbsp;				stage.showAndWait();</b>
<i>1233</i>&nbsp;//				DisplayHelpers.showMessageDialog(
<i>1234</i>&nbsp;//						&quot;QuPath&quot;,
<i>1235</i>&nbsp;//						textArea);
<b class="nc"><i>1236</i>&nbsp;			});</b>
<b class="nc"><i>1237</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>1238</i>&nbsp;			logger.error(&quot;Error reading &quot; + fileStartup.getAbsolutePath(), e);</b>
<b class="nc"><i>1239</i>&nbsp;		}</b>
<b class="nc"><i>1240</i>&nbsp;	}</b>
<i>1241</i>&nbsp;	
<i>1242</i>&nbsp;	/**
<i>1243</i>&nbsp;	 * Static method to launch QuPath on the JavaFX Application thread.
<i>1244</i>&nbsp;	 * &lt;p&gt;
<i>1245</i>&nbsp;	 * This can potentially be used from other environments (e.g. MATLAB, Fiji, Python).
<i>1246</i>&nbsp;	 * It is assumed that it is being launched from a JavaFX (without {@link HostServices} available) or AWT/Swing application; 
<i>1247</i>&nbsp;	 * if this is not the case, use {@link #launchQuPath(HostServices, boolean)} instead.
<i>1248</i>&nbsp;	 * &lt;p&gt;
<i>1249</i>&nbsp;	 * Afterwards, calls to {@link #getInstance()} will return the QuPath instance as soon as it is available.
<i>1250</i>&nbsp;	 * However, note that depending upon the thread from which this method is called, the QuPath instance may &lt;i&gt;not&lt;/i&gt; 
<i>1251</i>&nbsp;	 * be available until some time after the method returns.
<i>1252</i>&nbsp;	 * &lt;p&gt;
<i>1253</i>&nbsp;	 * If there is already an instance of QuPath running, this ensures that it is visible - but otherwise does nothing.
<i>1254</i>&nbsp;	 */
<i>1255</i>&nbsp;	public static void launchQuPath() {
<b class="nc"><i>1256</i>&nbsp;		launchQuPath(null, true);</b>
<b class="nc"><i>1257</i>&nbsp;	}</b>
<i>1258</i>&nbsp;	
<i>1259</i>&nbsp;	/**
<i>1260</i>&nbsp;	 * Launch QuPath from an AWT/Swing application.
<i>1261</i>&nbsp;	 * Equivalent to calling {@code #launchQuPath(hostServices, true)}
<i>1262</i>&nbsp;	 * @param hostServices
<i>1263</i>&nbsp;	 * @deprecated as of v0.2.3 in favor of {@link #launchQuPath(HostServices, boolean)}
<i>1264</i>&nbsp;	 */
<i>1265</i>&nbsp;	@Deprecated
<i>1266</i>&nbsp;	public static void launchQuPath(HostServices hostServices) {
<b class="nc"><i>1267</i>&nbsp;		launchQuPath(hostServices, true);</b>
<b class="nc"><i>1268</i>&nbsp;	}</b>
<i>1269</i>&nbsp;	
<i>1270</i>&nbsp;	/**
<i>1271</i>&nbsp;	 * Static method to launch QuPath on the JavaFX Application thread.
<i>1272</i>&nbsp;	 * &lt;p&gt;
<i>1273</i>&nbsp;	 * This can potentially be used from other environments (e.g. MATLAB, Fiji, Python).
<i>1274</i>&nbsp;	 * Afterwards, calls to {@link #getInstance()} will return the QuPath instance as soon as it is available.
<i>1275</i>&nbsp;	 * However, note that depending upon the thread from which this method is called, the QuPath instance may &lt;i&gt;not&lt;/i&gt; 
<i>1276</i>&nbsp;	 * be available until some time after the method returns.
<i>1277</i>&nbsp;	 * &lt;p&gt;
<i>1278</i>&nbsp;	 * If there is already an instance of QuPath running, this requests that it is made visible - but otherwise does nothing.
<i>1279</i>&nbsp;	 * 
<i>1280</i>&nbsp;	 * @param hostServices JavaFX HostServices if available, otherwise null
<i>1281</i>&nbsp;	 * @param isSwing if true, it is assumed that the launch is being requested from another Swing-based Java application.
<i>1282</i>&nbsp;	 *                This results in an alternative method of starting the JavaFX runtime, which may be more reliable. 
<i>1283</i>&nbsp;	 *                However, when called from a non-swing app in some cases the thread may freeze.
<i>1284</i>&nbsp;	 */
<i>1285</i>&nbsp;	public static void launchQuPath(HostServices hostServices, boolean isSwing) {
<i>1286</i>&nbsp;		
<b class="nc"><i>1287</i>&nbsp;		QuPathGUI instance = getInstance();</b>
<b class="nc"><i>1288</i>&nbsp;		if (instance != null) {</b>
<b class="nc"><i>1289</i>&nbsp;			logger.info(&quot;Request to launch QuPath - will try to show existing instance instead&quot;);</b>
<b class="nc"><i>1290</i>&nbsp;			if (Platform.isFxApplicationThread())</b>
<b class="nc"><i>1291</i>&nbsp;				instance.getStage().show();</b>
<i>1292</i>&nbsp;			else {
<b class="nc"><i>1293</i>&nbsp;				Platform.runLater(() -&gt; instance.getStage().show());</b>
<i>1294</i>&nbsp;			}
<b class="nc"><i>1295</i>&nbsp;			return;</b>
<i>1296</i>&nbsp;		}
<i>1297</i>&nbsp;		
<b class="nc"><i>1298</i>&nbsp;		if (Platform.isFxApplicationThread()) {</b>
<b class="nc"><i>1299</i>&nbsp;			System.out.println(&quot;Launching new QuPath instance...&quot;);</b>
<b class="nc"><i>1300</i>&nbsp;			logger.info(&quot;Launching new QuPath instance...&quot;);</b>
<b class="nc"><i>1301</i>&nbsp;			Stage stage = new Stage();</b>
<b class="nc"><i>1302</i>&nbsp;			QuPathGUI qupath = new QuPathGUI(hostServices, stage, (String)null, false, false);</b>
<b class="nc"><i>1303</i>&nbsp;			qupath.getStage().show();</b>
<b class="nc"><i>1304</i>&nbsp;			System.out.println(&quot;Done!&quot;);</b>
<b class="nc"><i>1305</i>&nbsp;			return;</b>
<i>1306</i>&nbsp;		}
<i>1307</i>&nbsp;		
<b class="nc"><i>1308</i>&nbsp;		System.out.println(&quot;QuPath launch requested in &quot; + Thread.currentThread());</b>
<i>1309</i>&nbsp;		
<b class="nc"><i>1310</i>&nbsp;		if (isSwing) {</b>
<i>1311</i>&nbsp;			// If we are starting from a Swing application, try to ensure we are on the correct thread
<i>1312</i>&nbsp;			// (This can be particularly important on macOS)
<b class="nc"><i>1313</i>&nbsp;			if (SwingUtilities.isEventDispatchThread()) {</b>
<b class="nc"><i>1314</i>&nbsp;				System.out.println(&quot;Initializing with JFXPanel...&quot;);</b>
<b class="nc"><i>1315</i>&nbsp;				new JFXPanel(); // To initialize</b>
<b class="nc"><i>1316</i>&nbsp;				Platform.runLater(() -&gt; launchQuPath(hostServices, true));</b>
<b class="nc"><i>1317</i>&nbsp;				return;</b>
<i>1318</i>&nbsp;			} else {
<b class="nc"><i>1319</i>&nbsp;				SwingUtilities.invokeLater(() -&gt; launchQuPath(hostServices, true));</b>
<i>1320</i>&nbsp;				// Required to be able to restart QuPath... or probably any JavaFX application
<b class="nc"><i>1321</i>&nbsp;				Platform.setImplicitExit(false);</b>
<i>1322</i>&nbsp;			}
<i>1323</i>&nbsp;		} else {
<i>1324</i>&nbsp;			try {
<i>1325</i>&nbsp;				// This will fail if already started... but unfortunately there is no method to query if this is the case
<b class="nc"><i>1326</i>&nbsp;				System.out.println(&quot;Calling Platform.startup()...&quot;);</b>
<b class="nc"><i>1327</i>&nbsp;				Platform.startup(() -&gt; launchQuPath(hostServices, false));</b>
<b class="nc"><i>1328</i>&nbsp;			} catch (Exception e) {</b>
<b class="nc"><i>1329</i>&nbsp;				System.err.println(&quot;If JavaFX is initialized, be sure to call launchQuPath() on the Application thread!&quot;);</b>
<b class="nc"><i>1330</i>&nbsp;				System.out.println(&quot;Calling Platform.runLater()...&quot;);</b>
<b class="nc"><i>1331</i>&nbsp;				Platform.runLater(() -&gt; launchQuPath(hostServices, false));</b>
<b class="nc"><i>1332</i>&nbsp;			}</b>
<i>1333</i>&nbsp;		}
<i>1334</i>&nbsp;		
<b class="nc"><i>1335</i>&nbsp;	}</b>
<i>1336</i>&nbsp;	
<i>1337</i>&nbsp;	
<i>1338</i>&nbsp;	
<i>1339</i>&nbsp;	/**
<i>1340</i>&nbsp;	 * Try to launch a browser window for a specified URL.
<i>1341</i>&nbsp;	 * 
<i>1342</i>&nbsp;	 * @param url the URL to open in the browser
<i>1343</i>&nbsp;	 * @return true if this was (as far as we know...) successful, and false otherwise
<i>1344</i>&nbsp;	 */
<i>1345</i>&nbsp;	public static boolean launchBrowserWindow(final String url) {
<b class="nc"><i>1346</i>&nbsp;		var instance = getInstance();</b>
<b class="nc"><i>1347</i>&nbsp;		if (instance != null &amp;&amp; instance.hostServices != null) {</b>
<b class="nc"><i>1348</i>&nbsp;			logger.debug(&quot;Showing URL with host services: {}&quot;, url);</b>
<b class="nc"><i>1349</i>&nbsp;			instance.hostServices.showDocument(url);</b>
<b class="nc"><i>1350</i>&nbsp;			return true;</b>
<i>1351</i>&nbsp;		}
<b class="nc"><i>1352</i>&nbsp;		if (Desktop.isDesktopSupported() &amp;&amp; Desktop.getDesktop().isSupported(Desktop.Action.APP_OPEN_URI)) {</b>
<i>1353</i>&nbsp;			try {
<b class="nc"><i>1354</i>&nbsp;				Desktop.getDesktop().browse(new URI(url));</b>
<b class="nc"><i>1355</i>&nbsp;				return true;</b>
<b class="nc"><i>1356</i>&nbsp;			} catch (Exception e) {</b>
<b class="nc"><i>1357</i>&nbsp;				logger.error(&quot;Failed to launch browser window for {}&quot;, url, e);</b>
<b class="nc"><i>1358</i>&nbsp;				return false;</b>
<i>1359</i>&nbsp;			}
<i>1360</i>&nbsp;		} else {
<b class="nc"><i>1361</i>&nbsp;			Dialogs.showErrorMessage(&quot;Show URL&quot;, &quot;Sorry, unable to launch a browser to open \n&quot; + url);</b>
<b class="nc"><i>1362</i>&nbsp;			return false;</b>
<i>1363</i>&nbsp;		}
<i>1364</i>&nbsp;	}
<i>1365</i>&nbsp;	
<i>1366</i>&nbsp;	
<i>1367</i>&nbsp;	/**
<i>1368</i>&nbsp;	 * Directory containing extensions.
<i>1369</i>&nbsp;	 * 
<i>1370</i>&nbsp;	 * This can contain any jars - all will be added to the search path when starting QuPath.
<i>1371</i>&nbsp;	 * 
<i>1372</i>&nbsp;	 * @return
<i>1373</i>&nbsp;	 */
<i>1374</i>&nbsp;	public static File getExtensionDirectory() {
<b class="fc"><i>1375</i>&nbsp;		String path = PathPrefs.getExtensionsPath();</b>
<b class="fc"><i>1376</i>&nbsp;		if (path == null || path.trim().length() == 0)</b>
<b class="fc"><i>1377</i>&nbsp;			return null;</b>
<b class="nc"><i>1378</i>&nbsp;		File dir = new File(path);</b>
<b class="nc"><i>1379</i>&nbsp;		return dir;</b>
<i>1380</i>&nbsp;	}
<i>1381</i>&nbsp;	
<i>1382</i>&nbsp;	
<i>1383</i>&nbsp;	/**
<i>1384</i>&nbsp;	 * Get the default location for extensions.
<i>1385</i>&nbsp;	 * 
<i>1386</i>&nbsp;	 * This is platform and user-specific.  It isn&#39;t necessarily used (and doesn&#39;t necessarily exist).
<i>1387</i>&nbsp;	 * 
<i>1388</i>&nbsp;	 * @return
<i>1389</i>&nbsp;	 */
<i>1390</i>&nbsp;	private static File getDefaultQuPathUserDirectory() {
<b class="nc"><i>1391</i>&nbsp;		return new File(System.getProperty(&quot;user.home&quot;), &quot;QuPath&quot;);</b>
<i>1392</i>&nbsp;	}
<i>1393</i>&nbsp;	
<i>1394</i>&nbsp;	
<i>1395</i>&nbsp;	
<i>1396</i>&nbsp;	/**
<i>1397</i>&nbsp;	 * Check if extensions can be installed.
<i>1398</i>&nbsp;	 * 
<i>1399</i>&nbsp;	 * Generally, extensions can only be added if running from within a jar.
<i>1400</i>&nbsp;	 * 
<i>1401</i>&nbsp;	 * @return
<i>1402</i>&nbsp;	 */
<i>1403</i>&nbsp;	public boolean canInstallExtensions() {
<b class="nc"><i>1404</i>&nbsp;		return true;</b>
<i>1405</i>&nbsp;	}
<i>1406</i>&nbsp;		
<i>1407</i>&nbsp;	/**
<i>1408</i>&nbsp;	 * Get the directory containing the QuPath code
<i>1409</i>&nbsp;	 * @return {@link File} object representing the code directory, or null if this cannot be determined
<i>1410</i>&nbsp;	 */
<i>1411</i>&nbsp;	File getCodeDirectory() {
<b class="nc"><i>1412</i>&nbsp;		URI uri = null;</b>
<i>1413</i>&nbsp;		try {
<b class="nc"><i>1414</i>&nbsp;			if (hostServices != null) {</b>
<b class="nc"><i>1415</i>&nbsp;				String code = hostServices.getCodeBase();</b>
<b class="nc"><i>1416</i>&nbsp;				if (code == null || code.isBlank())</b>
<b class="nc"><i>1417</i>&nbsp;					code = hostServices.getDocumentBase();</b>
<b class="nc"><i>1418</i>&nbsp;				if (code != null &amp;&amp; code.isBlank()) {</b>
<b class="nc"><i>1419</i>&nbsp;					uri = GeneralTools.toURI(code);</b>
<b class="nc"><i>1420</i>&nbsp;					return new File(uri);</b>
<i>1421</i>&nbsp;				}
<i>1422</i>&nbsp;			}
<b class="nc"><i>1423</i>&nbsp;		} catch (URISyntaxException e) {</b>
<b class="nc"><i>1424</i>&nbsp;			logger.debug(&quot;Exception converting to URI: &quot; + e.getLocalizedMessage(), e);</b>
<b class="nc"><i>1425</i>&nbsp;		}</b>
<i>1426</i>&nbsp;		try {
<b class="nc"><i>1427</i>&nbsp;			return Paths.get(</b>
<i>1428</i>&nbsp;					QuPathGUI.class
<b class="nc"><i>1429</i>&nbsp;					.getProtectionDomain()</b>
<b class="nc"><i>1430</i>&nbsp;					.getCodeSource()</b>
<b class="nc"><i>1431</i>&nbsp;					.getLocation()</b>
<b class="nc"><i>1432</i>&nbsp;					.toURI()).getParent().toFile();</b>
<b class="nc"><i>1433</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>1434</i>&nbsp;			logger.error(&quot;Error identifying code directory: &quot; + e.getLocalizedMessage(), e);</b>
<b class="nc"><i>1435</i>&nbsp;			return null;</b>
<i>1436</i>&nbsp;		}
<i>1437</i>&nbsp;	}
<i>1438</i>&nbsp;	
<i>1439</i>&nbsp;	/**
<i>1440</i>&nbsp;	 * Do an update check.
<i>1441</i>&nbsp;	 * @param isAutoCheck if true, avoid prompting the user unless an update is available. If false, the update has been explicitly 
<i>1442</i>&nbsp;	 *                    requested and so the user should be notified of the outcome, regardless of whether an update is found.
<i>1443</i>&nbsp;	 */
<i>1444</i>&nbsp;	private synchronized void doUpdateCheck(boolean isAutoCheck) {
<i>1445</i>&nbsp;		
<b class="nc"><i>1446</i>&nbsp;		var currentVersion = getVersion();</b>
<b class="nc"><i>1447</i>&nbsp;		String updateMessage = null;</b>
<b class="nc"><i>1448</i>&nbsp;		boolean isError = false;</b>
<b class="nc"><i>1449</i>&nbsp;		if (currentVersion == null || currentVersion == Version.UNKNOWN) {</b>
<b class="nc"><i>1450</i>&nbsp;			updateMessage = &quot;I can&#39;t tell which version of QuPath you are running!&quot;;</b>
<b class="nc"><i>1451</i>&nbsp;			if (isAutoCheck) {</b>
<b class="nc"><i>1452</i>&nbsp;				logger.warn(&quot;Cannot check for updates - &quot; + updateMessage);</b>
<b class="nc"><i>1453</i>&nbsp;				return;</b>
<i>1454</i>&nbsp;			}
<i>1455</i>&nbsp;		} else {
<b class="nc"><i>1456</i>&nbsp;			String title = &quot;Update check&quot;;</b>
<b class="nc"><i>1457</i>&nbsp;			Version version = null;</b>
<i>1458</i>&nbsp;			try {
<b class="nc"><i>1459</i>&nbsp;				logger.info(&quot;Performing update check...&quot;);</b>
<b class="nc"><i>1460</i>&nbsp;				version = UpdateChecker.checkForUpdate();</b>
<b class="nc"><i>1461</i>&nbsp;				PathPrefs.getUserPreferences().putLong(&quot;lastUpdateCheck&quot;, System.currentTimeMillis());</b>
<b class="nc"><i>1462</i>&nbsp;			} catch (Exception e) {</b>
<b class="nc"><i>1463</i>&nbsp;				logger.error(&quot;Unable to check for update: {}&quot;, e.getLocalizedMessage());</b>
<b class="nc"><i>1464</i>&nbsp;				logger.debug(e.getLocalizedMessage(), e);</b>
<b class="nc"><i>1465</i>&nbsp;			}</b>
<i>1466</i>&nbsp;			// If we couldn&#39;t determine the version, tell the user only if this isn&#39;t the automatic check
<b class="nc"><i>1467</i>&nbsp;			if (version == null) {</b>
<b class="nc"><i>1468</i>&nbsp;				if (isAutoCheck)</b>
<b class="nc"><i>1469</i>&nbsp;					return;</b>
<i>1470</i>&nbsp;				else {
<b class="nc"><i>1471</i>&nbsp;					updateMessage = &quot;Sorry, I can&#39;t check for updates at this time.&quot;;</b>
<b class="nc"><i>1472</i>&nbsp;					isError = true;</b>
<i>1473</i>&nbsp;				}
<i>1474</i>&nbsp;			}
<b class="nc"><i>1475</i>&nbsp;			if (version.compareTo(currentVersion) &gt; 0) {</b>
<b class="nc"><i>1476</i>&nbsp;				updateMessage = &quot;QuPath &quot; + version.toString() + &quot; is available, you are running &quot; + currentVersion.toString();</b>
<i>1477</i>&nbsp;			} else {
<b class="nc"><i>1478</i>&nbsp;				logger.info(&quot;Current version {}, latest stable release {} - nothing to update&quot;, currentVersion, version);</b>
<b class="nc"><i>1479</i>&nbsp;				if (!isAutoCheck)</b>
<b class="nc"><i>1480</i>&nbsp;					Dialogs.showMessageDialog(title, &quot;QuPath &quot; + currentVersion + &quot; is up to date!&quot;);</b>
<b class="nc"><i>1481</i>&nbsp;				return;</b>
<i>1482</i>&nbsp;			}
<i>1483</i>&nbsp;		}
<i>1484</i>&nbsp;		
<b class="nc"><i>1485</i>&nbsp;		var label = new Label(updateMessage + &quot;\n\nDo you want to open the QuPath website (https://qupath.github.io)?&quot;);</b>
<b class="nc"><i>1486</i>&nbsp;		label.setPadding(new Insets(0, 0, 20, 0));</b>
<b class="nc"><i>1487</i>&nbsp;		var pane = new BorderPane(label);</b>
<b class="nc"><i>1488</i>&nbsp;		var checkbox = new CheckBox(&quot;Automatically check for updates on startup&quot;);</b>
<b class="nc"><i>1489</i>&nbsp;		checkbox.setSelected(PathPrefs.doAutoUpdateCheckProperty().get());</b>
<b class="nc"><i>1490</i>&nbsp;		checkbox.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>1491</i>&nbsp;		pane.setBottom(checkbox);</b>
<i>1492</i>&nbsp;		
<b class="nc"><i>1493</i>&nbsp;		var dialog = Dialogs.builder()</b>
<b class="nc"><i>1494</i>&nbsp;				.title(&quot;Update check&quot;)</b>
<b class="nc"><i>1495</i>&nbsp;				.content(pane)</b>
<b class="nc"><i>1496</i>&nbsp;				.alertType(isError ? AlertType.ERROR : AlertType.INFORMATION)</b>
<b class="nc"><i>1497</i>&nbsp;				.buttons(ButtonType.YES, ButtonType.NO, ButtonType.CANCEL);</b>
<b class="nc"><i>1498</i>&nbsp;		var response = dialog.showAndWait().orElse(ButtonType.CANCEL);</b>
<b class="nc"><i>1499</i>&nbsp;		if (response != ButtonType.CANCEL)</b>
<b class="nc"><i>1500</i>&nbsp;			PathPrefs.doAutoUpdateCheckProperty().set(checkbox.isSelected());</b>
<b class="nc"><i>1501</i>&nbsp;		if (response == ButtonType.YES) {</b>
<b class="nc"><i>1502</i>&nbsp;			launchBrowserWindow(&quot;https://qupath.github.io&quot;);</b>
<i>1503</i>&nbsp;		}
<b class="nc"><i>1504</i>&nbsp;	}</b>
<i>1505</i>&nbsp;	
<i>1506</i>&nbsp;	
<i>1507</i>&nbsp;	
<i>1508</i>&nbsp;	/**
<i>1509</i>&nbsp;	 * Check for any updates.
<i>1510</i>&nbsp;	 * 
<i>1511</i>&nbsp;	 * @param isAutoCheck if true, the check will only be performed if the auto-update preferences allow it, 
<i>1512</i>&nbsp;	 * 					  and the user won&#39;t be prompted if no update is available.
<i>1513</i>&nbsp;	 */
<i>1514</i>&nbsp;	void checkForUpdate(final boolean isAutoCheck) {
<i>1515</i>&nbsp;		
<b class="nc"><i>1516</i>&nbsp;		if (isAutoCheck) {</b>
<i>1517</i>&nbsp;			// Don&#39;t run auto check if the user doesn&#39;t want it
<b class="nc"><i>1518</i>&nbsp;			boolean doAutoUpdateCheck = PathPrefs.doAutoUpdateCheckProperty().get();</b>
<b class="nc"><i>1519</i>&nbsp;			if (!doAutoUpdateCheck)</b>
<b class="nc"><i>1520</i>&nbsp;				return;</b>
<i>1521</i>&nbsp;
<i>1522</i>&nbsp;			// Don&#39;t run auto-update check again if we already checked within the last hour
<b class="nc"><i>1523</i>&nbsp;			long currentTime = System.currentTimeMillis();</b>
<b class="nc"><i>1524</i>&nbsp;			long lastUpdateCheck = PathPrefs.getUserPreferences().getLong(&quot;lastUpdateCheck&quot;, 0);</b>
<b class="nc"><i>1525</i>&nbsp;			double diffHours = (double)(currentTime - lastUpdateCheck) / (60L * 60L * 1000L);</b>
<b class="nc"><i>1526</i>&nbsp;			if (diffHours &lt; 1) {</b>
<b class="nc"><i>1527</i>&nbsp;				logger.trace(&quot;Skipping update check (I already checked recently)&quot;);</b>
<b class="nc"><i>1528</i>&nbsp;				return;</b>
<i>1529</i>&nbsp;			}
<i>1530</i>&nbsp;		}
<i>1531</i>&nbsp;		// Run the check in a background thread
<b class="nc"><i>1532</i>&nbsp;		createSingleThreadExecutor(this).execute(() -&gt; doUpdateCheck(isAutoCheck));</b>
<b class="nc"><i>1533</i>&nbsp;	}</b>
<i>1534</i>&nbsp;	
<i>1535</i>&nbsp;		
<i>1536</i>&nbsp;	/**
<i>1537</i>&nbsp;	 * Keep a record of loaded extensions, both for display and to avoid loading them twice.
<i>1538</i>&nbsp;	 */
<b class="fc"><i>1539</i>&nbsp;	private static Map&lt;Class&lt;? extends QuPathExtension&gt;, QuPathExtension&gt; loadedExtensions = new HashMap&lt;&gt;();</b>
<i>1540</i>&nbsp;	
<i>1541</i>&nbsp;	/**
<i>1542</i>&nbsp;	 * @return a collection of extensions that are currently loaded
<i>1543</i>&nbsp;	 */
<i>1544</i>&nbsp;	public Collection&lt;QuPathExtension&gt; getLoadedExtensions() {
<b class="nc"><i>1545</i>&nbsp;		return loadedExtensions.values();</b>
<i>1546</i>&nbsp;	}
<i>1547</i>&nbsp;	
<i>1548</i>&nbsp;	/**
<i>1549</i>&nbsp;	 * Check the extensions directory, loading any new extensions found there.
<i>1550</i>&nbsp;	 * @param showNotification if true, display a notification if a new extension has been loaded
<i>1551</i>&nbsp;	 */
<i>1552</i>&nbsp;	public void refreshExtensions(final boolean showNotification) {
<b class="fc"><i>1553</i>&nbsp;		boolean initializing = initializingMenus.get();</b>
<b class="fc"><i>1554</i>&nbsp;		initializingMenus.set(true);</b>
<i>1555</i>&nbsp;		
<i>1556</i>&nbsp;		// Refresh the extensions
<b class="fc"><i>1557</i>&nbsp;		extensionClassLoader.refresh();</b>
<b class="fc"><i>1558</i>&nbsp;		extensionLoader.reload();</b>
<i>1559</i>&nbsp;		// Sort the extensions by name, to ensure predictable loading order
<i>1560</i>&nbsp;		// (also, menus are in a better order if ImageJ extension installed before OpenCV extension)
<b class="fc"><i>1561</i>&nbsp;		List&lt;QuPathExtension&gt; extensions = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>1562</i>&nbsp;		Iterator&lt;QuPathExtension&gt; iterator = extensionLoader.iterator();</b>
<b class="fc"><i>1563</i>&nbsp;		while (iterator.hasNext()) {</b>
<i>1564</i>&nbsp;			try {
<b class="fc"><i>1565</i>&nbsp;				extensions.add(iterator.next());</b>
<b class="nc"><i>1566</i>&nbsp;			} catch (Throwable e) {</b>
<b class="nc"><i>1567</i>&nbsp;				if (getStage() != null &amp;&amp; getStage().isShowing()) {</b>
<b class="nc"><i>1568</i>&nbsp;					Dialogs.showErrorMessage(&quot;Extension error&quot;, &quot;Error loading extension - check &#39;View -&gt; Show log&#39; for details.&quot;);</b>
<i>1569</i>&nbsp;				}
<b class="nc"><i>1570</i>&nbsp;				logger.error(e.getLocalizedMessage(), e);</b>
<b class="fc"><i>1571</i>&nbsp;			}</b>
<i>1572</i>&nbsp;		}
<b class="fc"><i>1573</i>&nbsp;		Collections.sort(extensions, Comparator.comparing(QuPathExtension::getName));</b>
<b class="fc"><i>1574</i>&nbsp;		for (QuPathExtension extension : extensions) {</b>
<b class="fc"><i>1575</i>&nbsp;			if (!loadedExtensions.containsKey(extension.getClass())) {</b>
<i>1576</i>&nbsp;				try {
<b class="fc"><i>1577</i>&nbsp;					long startTime = System.currentTimeMillis();</b>
<b class="fc"><i>1578</i>&nbsp;					extension.installExtension(this);</b>
<b class="fc"><i>1579</i>&nbsp;					long endTime = System.currentTimeMillis();</b>
<b class="fc"><i>1580</i>&nbsp;					logger.info(&quot;Loaded extension {} ({} ms)&quot;, extension.getName(), endTime - startTime);</b>
<b class="fc"><i>1581</i>&nbsp;					loadedExtensions.put(extension.getClass(), extension);</b>
<b class="fc"><i>1582</i>&nbsp;					if (showNotification)</b>
<b class="nc"><i>1583</i>&nbsp;						Dialogs.showInfoNotification(&quot;Extension loaded&quot;,  extension.getName());</b>
<b class="nc"><i>1584</i>&nbsp;				} catch (Exception | LinkageError e) {</b>
<b class="nc"><i>1585</i>&nbsp;					if (showNotification)</b>
<b class="nc"><i>1586</i>&nbsp;						Dialogs.showErrorNotification(&quot;Extension error&quot;, &quot;Unable to load &quot; + extension.getName());</b>
<b class="nc"><i>1587</i>&nbsp;					logger.error(&quot;Error loading extension &quot; + extension + &quot;: &quot; + e.getLocalizedMessage(), e);</b>
<i>1588</i>&nbsp;					try {
<b class="nc"><i>1589</i>&nbsp;						logger.error(&quot;It is recommended that you delete {} and restart QuPath&quot;,</b>
<b class="nc"><i>1590</i>&nbsp;								URLDecoder.decode(</b>
<b class="nc"><i>1591</i>&nbsp;										extension.getClass().getProtectionDomain().getCodeSource().getLocation().toExternalForm(),</b>
<i>1592</i>&nbsp;										StandardCharsets.UTF_8));
<b class="nc"><i>1593</i>&nbsp;					} catch (Exception e2) {</b>
<b class="nc"><i>1594</i>&nbsp;						logger.debug(&quot;Error finding code source &quot; + e2.getLocalizedMessage(), e2);</b>
<b class="nc"><i>1595</i>&nbsp;					}</b>
<b class="nc"><i>1596</i>&nbsp;					defaultActions.SHOW_LOG.handle(null);</b>
<b class="fc"><i>1597</i>&nbsp;				}</b>
<i>1598</i>&nbsp;			}
<b class="fc"><i>1599</i>&nbsp;		}</b>
<i>1600</i>&nbsp;		// Set the ImageServer to also look on the same search path
<b class="fc"><i>1601</i>&nbsp;		List&lt;ImageServerBuilder&lt;?&gt;&gt; serverBuildersBefore = ImageServerProvider.getInstalledImageServerBuilders();</b>
<b class="fc"><i>1602</i>&nbsp;		ImageServerProvider.setServiceLoader(ServiceLoader.load(ImageServerBuilder.class, extensionClassLoader));</b>
<b class="fc"><i>1603</i>&nbsp;		if (showNotification) {</b>
<i>1604</i>&nbsp;			// A bit convoluted... but try to show new servers that have been loaded by comparing with the past
<b class="nc"><i>1605</i>&nbsp;			List&lt;String&gt; serverBuilders = serverBuildersBefore.stream().map(s -&gt; s.getName()).collect(Collectors.toList());</b>
<b class="nc"><i>1606</i>&nbsp;			List&lt;String&gt; serverBuildersUpdated = ImageServerProvider.getInstalledImageServerBuilders().stream().map(s -&gt; s.getName()).collect(Collectors.toList());</b>
<b class="nc"><i>1607</i>&nbsp;			serverBuildersUpdated.removeAll(serverBuilders);</b>
<b class="nc"><i>1608</i>&nbsp;			for (String builderName : serverBuildersUpdated) {</b>
<b class="nc"><i>1609</i>&nbsp;				Dialogs.showInfoNotification(&quot;Image server loaded&quot;,  builderName);</b>
<b class="nc"><i>1610</i>&nbsp;			}</b>
<i>1611</i>&nbsp;		}
<i>1612</i>&nbsp;		
<b class="fc"><i>1613</i>&nbsp;		initializingMenus.set(initializing);</b>
<b class="fc"><i>1614</i>&nbsp;	}</b>
<i>1615</i>&nbsp;	
<i>1616</i>&nbsp;	/**
<i>1617</i>&nbsp;	 * Install extensions while QuPath is running.
<i>1618</i>&nbsp;	 * 
<i>1619</i>&nbsp;	 * @param files A collection of jar files for installation.
<i>1620</i>&nbsp;	 */
<i>1621</i>&nbsp;	public void installExtensions(final Collection&lt;File&gt; files) {
<b class="nc"><i>1622</i>&nbsp;		if (files.isEmpty()) {</b>
<b class="nc"><i>1623</i>&nbsp;			logger.debug(&quot;No extensions to install!&quot;);</b>
<b class="nc"><i>1624</i>&nbsp;			return;</b>
<i>1625</i>&nbsp;		}
<b class="nc"><i>1626</i>&nbsp;		if (!canInstallExtensions()) {</b>
<b class="nc"><i>1627</i>&nbsp;			Dialogs.showErrorMessage(&quot;Install extension&quot;, &quot;Cannot install extensions when not running QuPath from a .jar file (application), sorry!&quot;);</b>
<b class="nc"><i>1628</i>&nbsp;			return;</b>
<i>1629</i>&nbsp;		}
<b class="nc"><i>1630</i>&nbsp;		File dir = getExtensionDirectory();</b>
<b class="nc"><i>1631</i>&nbsp;		if (dir == null || !dir.isDirectory()) {</b>
<b class="nc"><i>1632</i>&nbsp;			logger.info(&quot;No extension directory found!&quot;);</b>
<i>1633</i>&nbsp;			// Prompt to create an extensions directory
<b class="nc"><i>1634</i>&nbsp;			File dirDefault = getDefaultQuPathUserDirectory();</b>
<i>1635</i>&nbsp;			String msg;
<b class="nc"><i>1636</i>&nbsp;			if (dirDefault.exists()) {</b>
<b class="nc"><i>1637</i>&nbsp;				msg = &quot;An directory already exists at &quot; + dirDefault.getAbsolutePath() + </b>
<i>1638</i>&nbsp;						&quot;\n\nDo you want to use this default, or specify another directory?&quot;;
<i>1639</i>&nbsp;			} else {
<b class="nc"><i>1640</i>&nbsp;				msg = &quot;QuPath can automatically create one at\n&quot; + dirDefault.getAbsolutePath() + </b>
<i>1641</i>&nbsp;						&quot;\n\nDo you want to use this default, or specify another directory?&quot;;
<i>1642</i>&nbsp;			}
<i>1643</i>&nbsp;			
<b class="nc"><i>1644</i>&nbsp;			Dialog&lt;ButtonType&gt; dialog = new Dialog&lt;&gt;();</b>
<b class="nc"><i>1645</i>&nbsp;			dialog.initOwner(getStage());</b>
<i>1646</i>&nbsp;
<b class="nc"><i>1647</i>&nbsp;			ButtonType btUseDefault = new ButtonType(&quot;Use default&quot;, ButtonData.YES);</b>
<b class="nc"><i>1648</i>&nbsp;			ButtonType btChooseDirectory = new ButtonType(&quot;Choose directory&quot;, ButtonData.NO);</b>
<b class="nc"><i>1649</i>&nbsp;			ButtonType btCancel = new ButtonType(&quot;Cancel&quot;, ButtonData.CANCEL_CLOSE);</b>
<b class="nc"><i>1650</i>&nbsp;			dialog.getDialogPane().getButtonTypes().setAll(btUseDefault, btChooseDirectory, btCancel);</b>
<i>1651</i>&nbsp;
<b class="nc"><i>1652</i>&nbsp;			dialog.setHeaderText(null);</b>
<b class="nc"><i>1653</i>&nbsp;			dialog.setTitle(&quot;Choose extensions directory&quot;);</b>
<b class="nc"><i>1654</i>&nbsp;			dialog.setContentText(&quot;No extensions directory is set.\n\n&quot; + msg);</b>
<b class="nc"><i>1655</i>&nbsp;			Optional&lt;ButtonType&gt; result = dialog.showAndWait();</b>
<b class="nc"><i>1656</i>&nbsp;			if (!result.isPresent() || result.get() == btCancel) {</b>
<b class="nc"><i>1657</i>&nbsp;				logger.info(&quot;No extension directory set - extensions not installed&quot;);</b>
<b class="nc"><i>1658</i>&nbsp;				return;</b>
<i>1659</i>&nbsp;			}
<b class="nc"><i>1660</i>&nbsp;			if (result.get() == btUseDefault) {</b>
<b class="nc"><i>1661</i>&nbsp;				if (!dirDefault.exists() &amp;&amp; !dirDefault.mkdirs()) {</b>
<b class="nc"><i>1662</i>&nbsp;					Dialogs.showErrorMessage(&quot;Extension error&quot;, &quot;Unable to create directory at \n&quot; + dirDefault.getAbsolutePath());</b>
<b class="nc"><i>1663</i>&nbsp;					return;</b>
<i>1664</i>&nbsp;				}
<b class="nc"><i>1665</i>&nbsp;				PathPrefs.userPathProperty().set(dirDefault.getAbsolutePath());</b>
<i>1666</i>&nbsp;			} else {
<b class="nc"><i>1667</i>&nbsp;				File dirUser = Dialogs.promptForDirectory(dirDefault);</b>
<b class="nc"><i>1668</i>&nbsp;				if (dirUser == null) {</b>
<b class="nc"><i>1669</i>&nbsp;					logger.info(&quot;No QuPath user directory set - extensions not installed&quot;);</b>
<b class="nc"><i>1670</i>&nbsp;					return;</b>
<i>1671</i>&nbsp;				}
<b class="nc"><i>1672</i>&nbsp;				PathPrefs.userPathProperty().set(dirUser.getAbsolutePath());</b>
<i>1673</i>&nbsp;			}
<i>1674</i>&nbsp;			// Now get the extensions directory (within the user directory)
<b class="nc"><i>1675</i>&nbsp;			dir = getExtensionDirectory();</b>
<i>1676</i>&nbsp;		}
<i>1677</i>&nbsp;		// Create directory if we need it
<b class="nc"><i>1678</i>&nbsp;		if (!dir.exists())</b>
<b class="nc"><i>1679</i>&nbsp;			dir.mkdir();</b>
<i>1680</i>&nbsp;		
<i>1681</i>&nbsp;		// Copy all files into extensions directory
<b class="nc"><i>1682</i>&nbsp;		Path dest = dir.toPath();</b>
<b class="nc"><i>1683</i>&nbsp;		for (File file : files) {</b>
<b class="nc"><i>1684</i>&nbsp;			Path source = file.toPath();</b>
<b class="nc"><i>1685</i>&nbsp;			Path destination = dest.resolve(source.getFileName());</b>
<b class="nc"><i>1686</i>&nbsp;			if (destination.toFile().exists()) {</b>
<i>1687</i>&nbsp;				// It would be better to check how many files will be overwritten in one go,
<i>1688</i>&nbsp;				// but this should be a pretty rare occurrence
<b class="nc"><i>1689</i>&nbsp;				if (!Dialogs.showConfirmDialog(&quot;Install extension&quot;, &quot;Overwrite &quot; + destination.toFile().getName() + &quot;?\n\nYou will have to restart QuPath to see the updates.&quot;))</b>
<b class="nc"><i>1690</i>&nbsp;					return;</b>
<i>1691</i>&nbsp;			}
<i>1692</i>&nbsp;			try {
<b class="nc"><i>1693</i>&nbsp;				Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);</b>
<b class="nc"><i>1694</i>&nbsp;			} catch (IOException e) {</b>
<b class="nc"><i>1695</i>&nbsp;				Dialogs.showErrorMessage(&quot;Extension error&quot;, file + &quot;\ncould not be copied, sorry&quot;);</b>
<b class="nc"><i>1696</i>&nbsp;				logger.error(&quot;Could not copy file {}&quot;, file, e);</b>
<b class="nc"><i>1697</i>&nbsp;				return;</b>
<b class="nc"><i>1698</i>&nbsp;			}</b>
<b class="nc"><i>1699</i>&nbsp;		}</b>
<b class="nc"><i>1700</i>&nbsp;		refreshExtensions(true);</b>
<b class="nc"><i>1701</i>&nbsp;	}</b>
<i>1702</i>&nbsp;	
<i>1703</i>&nbsp;	
<i>1704</i>&nbsp;	/**
<i>1705</i>&nbsp;	 * Initialize available PathClasses, either from saved list or defaults
<i>1706</i>&nbsp;	 */
<i>1707</i>&nbsp;	private void initializePathClasses() {
<b class="fc"><i>1708</i>&nbsp;		availablePathClasses = FXCollections.observableArrayList();</b>
<b class="fc"><i>1709</i>&nbsp;		List&lt;PathClass&gt; pathClasses = new ArrayList&lt;&gt;();		</b>
<i>1710</i>&nbsp;		try {
<b class="fc"><i>1711</i>&nbsp;			pathClasses.addAll(loadPathClasses());			</b>
<b class="nc"><i>1712</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>1713</i>&nbsp;			logger.error(&quot;Unable to load PathClasses&quot;, e);</b>
<b class="fc"><i>1714</i>&nbsp;		}</b>
<b class="fc"><i>1715</i>&nbsp;		if (pathClasses.isEmpty())</b>
<b class="nc"><i>1716</i>&nbsp;			resetAvailablePathClasses();</b>
<i>1717</i>&nbsp;		else
<b class="fc"><i>1718</i>&nbsp;			availablePathClasses.setAll(pathClasses);</b>
<b class="fc"><i>1719</i>&nbsp;		availablePathClasses.addListener((Change&lt;? extends PathClass&gt; c) -&gt; {</b>
<b class="nc"><i>1720</i>&nbsp;			Project&lt;?&gt; project = getProject();</b>
<b class="nc"><i>1721</i>&nbsp;			if (project != null) {</b>
<i>1722</i>&nbsp;				// Write the project, if necessary
<b class="nc"><i>1723</i>&nbsp;				project.setPathClasses(c.getList());</b>
<i>1724</i>&nbsp;//				if (project.setPathClasses(c.getList())
<i>1725</i>&nbsp;//					ProjectBrowser.syncProject(project);
<i>1726</i>&nbsp;			}
<b class="nc"><i>1727</i>&nbsp;		});</b>
<b class="fc"><i>1728</i>&nbsp;	}</b>
<i>1729</i>&nbsp;	
<i>1730</i>&nbsp;	
<i>1731</i>&nbsp;	/**
<i>1732</i>&nbsp;	 * Populate the availablePathClasses with a default list.
<i>1733</i>&nbsp;	 * 
<i>1734</i>&nbsp;	 * @return true if changes were mad to the available classes, false otherwise
<i>1735</i>&nbsp;	 */
<i>1736</i>&nbsp;	public boolean resetAvailablePathClasses() {
<b class="nc"><i>1737</i>&nbsp;		List&lt;PathClass&gt; pathClasses = Arrays.asList(</b>
<b class="nc"><i>1738</i>&nbsp;				PathClassFactory.getPathClassUnclassified(),</b>
<b class="nc"><i>1739</i>&nbsp;				PathClassFactory.getPathClass(PathClassFactory.StandardPathClasses.TUMOR),</b>
<b class="nc"><i>1740</i>&nbsp;				PathClassFactory.getPathClass(PathClassFactory.StandardPathClasses.STROMA),</b>
<b class="nc"><i>1741</i>&nbsp;				PathClassFactory.getPathClass(PathClassFactory.StandardPathClasses.IMMUNE_CELLS),</b>
<b class="nc"><i>1742</i>&nbsp;				PathClassFactory.getPathClass(PathClassFactory.StandardPathClasses.NECROSIS),</b>
<b class="nc"><i>1743</i>&nbsp;				PathClassFactory.getPathClass(PathClassFactory.StandardPathClasses.OTHER),</b>
<b class="nc"><i>1744</i>&nbsp;				PathClassFactory.getPathClass(PathClassFactory.StandardPathClasses.REGION),</b>
<b class="nc"><i>1745</i>&nbsp;				PathClassFactory.getPathClass(PathClassFactory.StandardPathClasses.IGNORE),</b>
<b class="nc"><i>1746</i>&nbsp;				PathClassFactory.getPathClass(PathClassFactory.StandardPathClasses.POSITIVE),</b>
<b class="nc"><i>1747</i>&nbsp;				PathClassFactory.getPathClass(PathClassFactory.StandardPathClasses.NEGATIVE)</b>
<i>1748</i>&nbsp;				);
<i>1749</i>&nbsp;		
<b class="nc"><i>1750</i>&nbsp;		if (availablePathClasses == null) {</b>
<b class="nc"><i>1751</i>&nbsp;			availablePathClasses = FXCollections.observableArrayList(pathClasses);</b>
<b class="nc"><i>1752</i>&nbsp;			return true;</b>
<i>1753</i>&nbsp;		} else
<b class="nc"><i>1754</i>&nbsp;			return availablePathClasses.setAll(pathClasses);</b>
<i>1755</i>&nbsp;	}
<i>1756</i>&nbsp;	
<i>1757</i>&nbsp;	/**
<i>1758</i>&nbsp;	 * Load PathClasses from preferences.
<i>1759</i>&nbsp;	 * Note that this also sets the color of any PathClass that is loads,
<i>1760</i>&nbsp;	 * and is really only intended for use when initializing.
<i>1761</i>&nbsp;	 * 
<i>1762</i>&nbsp;	 * @return
<i>1763</i>&nbsp;	 */
<i>1764</i>&nbsp;	private static List&lt;PathClass&gt; loadPathClasses() {
<b class="fc"><i>1765</i>&nbsp;		byte[] bytes = PathPrefs.getUserPreferences().getByteArray(&quot;defaultPathClasses&quot;, null);</b>
<b class="fc"><i>1766</i>&nbsp;		if (bytes == null || bytes.length == 0)</b>
<b class="nc"><i>1767</i>&nbsp;			return Collections.emptyList();</b>
<b class="fc"><i>1768</i>&nbsp;		ByteArrayInputStream stream = new ByteArrayInputStream(bytes);</b>
<b class="fc"><i>1769</i>&nbsp;		try (ObjectInputStream in = new ObjectInputStream(stream)) {</b>
<b class="fc"><i>1770</i>&nbsp;			List&lt;PathClass&gt; pathClassesOriginal = (List&lt;PathClass&gt;)in.readObject();</b>
<b class="fc"><i>1771</i>&nbsp;			List&lt;PathClass&gt; pathClasses = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>1772</i>&nbsp;			for (PathClass pathClass : pathClassesOriginal) {</b>
<b class="fc"><i>1773</i>&nbsp;				PathClass singleton = PathClassFactory.getSingletonPathClass(pathClass);</b>
<i>1774</i>&nbsp;				// Ensure the color is set
<b class="fc"><i>1775</i>&nbsp;				if (singleton != null &amp;&amp; pathClass.getColor() != null)</b>
<b class="fc"><i>1776</i>&nbsp;					singleton.setColor(pathClass.getColor());</b>
<b class="fc"><i>1777</i>&nbsp;				pathClasses.add(singleton);</b>
<b class="fc"><i>1778</i>&nbsp;			}</b>
<b class="fc"><i>1779</i>&nbsp;			return pathClasses;</b>
<b class="fc"><i>1780</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>1781</i>&nbsp;			logger.error(&quot;Error loading classes&quot;, e);</b>
<b class="nc"><i>1782</i>&nbsp;			return Collections.emptyList();</b>
<i>1783</i>&nbsp;		}
<i>1784</i>&nbsp;	}
<i>1785</i>&nbsp;
<i>1786</i>&nbsp;	
<i>1787</i>&nbsp;	/**
<i>1788</i>&nbsp;	 * Show a dialog requesting setup parameters
<i>1789</i>&nbsp;	 * 
<i>1790</i>&nbsp;	 * @return
<i>1791</i>&nbsp;	 */
<i>1792</i>&nbsp;	public boolean showSetupDialog() {
<i>1793</i>&nbsp;		// Show a setup message
<b class="nc"><i>1794</i>&nbsp;		Dialog&lt;ButtonType&gt; dialog = new Dialog&lt;&gt;();</b>
<b class="nc"><i>1795</i>&nbsp;		dialog.setTitle(&quot;QuPath setup&quot;);</b>
<b class="nc"><i>1796</i>&nbsp;		dialog.initOwner(getStage());</b>
<i>1797</i>&nbsp;
<i>1798</i>&nbsp;		// Try to get an image to display
<b class="nc"><i>1799</i>&nbsp;		Image img = loadIcon(128);</b>
<b class="nc"><i>1800</i>&nbsp;		BorderPane pane = new BorderPane();</b>
<b class="nc"><i>1801</i>&nbsp;		if (img != null) {</b>
<b class="nc"><i>1802</i>&nbsp;			StackPane imagePane = new StackPane(new ImageView(img));</b>
<b class="nc"><i>1803</i>&nbsp;			imagePane.setPadding(new Insets(10, 10, 10, 10));</b>
<b class="nc"><i>1804</i>&nbsp;			pane.setLeft(imagePane);</b>
<i>1805</i>&nbsp;		}
<i>1806</i>&nbsp;
<b class="nc"><i>1807</i>&nbsp;		Map&lt;String, Locale&gt; localeMap = Arrays.stream(Locale.getAvailableLocales()).collect(Collectors.toMap(l -&gt; l.getDisplayName(Locale.US), l -&gt; l));</b>
<b class="nc"><i>1808</i>&nbsp;		localeMap.remove(&quot;&quot;);</b>
<b class="nc"><i>1809</i>&nbsp;		List&lt;String&gt; localeList = new ArrayList&lt;&gt;(localeMap.keySet());</b>
<b class="nc"><i>1810</i>&nbsp;		Collections.sort(localeList);</b>
<i>1811</i>&nbsp;		
<b class="nc"><i>1812</i>&nbsp;		long maxMemoryMB = Runtime.getRuntime().maxMemory() / 1024 / 1024;</b>
<b class="nc"><i>1813</i>&nbsp;		String maxMemoryString = String.format(&quot;Current maximum memory is %.2f GB.&quot;, maxMemoryMB/1024.0);</b>
<i>1814</i>&nbsp;		
<b class="nc"><i>1815</i>&nbsp;		boolean canSetMemory = PathPrefs.hasJavaPreferences();</b>
<i>1816</i>&nbsp;
<b class="nc"><i>1817</i>&nbsp;		ParameterList paramsSetup = new ParameterList()</b>
<b class="nc"><i>1818</i>&nbsp;				.addTitleParameter(&quot;Memory&quot;);</b>
<i>1819</i>&nbsp;		
<b class="nc"><i>1820</i>&nbsp;		double originalMaxMemory = Math.ceil(maxMemoryMB/1024.0);</b>
<b class="nc"><i>1821</i>&nbsp;		if (canSetMemory) {</b>
<b class="nc"><i>1822</i>&nbsp;			paramsSetup.addEmptyParameter(&quot;Set the maximum memory used by QuPath.&quot;);</b>
<i>1823</i>&nbsp;//					.addEmptyParameter(maxMemoryString);
<i>1824</i>&nbsp;	
<b class="nc"><i>1825</i>&nbsp;			boolean lowMemory = maxMemoryMB &lt; 1024*6;</b>
<b class="nc"><i>1826</i>&nbsp;			if (lowMemory) {</b>
<b class="nc"><i>1827</i>&nbsp;				paramsSetup.addEmptyParameter(</b>
<i>1828</i>&nbsp;						&quot;It is suggested to increase the memory limit to approximately\nhalf of the RAM available on your computer.&quot;
<i>1829</i>&nbsp;						);
<i>1830</i>&nbsp;			}
<i>1831</i>&nbsp;			
<b class="nc"><i>1832</i>&nbsp;			paramsSetup.addDoubleParameter(&quot;maxMemoryGB&quot;, &quot;Maximum memory&quot;, originalMaxMemory, &quot;GB&quot;, &quot;Set the maximum memory for QuPath - consider using approximately half the total RAM for the system&quot;);</b>
<b class="nc"><i>1833</i>&nbsp;		} else {</b>
<b class="nc"><i>1834</i>&nbsp;			paramsSetup.addEmptyParameter(maxMemoryString)</b>
<b class="nc"><i>1835</i>&nbsp;				.addEmptyParameter(&quot;Sorry, I can&#39;t access the config file needed to change the max memory.\n&quot; +</b>
<i>1836</i>&nbsp;							&quot;See the QuPath installation instructions for more details.&quot;);
<i>1837</i>&nbsp;		}
<i>1838</i>&nbsp;		
<b class="nc"><i>1839</i>&nbsp;		paramsSetup.addTitleParameter(&quot;Region&quot;)</b>
<b class="nc"><i>1840</i>&nbsp;				.addEmptyParameter(&quot;Set the region for QuPath to use for displaying numbers and messages.\n&quot; + </b>
<i>1841</i>&nbsp;						&quot;Note: It is *highly recommended* to keep the default (English, US) region settings.\n&quot; +
<i>1842</i>&nbsp;						&quot;Support for regions that use different number formatting (e.g. commas as decimal marks)\n&quot; +
<i>1843</i>&nbsp;						&quot;is still experimental, and may give unexpected results.&quot;)
<b class="nc"><i>1844</i>&nbsp;				.addChoiceParameter(&quot;localeFormatting&quot;, &quot;Numbers &amp; dates&quot;, Locale.getDefault(Category.FORMAT).getDisplayName(), localeList, &quot;Choose region settings used to format numbers and dates&quot;)</b>
<i>1845</i>&nbsp;//				.addChoiceParameter(&quot;localeDisplay&quot;, &quot;Messages&quot;, Locale.getDefault(Category.DISPLAY).getDisplayName(), localeList, &quot;Choose region settings used for other formatting, e.g. in dialog boxes&quot;)
<b class="nc"><i>1846</i>&nbsp;				.addTitleParameter(&quot;Updates&quot;)</b>
<b class="nc"><i>1847</i>&nbsp;				.addBooleanParameter(&quot;checkForUpdates&quot;, &quot;Check for updates on startup (recommended)&quot;, PathPrefs.doAutoUpdateCheckProperty().get(), &quot;Specify whether to automatically prompt to download the latest QuPath on startup (required internet connection)&quot;)	</b>
<i>1848</i>&nbsp;				;
<i>1849</i>&nbsp;
<b class="nc"><i>1850</i>&nbsp;		ParameterPanelFX parameterPanel = new ParameterPanelFX(paramsSetup);</b>
<b class="nc"><i>1851</i>&nbsp;		pane.setCenter(parameterPanel.getPane());</b>
<i>1852</i>&nbsp;				
<i>1853</i>&nbsp;		Label labelMemory;
<b class="nc"><i>1854</i>&nbsp;		if (canSetMemory) {</b>
<b class="nc"><i>1855</i>&nbsp;			labelMemory = new Label(&quot;You will need to restart QuPath for memory changes to take effect&quot;);</b>
<b class="nc"><i>1856</i>&nbsp;			labelMemory.setStyle(&quot;-fx-font-weight: bold;&quot;);</b>
<b class="nc"><i>1857</i>&nbsp;			labelMemory.setMaxWidth(Double.MAX_VALUE);</b>
<b class="nc"><i>1858</i>&nbsp;			labelMemory.setAlignment(Pos.CENTER);</b>
<b class="nc"><i>1859</i>&nbsp;			labelMemory.setFont(Font.font(&quot;Arial&quot;));</b>
<b class="nc"><i>1860</i>&nbsp;			labelMemory.setPadding(new Insets(10, 10, 10, 10));</b>
<b class="nc"><i>1861</i>&nbsp;			pane.setBottom(labelMemory);</b>
<i>1862</i>&nbsp;		}
<i>1863</i>&nbsp;		
<i>1864</i>&nbsp;//		dialog.initStyle(StageStyle.UNDECORATED);
<b class="nc"><i>1865</i>&nbsp;		dialog.getDialogPane().setContent(pane);</b>
<b class="nc"><i>1866</i>&nbsp;		dialog.getDialogPane().getButtonTypes().setAll(ButtonType.APPLY, ButtonType.CANCEL);</b>
<i>1867</i>&nbsp;
<b class="nc"><i>1868</i>&nbsp;		Optional&lt;ButtonType&gt; result = dialog.showAndWait();</b>
<b class="nc"><i>1869</i>&nbsp;		if (!result.isPresent() || !ButtonType.APPLY.equals(result.get()))</b>
<b class="nc"><i>1870</i>&nbsp;			return false;</b>
<i>1871</i>&nbsp;		
<b class="nc"><i>1872</i>&nbsp;		Locale localeFormatting = localeMap.get(paramsSetup.getChoiceParameterValue(&quot;localeFormatting&quot;));</b>
<i>1873</i>&nbsp;//		Locale localeDisplay = localeMap.get(paramsSetup.getChoiceParameterValue(&quot;localeDisplay&quot;));
<i>1874</i>&nbsp;		
<b class="nc"><i>1875</i>&nbsp;		PathPrefs.defaultLocaleFormatProperty().set(localeFormatting);</b>
<i>1876</i>&nbsp;//		PathPrefs.defaultLocaleDisplayProperty().set(localeDisplay);
<i>1877</i>&nbsp;		
<b class="nc"><i>1878</i>&nbsp;		PathPrefs.doAutoUpdateCheckProperty().set(paramsSetup.getBooleanParameterValue(&quot;checkForUpdates&quot;));</b>
<i>1879</i>&nbsp;		
<b class="nc"><i>1880</i>&nbsp;		if (canSetMemory &amp;&amp; paramsSetup.containsKey(&quot;maxMemoryGB&quot;)) {</b>
<b class="nc"><i>1881</i>&nbsp;			int maxMemorySpecifiedMB = (int)(Math.round(paramsSetup.getDoubleParameterValue(&quot;maxMemoryGB&quot;) * 1024));</b>
<b class="nc"><i>1882</i>&nbsp;			if (maxMemorySpecifiedMB &gt;= 1024) {</b>
<b class="nc"><i>1883</i>&nbsp;				PathPrefs.maxMemoryMBProperty().set(maxMemorySpecifiedMB);</b>
<i>1884</i>&nbsp;			} else {
<b class="nc"><i>1885</i>&nbsp;				if (maxMemorySpecifiedMB &gt;= 0)</b>
<b class="nc"><i>1886</i>&nbsp;					Dialogs.showErrorNotification(&quot;Max memory setting&quot;, &quot;Specified maximum memory setting too low - it must be at least 1 GB&quot;);</b>
<i>1887</i>&nbsp;				else
<b class="nc"><i>1888</i>&nbsp;					logger.warn(&quot;Requested max memory must be at least 1 GB - specified value {} will be ignored&quot;, paramsSetup.getDoubleParameterValue(&quot;maxMemoryGB&quot;));</b>
<i>1889</i>&nbsp;//				PathPrefs.maxMemoryMBProperty().set(-1);
<i>1890</i>&nbsp;			}
<i>1891</i>&nbsp;		}
<i>1892</i>&nbsp;		
<i>1893</i>&nbsp;		// Try to update display
<b class="nc"><i>1894</i>&nbsp;		if (getStage() != null &amp;&amp; getStage().isShowing())</b>
<b class="nc"><i>1895</i>&nbsp;			updateListsAndTables(getStage().getScene().getRoot());</b>
<i>1896</i>&nbsp;		
<b class="nc"><i>1897</i>&nbsp;		return true;</b>
<i>1898</i>&nbsp;	}
<i>1899</i>&nbsp;	
<i>1900</i>&nbsp;	/**
<i>1901</i>&nbsp;	 * Make an effort at updating all the trees, tables or lists that we can find.
<i>1902</i>&nbsp;	 * 
<i>1903</i>&nbsp;	 * @param parent
<i>1904</i>&nbsp;	 */
<i>1905</i>&nbsp;	private static void updateListsAndTables(final Parent parent) {
<b class="nc"><i>1906</i>&nbsp;		if (parent == null)</b>
<b class="nc"><i>1907</i>&nbsp;			return;</b>
<b class="nc"><i>1908</i>&nbsp;		for (Node child : parent.getChildrenUnmodifiable()) {</b>
<b class="nc"><i>1909</i>&nbsp;			if (child instanceof TreeView&lt;?&gt;)</b>
<b class="nc"><i>1910</i>&nbsp;				((TreeView&lt;?&gt;)child).refresh();</b>
<b class="nc"><i>1911</i>&nbsp;			else if (child instanceof ListView&lt;?&gt;)</b>
<b class="nc"><i>1912</i>&nbsp;				((ListView&lt;?&gt;)child).refresh();</b>
<b class="nc"><i>1913</i>&nbsp;			else if (child instanceof TableView&lt;?&gt;)</b>
<b class="nc"><i>1914</i>&nbsp;				((TableView&lt;?&gt;)child).refresh();</b>
<b class="nc"><i>1915</i>&nbsp;			else if (child instanceof TreeTableView&lt;?&gt;)</b>
<b class="nc"><i>1916</i>&nbsp;				((TreeTableView&lt;?&gt;)child).refresh();</b>
<b class="nc"><i>1917</i>&nbsp;			else if (child instanceof Parent)</b>
<b class="nc"><i>1918</i>&nbsp;				updateListsAndTables((Parent)child);</b>
<b class="nc"><i>1919</i>&nbsp;		}</b>
<b class="nc"><i>1920</i>&nbsp;	}</b>
<i>1921</i>&nbsp;	
<i>1922</i>&nbsp;	
<i>1923</i>&nbsp;	/**
<i>1924</i>&nbsp;	 * Save available PathClasses to preferences.
<i>1925</i>&nbsp;	 */
<i>1926</i>&nbsp;	private void savePathClasses() {
<b class="fc"><i>1927</i>&nbsp;		ByteArrayOutputStream stream = new ByteArrayOutputStream();</b>
<b class="fc"><i>1928</i>&nbsp;		try (ObjectOutputStream out = new ObjectOutputStream(stream)) {</b>
<b class="fc"><i>1929</i>&nbsp;			List&lt;PathClass&gt; pathClasses = new ArrayList&lt;&gt;(availablePathClasses);</b>
<b class="fc"><i>1930</i>&nbsp;			out.writeObject(pathClasses);</b>
<b class="fc"><i>1931</i>&nbsp;			out.flush();</b>
<b class="fc"><i>1932</i>&nbsp;		} catch (IOException e) {</b>
<b class="nc"><i>1933</i>&nbsp;			logger.error(&quot;Error saving classes&quot;, e);</b>
<b class="fc"><i>1934</i>&nbsp;		}</b>
<b class="fc"><i>1935</i>&nbsp;		byte[] bytes = stream.toByteArray();</b>
<b class="fc"><i>1936</i>&nbsp;		PathPrefs.getUserPreferences().putByteArray(&quot;defaultPathClasses&quot;, bytes);</b>
<b class="fc"><i>1937</i>&nbsp;	}</b>
<i>1938</i>&nbsp;	
<i>1939</i>&nbsp;	
<i>1940</i>&nbsp;	
<i>1941</i>&nbsp;	private BorderPane initializeMainComponent() {
<i>1942</i>&nbsp;		
<b class="fc"><i>1943</i>&nbsp;		pane = new BorderPane();</b>
<i>1944</i>&nbsp;		
<i>1945</i>&nbsp;		// Create a reasonably-sized viewer
<b class="fc"><i>1946</i>&nbsp;		QuPathViewerPlus viewer = new QuPathViewerPlus(null, imageRegionStore, overlayOptions, viewerDisplayOptions);</b>
<i>1947</i>&nbsp;		
<i>1948</i>&nbsp;		
<i>1949</i>&nbsp;
<i>1950</i>&nbsp;		// Add analysis panel &amp; viewer to split pane
<b class="fc"><i>1951</i>&nbsp;		viewerManager = new MultiviewManager(viewer);</b>
<i>1952</i>&nbsp;		
<b class="fc"><i>1953</i>&nbsp;		viewerProperty.bind(viewerManager.activeViewerProperty());</b>
<i>1954</i>&nbsp;		
<i>1955</i>&nbsp;		// Now that we have a viewer, we can create an undo/redo manager
<b class="fc"><i>1956</i>&nbsp;		undoRedoManager = new UndoRedoManager(this);</b>
<i>1957</i>&nbsp;
<i>1958</i>&nbsp;		
<i>1959</i>&nbsp;		// TODO: MOVE INITIALIZING MANAGERS ELSEWHERE
<b class="fc"><i>1960</i>&nbsp;		actions.addAll(new Menus(this).getActions());</b>
<i>1961</i>&nbsp;		
<i>1962</i>&nbsp;		// Add a recent projects menu
<b class="fc"><i>1963</i>&nbsp;		getMenu(&quot;File&quot;, true).getItems().add(1, createRecentProjectsMenu());</b>
<i>1964</i>&nbsp;
<i>1965</i>&nbsp;//		analysisPanel = createAnalysisPanel();
<b class="fc"><i>1966</i>&nbsp;		initializeAnalysisPanel();</b>
<b class="fc"><i>1967</i>&nbsp;		analysisPanel.setMinWidth(300);</b>
<b class="fc"><i>1968</i>&nbsp;		analysisPanel.setPrefWidth(400);</b>
<b class="fc"><i>1969</i>&nbsp;		splitPane.setMinWidth(analysisPanel.getMinWidth() + 200);</b>
<b class="fc"><i>1970</i>&nbsp;		splitPane.setPrefWidth(analysisPanel.getPrefWidth() + 200);</b>
<b class="fc"><i>1971</i>&nbsp;		SplitPane.setResizableWithParent(analysisPanel, Boolean.FALSE);		</b>
<i>1972</i>&nbsp;
<i>1973</i>&nbsp;		
<i>1974</i>&nbsp;//		paneCommands.setRight(cbPin);
<i>1975</i>&nbsp;		
<b class="fc"><i>1976</i>&nbsp;		mainViewerPane = CommandFinderTools.createCommandFinderPane(this, viewerManager.getNode(), CommandFinderTools.commandBarDisplayProperty());</b>
<i>1977</i>&nbsp;//		paneViewer.setTop(tfCommands);
<i>1978</i>&nbsp;//		paneViewer.setCenter(viewerManager.getNode());
<b class="fc"><i>1979</i>&nbsp;		splitPane.getItems().addAll(analysisPanel, mainViewerPane);</b>
<i>1980</i>&nbsp;//		splitPane.getItems().addAll(viewerManager.getComponent());
<b class="fc"><i>1981</i>&nbsp;		SplitPane.setResizableWithParent(viewerManager.getNode(), Boolean.TRUE);</b>
<i>1982</i>&nbsp;		
<b class="fc"><i>1983</i>&nbsp;		pane.setCenter(splitPane);</b>
<b class="fc"><i>1984</i>&nbsp;		toolbar = new ToolBarComponent(this);</b>
<b class="fc"><i>1985</i>&nbsp;		pane.setTop(toolbar.getToolBar());</b>
<i>1986</i>&nbsp;		
<b class="fc"><i>1987</i>&nbsp;		setAnalysisPaneVisible(showAnalysisPane.get());</b>
<b class="fc"><i>1988</i>&nbsp;		showAnalysisPane.addListener((v, o, n) -&gt; setAnalysisPaneVisible(n));</b>
<i>1989</i>&nbsp;		
<i>1990</i>&nbsp;//		setInitialLocationAndMagnification(getViewer());
<i>1991</i>&nbsp;
<i>1992</i>&nbsp;		// Prepare the viewer
<b class="fc"><i>1993</i>&nbsp;		setupViewer(viewerManager.getActiveViewer());</b>
<i>1994</i>&nbsp;
<i>1995</i>&nbsp;		// Ensure the mode is set
<i>1996</i>&nbsp;
<i>1997</i>&nbsp;		// Ensure actions are set appropriately
<b class="fc"><i>1998</i>&nbsp;		selectedToolProperty.addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>1999</i>&nbsp;			Action action = toolActions.get(n);</b>
<b class="nc"><i>2000</i>&nbsp;			if (action != null)</b>
<b class="nc"><i>2001</i>&nbsp;				action.setSelected(true);</b>
<i>2002</i>&nbsp;			
<b class="nc"><i>2003</i>&nbsp;			activateTools(getViewer());</b>
<i>2004</i>&nbsp;			
<b class="nc"><i>2005</i>&nbsp;			if (n == PathTools.POINTS)</b>
<b class="nc"><i>2006</i>&nbsp;				defaultActions.COUNTING_PANEL.handle(null);</b>
<i>2007</i>&nbsp;			
<b class="nc"><i>2008</i>&nbsp;			updateCursor();			</b>
<b class="nc"><i>2009</i>&nbsp;		});</b>
<b class="fc"><i>2010</i>&nbsp;		setSelectedTool(getSelectedTool());</b>
<i>2011</i>&nbsp;		
<b class="fc"><i>2012</i>&nbsp;		return pane;</b>
<i>2013</i>&nbsp;	}
<i>2014</i>&nbsp;	
<i>2015</i>&nbsp;	
<i>2016</i>&nbsp;	
<i>2017</i>&nbsp;
<i>2018</i>&nbsp;	
<i>2019</i>&nbsp;	/**
<i>2020</i>&nbsp;	 * Try to load icons, i.e. images of various sizes that could be sensible icons... here sacrificing elegance in an effort to make it work
<i>2021</i>&nbsp;	 * 
<i>2022</i>&nbsp;	 * @return
<i>2023</i>&nbsp;	 */
<i>2024</i>&nbsp;	private List&lt;Image&gt; loadIconList() {
<i>2025</i>&nbsp;		try {
<b class="fc"><i>2026</i>&nbsp;			List&lt;Image&gt; icons = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>2027</i>&nbsp;			for (int i : new int[]{16, 32, 48, 64, 128, 256, 512}) {</b>
<b class="fc"><i>2028</i>&nbsp;				Image icon = loadIcon(i);</b>
<b class="fc"><i>2029</i>&nbsp;				if (icon != null)</b>
<b class="fc"><i>2030</i>&nbsp;					icons.add(icon);</b>
<i>2031</i>&nbsp;			}
<b class="fc"><i>2032</i>&nbsp;			if (!icons.isEmpty())</b>
<b class="fc"><i>2033</i>&nbsp;				return icons;</b>
<b class="nc"><i>2034</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>2035</i>&nbsp;			logger.warn(&quot;Unable to load icons&quot;);</b>
<b class="nc"><i>2036</i>&nbsp;		}</b>
<b class="nc"><i>2037</i>&nbsp;		return null;</b>
<i>2038</i>&nbsp;	}
<i>2039</i>&nbsp;	
<i>2040</i>&nbsp;	private Image loadIcon(int size) {
<b class="fc"><i>2041</i>&nbsp;		String path = &quot;icons/QuPath_&quot; + size + &quot;.png&quot;;</b>
<b class="fc"><i>2042</i>&nbsp;		try (InputStream stream = getExtensionClassLoader().getResourceAsStream(path)) {</b>
<b class="fc"><i>2043</i>&nbsp;			if (stream != null) {</b>
<b class="fc"><i>2044</i>&nbsp;				BufferedImage img = ImageIO.read(stream);</b>
<b class="fc"><i>2045</i>&nbsp;				if (img != null)</b>
<b class="fc"><i>2046</i>&nbsp;					return SwingFXUtils.toFXImage(img, null);</b>
<i>2047</i>&nbsp;			}
<b class="fc"><i>2048</i>&nbsp;		} catch (IOException e) {</b>
<b class="nc"><i>2049</i>&nbsp;			logger.error(&quot;Unable to read icon from &quot; + path);</b>
<b class="nc"><i>2050</i>&nbsp;		}</b>
<b class="nc"><i>2051</i>&nbsp;		return null;</b>
<i>2052</i>&nbsp;	}
<i>2053</i>&nbsp;	
<i>2054</i>&nbsp;	
<i>2055</i>&nbsp;	/**
<i>2056</i>&nbsp;	 * Query whether this is a standalone QuPathGUI instance, as flagged during startup.
<i>2057</i>&nbsp;	 * It can be important to know this so as to avoid calling System.exit(0) or similar, 
<i>2058</i>&nbsp;	 * and bringing down some other application entirely.
<i>2059</i>&nbsp;	 * 
<i>2060</i>&nbsp;	 * @return true if this is a standalone QuPathGUI instance, false otherwise
<i>2061</i>&nbsp;	 */
<i>2062</i>&nbsp;	public boolean isStandalone() {
<b class="fc"><i>2063</i>&nbsp;		return isStandalone;</b>
<i>2064</i>&nbsp;	}
<i>2065</i>&nbsp;	
<i>2066</i>&nbsp;	/**
<i>2067</i>&nbsp;	 * Get an unmodifiable list of all viewers.
<i>2068</i>&nbsp;	 * @return
<i>2069</i>&nbsp;	 */
<i>2070</i>&nbsp;	public List&lt;QuPathViewerPlus&gt; getViewers() {
<b class="fc"><i>2071</i>&nbsp;		if (viewerManager == null)</b>
<b class="nc"><i>2072</i>&nbsp;			return Collections.emptyList();</b>
<b class="fc"><i>2073</i>&nbsp;		return viewerManager.getViewers();</b>
<i>2074</i>&nbsp;	}
<i>2075</i>&nbsp;	
<i>2076</i>&nbsp;	/**
<i>2077</i>&nbsp;	 * Get the currently active viewer.
<i>2078</i>&nbsp;	 * @return
<i>2079</i>&nbsp;	 */
<i>2080</i>&nbsp;	public QuPathViewerPlus getViewer() {
<b class="fc"><i>2081</i>&nbsp;		return viewerManager == null ? null : viewerManager.getActiveViewer();</b>
<i>2082</i>&nbsp;	}
<i>2083</i>&nbsp;	
<i>2084</i>&nbsp;	/**
<i>2085</i>&nbsp;	 * Get the static instance of the current QuPath GUI.
<i>2086</i>&nbsp;	 * @return
<i>2087</i>&nbsp;	 */
<i>2088</i>&nbsp;	public static QuPathGUI getInstance() {
<b class="fc"><i>2089</i>&nbsp;		return instance;</b>
<i>2090</i>&nbsp;	}
<i>2091</i>&nbsp;	
<i>2092</i>&nbsp;	
<i>2093</i>&nbsp;	void activateTools(final QuPathViewerPlus viewer) {
<b class="fc"><i>2094</i>&nbsp;		if (viewer != null)</b>
<b class="fc"><i>2095</i>&nbsp;			viewer.setActiveTool(getSelectedTool());		</b>
<i>2096</i>&nbsp;//		logger.debug(&quot;Tools activated for {}&quot;, viewer);
<b class="fc"><i>2097</i>&nbsp;	}</b>
<i>2098</i>&nbsp;	
<i>2099</i>&nbsp;	
<i>2100</i>&nbsp;	private void deactivateTools(final QuPathViewerPlus viewer) {
<b class="nc"><i>2101</i>&nbsp;		viewer.setActiveTool(null);</b>
<b class="nc"><i>2102</i>&nbsp;	}</b>
<i>2103</i>&nbsp;	
<i>2104</i>&nbsp;	
<i>2105</i>&nbsp;	/**
<i>2106</i>&nbsp;	 * Get the {@link ClassLoader} used to load extensions.
<i>2107</i>&nbsp;	 * @return
<i>2108</i>&nbsp;	 */
<i>2109</i>&nbsp;	public static ClassLoader getExtensionClassLoader() {
<b class="fc"><i>2110</i>&nbsp;		return extensionClassLoader;</b>
<i>2111</i>&nbsp;	}
<i>2112</i>&nbsp;	
<i>2113</i>&nbsp;	
<i>2114</i>&nbsp;	/**
<i>2115</i>&nbsp;	 * Get a reference to the default drag &amp;amp; drop listener, so this may be added to additional windows if needed.
<i>2116</i>&nbsp;	 * 
<i>2117</i>&nbsp;	 * @return
<i>2118</i>&nbsp;	 */
<i>2119</i>&nbsp;	public DragDropFileImportListener getDefaultDragDropListener() {
<b class="fc"><i>2120</i>&nbsp;		return dragAndDrop;</b>
<i>2121</i>&nbsp;	}
<i>2122</i>&nbsp;	
<i>2123</i>&nbsp;	
<i>2124</i>&nbsp;	
<i>2125</i>&nbsp;	void setupViewer(final QuPathViewerPlus viewer) {
<i>2126</i>&nbsp;		
<b class="fc"><i>2127</i>&nbsp;		viewer.getView().setFocusTraversable(true);</b>
<i>2128</i>&nbsp;		
<i>2129</i>&nbsp;		// Update active viewer as required
<b class="fc"><i>2130</i>&nbsp;		viewer.getView().focusedProperty().addListener((e, f, nowFocussed) -&gt; {</b>
<b class="nc"><i>2131</i>&nbsp;			if (nowFocussed) {</b>
<b class="nc"><i>2132</i>&nbsp;				viewerManager.setActiveViewer(viewer);</b>
<i>2133</i>&nbsp;			}
<b class="nc"><i>2134</i>&nbsp;		});</b>
<i>2135</i>&nbsp;		
<b class="fc"><i>2136</i>&nbsp;		viewer.getView().addEventFilter(MouseEvent.MOUSE_PRESSED, e -&gt; viewer.getView().requestFocus());</b>
<i>2137</i>&nbsp;
<b class="fc"><i>2138</i>&nbsp;		viewer.zoomToFitProperty().bind(zoomToFit);</b>
<i>2139</i>&nbsp;		
<i>2140</i>&nbsp;		// Create popup menu
<b class="fc"><i>2141</i>&nbsp;		setViewerPopupMenu(viewer);</b>
<i>2142</i>&nbsp;		
<i>2143</i>&nbsp;		
<b class="fc"><i>2144</i>&nbsp;		viewer.getView().widthProperty().addListener((e, f, g) -&gt; {</b>
<b class="fc"><i>2145</i>&nbsp;			if (viewer.getZoomToFit())</b>
<b class="nc"><i>2146</i>&nbsp;				updateMagnificationString();</b>
<b class="fc"><i>2147</i>&nbsp;		});</b>
<b class="fc"><i>2148</i>&nbsp;		viewer.getView().heightProperty().addListener((e, f, g) -&gt; {</b>
<b class="fc"><i>2149</i>&nbsp;			if (viewer.getZoomToFit())</b>
<b class="nc"><i>2150</i>&nbsp;				updateMagnificationString();</b>
<b class="fc"><i>2151</i>&nbsp;		});</b>
<i>2152</i>&nbsp;		
<i>2153</i>&nbsp;		// Enable drag and drop
<b class="fc"><i>2154</i>&nbsp;		dragAndDrop.setupTarget(viewer.getView());</b>
<i>2155</i>&nbsp;		
<i>2156</i>&nbsp;		
<i>2157</i>&nbsp;		
<i>2158</i>&nbsp;		
<i>2159</i>&nbsp;		// Listen to the scroll wheel
<b class="fc"><i>2160</i>&nbsp;		viewer.getView().setOnScroll(e -&gt; {</b>
<b class="nc"><i>2161</i>&nbsp;			if (viewer == viewerManager.getActiveViewer() || !viewerManager.getSynchronizeViewers()) {</b>
<b class="nc"><i>2162</i>&nbsp;				double scrollUnits = e.getDeltaY() * PathPrefs.getScaledScrollSpeed();</b>
<i>2163</i>&nbsp;				
<i>2164</i>&nbsp;				// Use shift down to adjust opacity
<b class="nc"><i>2165</i>&nbsp;				if (e.isShortcutDown()) {</b>
<b class="nc"><i>2166</i>&nbsp;					OverlayOptions options = viewer.getOverlayOptions();</b>
<b class="nc"><i>2167</i>&nbsp;					options.setOpacity((float)(options.getOpacity() + scrollUnits * 0.001));</b>
<b class="nc"><i>2168</i>&nbsp;					return;</b>
<i>2169</i>&nbsp;				}
<i>2170</i>&nbsp;				
<i>2171</i>&nbsp;				// Avoid zooming at the end of a gesture when using touchscreens
<b class="nc"><i>2172</i>&nbsp;				if (e.isInertia())</b>
<b class="nc"><i>2173</i>&nbsp;					return;</b>
<i>2174</i>&nbsp;				
<b class="nc"><i>2175</i>&nbsp;				if (PathPrefs.invertScrollingProperty().get())</b>
<b class="nc"><i>2176</i>&nbsp;					scrollUnits = -scrollUnits;</b>
<b class="nc"><i>2177</i>&nbsp;				double newDownsampleFactor = viewer.getDownsampleFactor() * Math.pow(viewer.getDefaultZoomFactor(), scrollUnits);</b>
<b class="nc"><i>2178</i>&nbsp;				newDownsampleFactor = Math.min(viewer.getMaxDownsample(), Math.max(newDownsampleFactor, viewer.getMinDownsample()));</b>
<b class="nc"><i>2179</i>&nbsp;				viewer.setDownsampleFactor(newDownsampleFactor, e.getX(), e.getY());</b>
<i>2180</i>&nbsp;			}
<b class="nc"><i>2181</i>&nbsp;		});</b>
<i>2182</i>&nbsp;		
<i>2183</i>&nbsp;		
<b class="fc"><i>2184</i>&nbsp;		viewer.getView().addEventFilter(RotateEvent.ANY, e -&gt; {</b>
<b class="nc"><i>2185</i>&nbsp;			if (!PathPrefs.useRotateGesturesProperty().get())</b>
<b class="nc"><i>2186</i>&nbsp;				return;</b>
<i>2187</i>&nbsp;//			logger.debug(&quot;Rotating: &quot; + e.getAngle());
<b class="nc"><i>2188</i>&nbsp;			viewer.setRotation(viewer.getRotation() + Math.toRadians(e.getAngle()));</b>
<b class="nc"><i>2189</i>&nbsp;			e.consume();</b>
<b class="nc"><i>2190</i>&nbsp;		});</b>
<i>2191</i>&nbsp;
<b class="fc"><i>2192</i>&nbsp;		viewer.getView().addEventFilter(ZoomEvent.ANY, e -&gt; {</b>
<b class="nc"><i>2193</i>&nbsp;			if (!PathPrefs.useZoomGesturesProperty().get())</b>
<b class="nc"><i>2194</i>&nbsp;				return;</b>
<b class="nc"><i>2195</i>&nbsp;			double zoomFactor = e.getZoomFactor();</b>
<b class="nc"><i>2196</i>&nbsp;			if (Double.isNaN(zoomFactor))</b>
<b class="nc"><i>2197</i>&nbsp;				return;</b>
<i>2198</i>&nbsp;			
<b class="nc"><i>2199</i>&nbsp;			logger.debug(&quot;Zooming: &quot; + e.getZoomFactor() + &quot; (&quot; + e.getTotalZoomFactor() + &quot;)&quot;);</b>
<b class="nc"><i>2200</i>&nbsp;			viewer.setDownsampleFactor(viewer.getDownsampleFactor() / zoomFactor, e.getX(), e.getY());</b>
<b class="nc"><i>2201</i>&nbsp;			e.consume();</b>
<b class="nc"><i>2202</i>&nbsp;		});</b>
<i>2203</i>&nbsp;		
<b class="fc"><i>2204</i>&nbsp;		viewer.getView().addEventFilter(ScrollEvent.ANY, new ScrollEventPanningFilter(viewer));</b>
<i>2205</i>&nbsp;		
<i>2206</i>&nbsp;		
<b class="fc"><i>2207</i>&nbsp;		viewer.getView().addEventHandler(KeyEvent.KEY_PRESSED, e -&gt; {</b>
<b class="nc"><i>2208</i>&nbsp;			PathObject pathObject = viewer.getSelectedObject();</b>
<b class="nc"><i>2209</i>&nbsp;			if (!e.isConsumed() &amp;&amp; pathObject != null) {</b>
<b class="nc"><i>2210</i>&nbsp;				if (pathObject.isTMACore()) {</b>
<b class="nc"><i>2211</i>&nbsp;					TMACoreObject core = (TMACoreObject)pathObject;</b>
<b class="nc"><i>2212</i>&nbsp;					if (e.getCode() == KeyCode.ENTER) {</b>
<b class="nc"><i>2213</i>&nbsp;						defaultActions.TMA_ADD_NOTE.handle(new ActionEvent(e.getSource(), e.getTarget()));</b>
<b class="nc"><i>2214</i>&nbsp;						e.consume();</b>
<b class="nc"><i>2215</i>&nbsp;					} else if (e.getCode() == KeyCode.BACK_SPACE) {</b>
<b class="nc"><i>2216</i>&nbsp;						core.setMissing(!core.isMissing());</b>
<b class="nc"><i>2217</i>&nbsp;						viewer.getHierarchy().fireObjectsChangedEvent(this, Collections.singleton(core));</b>
<b class="nc"><i>2218</i>&nbsp;						e.consume();</b>
<i>2219</i>&nbsp;					}
<b class="nc"><i>2220</i>&nbsp;				} else if (pathObject.isAnnotation()) {</b>
<b class="nc"><i>2221</i>&nbsp;					if (e.getCode() == KeyCode.ENTER) {</b>
<b class="nc"><i>2222</i>&nbsp;						GuiTools.promptToSetActiveAnnotationProperties(viewer.getHierarchy());</b>
<b class="nc"><i>2223</i>&nbsp;						e.consume();</b>
<i>2224</i>&nbsp;					}
<i>2225</i>&nbsp;				}
<i>2226</i>&nbsp;			}
<b class="nc"><i>2227</i>&nbsp;		});</b>
<i>2228</i>&nbsp;		
<i>2229</i>&nbsp;
<b class="fc"><i>2230</i>&nbsp;	}</b>
<i>2231</i>&nbsp;	
<i>2232</i>&nbsp;	
<i>2233</i>&nbsp;	
<i>2234</i>&nbsp;	
<i>2235</i>&nbsp;	static class ScrollEventPanningFilter implements EventHandler&lt;ScrollEvent&gt; {
<i>2236</i>&nbsp;		
<i>2237</i>&nbsp;		private QuPathViewer viewer;
<b class="fc"><i>2238</i>&nbsp;		private boolean lastTouchEvent = false;</b>
<b class="fc"><i>2239</i>&nbsp;		private double deltaX = 0;</b>
<b class="fc"><i>2240</i>&nbsp;		private double deltaY = 0;</b>
<b class="fc"><i>2241</i>&nbsp;		private long lastTimestamp = 0L;</b>
<i>2242</i>&nbsp;		
<b class="fc"><i>2243</i>&nbsp;		ScrollEventPanningFilter(final QuPathViewer viewer) {</b>
<b class="fc"><i>2244</i>&nbsp;			this.viewer = viewer;</b>
<b class="fc"><i>2245</i>&nbsp;		}</b>
<i>2246</i>&nbsp;
<i>2247</i>&nbsp;		@Override
<i>2248</i>&nbsp;		public void handle(ScrollEvent e) {
<i>2249</i>&nbsp;			// Check if we&#39;d rather be using scroll to do something else (e.g. zoom, adjust opacity)
<b class="nc"><i>2250</i>&nbsp;			boolean wouldRatherDoSomethingElse = e.getTouchCount() == 0 &amp;&amp; (!PathPrefs.useScrollGesturesProperty().get() || e.isShiftDown() || e.isShortcutDown());</b>
<b class="nc"><i>2251</i>&nbsp;			if (wouldRatherDoSomethingElse) {</b>
<b class="nc"><i>2252</i>&nbsp;				return;</b>
<i>2253</i>&nbsp;			}
<i>2254</i>&nbsp;			
<i>2255</i>&nbsp;			// Don&#39;t pan with inertia events (use the &#39;mover&#39; instead)
<b class="nc"><i>2256</i>&nbsp;			if (e.isInertia()) {</b>
<b class="nc"><i>2257</i>&nbsp;				e.consume();</b>
<b class="nc"><i>2258</i>&nbsp;				return;</b>
<i>2259</i>&nbsp;			}
<i>2260</i>&nbsp;			
<i>2261</i>&nbsp;			// Return if we aren&#39;t using a touchscreen, and we don&#39;t want to handle scroll gestures - 
<i>2262</i>&nbsp;			// but don&#39;t consume the event so that it can be handled elsewhere
<b class="nc"><i>2263</i>&nbsp;			lastTouchEvent = e.getTouchCount() != 0;</b>
<b class="nc"><i>2264</i>&nbsp;			if (!lastTouchEvent &amp;&amp; !PathPrefs.useScrollGesturesProperty().get() || e.isShiftDown() || e.isShortcutDown()) {</b>
<b class="nc"><i>2265</i>&nbsp;				return;</b>
<i>2266</i>&nbsp;			}
<i>2267</i>&nbsp;			// Swallow the event if we&#39;re using a touch screen without the move tool selected - we want to draw instead
<b class="nc"><i>2268</i>&nbsp;			if (lastTouchEvent &amp;&amp; viewer.getActiveTool() != PathTools.MOVE) {</b>
<b class="nc"><i>2269</i>&nbsp;				e.consume();</b>
<b class="nc"><i>2270</i>&nbsp;				return;</b>
<i>2271</i>&nbsp;			}
<i>2272</i>&nbsp;			
<i>2273</i>&nbsp;//			// If this is a SCROLL_FINISHED event, continue moving with the last starting velocity - but ignore inertia
<b class="nc"><i>2274</i>&nbsp;			if (!lastTouchEvent &amp;&amp; e.getEventType() == ScrollEvent.SCROLL_FINISHED) {</b>
<b class="nc"><i>2275</i>&nbsp;				if (System.currentTimeMillis() - lastTimestamp &lt; 100L) {</b>
<b class="nc"><i>2276</i>&nbsp;					viewer.requestStartMoving(deltaX, deltaY);</b>
<b class="nc"><i>2277</i>&nbsp;					viewer.requestDecelerate();					</b>
<i>2278</i>&nbsp;				}
<b class="nc"><i>2279</i>&nbsp;				deltaX = 0;</b>
<b class="nc"><i>2280</i>&nbsp;				deltaY = 0;</b>
<b class="nc"><i>2281</i>&nbsp;				e.consume();</b>
<b class="nc"><i>2282</i>&nbsp;				return;</b>
<i>2283</i>&nbsp;			}
<i>2284</i>&nbsp;//			viewer.requestStopMoving();
<i>2285</i>&nbsp;			
<i>2286</i>&nbsp;			// Use downsample since shift will be defined in full-resolution pixel coordinates
<b class="nc"><i>2287</i>&nbsp;			double dx = e.getDeltaX() * viewer.getDownsampleFactor();</b>
<b class="nc"><i>2288</i>&nbsp;			double dy = e.getDeltaY() * viewer.getDownsampleFactor();</b>
<i>2289</i>&nbsp;			
<i>2290</i>&nbsp;			// When e.isInertia() == TRUE on OSX, the results are quite annoyingly &#39;choppy&#39; - x,y values are often passed separately
<i>2291</i>&nbsp;//			System.err.println(String.format(&quot;dx=%.1f, dy=%.1f %s&quot;, e.getDeltaX(), e.getDeltaY(), (e.isInertia() ? &quot;-Inertia&quot; : &quot;&quot;)));
<i>2292</i>&nbsp;			
<i>2293</i>&nbsp;			// Flip scrolling direction if necessary
<b class="nc"><i>2294</i>&nbsp;			if (PathPrefs.invertScrollingProperty().get()) {</b>
<b class="nc"><i>2295</i>&nbsp;				dx = -dx;</b>
<b class="nc"><i>2296</i>&nbsp;				dy = -dy;</b>
<i>2297</i>&nbsp;			}
<i>2298</i>&nbsp;			
<i>2299</i>&nbsp;			// Handle rotation
<b class="nc"><i>2300</i>&nbsp;			if (viewer.isRotated()) {</b>
<b class="nc"><i>2301</i>&nbsp;				double cosTheta = Math.cos(-viewer.getRotation());</b>
<b class="nc"><i>2302</i>&nbsp;				double sinTheta = Math.sin(-viewer.getRotation());</b>
<b class="nc"><i>2303</i>&nbsp;				double dx2 = cosTheta*dx - sinTheta*dy;</b>
<b class="nc"><i>2304</i>&nbsp;				double dy2 = sinTheta*dx + cosTheta*dy;</b>
<b class="nc"><i>2305</i>&nbsp;				dx = dx2;</b>
<b class="nc"><i>2306</i>&nbsp;				dy = dy2;</b>
<i>2307</i>&nbsp;			}
<i>2308</i>&nbsp;
<i>2309</i>&nbsp;			// Shift the viewer
<b class="nc"><i>2310</i>&nbsp;			viewer.setCenterPixelLocation(</b>
<b class="nc"><i>2311</i>&nbsp;					viewer.getCenterPixelX() - dx,</b>
<b class="nc"><i>2312</i>&nbsp;					viewer.getCenterPixelY() - dy);</b>
<i>2313</i>&nbsp;			
<i>2314</i>&nbsp;			// Retain deltas in case we need to decelerate later
<b class="nc"><i>2315</i>&nbsp;			deltaX = dx;</b>
<b class="nc"><i>2316</i>&nbsp;			deltaY = dy;</b>
<b class="nc"><i>2317</i>&nbsp;			lastTimestamp = System.currentTimeMillis();</b>
<i>2318</i>&nbsp;			
<b class="nc"><i>2319</i>&nbsp;			e.consume();</b>
<b class="nc"><i>2320</i>&nbsp;		}</b>
<i>2321</i>&nbsp;		
<i>2322</i>&nbsp;	}
<i>2323</i>&nbsp;	
<i>2324</i>&nbsp;	
<i>2325</i>&nbsp;	
<i>2326</i>&nbsp;	
<i>2327</i>&nbsp;	
<i>2328</i>&nbsp;	
<i>2329</i>&nbsp;	private void setViewerPopupMenu(final QuPathViewerPlus viewer) {
<i>2330</i>&nbsp;		
<b class="fc"><i>2331</i>&nbsp;		final ContextMenu popup = new ContextMenu();</b>
<i>2332</i>&nbsp;		
<b class="fc"><i>2333</i>&nbsp;		MenuItem miAddRow = new MenuItem(&quot;Add row&quot;);</b>
<b class="fc"><i>2334</i>&nbsp;		miAddRow.setOnAction(e -&gt; viewerManager.addRow(viewer));</b>
<b class="fc"><i>2335</i>&nbsp;		MenuItem miAddColumn = new MenuItem(&quot;Add column&quot;);</b>
<b class="fc"><i>2336</i>&nbsp;		miAddColumn.setOnAction(e -&gt; viewerManager.addColumn(viewer));</b>
<i>2337</i>&nbsp;		
<b class="fc"><i>2338</i>&nbsp;		MenuItem miRemoveRow = new MenuItem(&quot;Remove row&quot;);</b>
<b class="fc"><i>2339</i>&nbsp;		miRemoveRow.setOnAction(e -&gt; viewerManager.removeViewerRow(viewer));</b>
<b class="fc"><i>2340</i>&nbsp;		MenuItem miRemoveColumn = new MenuItem(&quot;Remove column&quot;);</b>
<b class="fc"><i>2341</i>&nbsp;		miRemoveColumn.setOnAction(e -&gt; viewerManager.removeViewerColumn(viewer));</b>
<i>2342</i>&nbsp;
<b class="fc"><i>2343</i>&nbsp;		MenuItem miCloseViewer = new MenuItem(&quot;Close viewer&quot;);</b>
<b class="fc"><i>2344</i>&nbsp;		miCloseViewer.setOnAction(e -&gt; {</b>
<b class="nc"><i>2345</i>&nbsp;			viewerManager.closeViewer(viewer);</b>
<i>2346</i>&nbsp;//				viewerManager.removeViewer(viewer);
<b class="nc"><i>2347</i>&nbsp;		});</b>
<b class="fc"><i>2348</i>&nbsp;		MenuItem miResizeGrid = new MenuItem(&quot;Reset grid size&quot;);</b>
<b class="fc"><i>2349</i>&nbsp;		miResizeGrid.setOnAction(e -&gt; {</b>
<b class="nc"><i>2350</i>&nbsp;				viewerManager.resetGridSize();</b>
<b class="nc"><i>2351</i>&nbsp;		});</b>
<b class="fc"><i>2352</i>&nbsp;		MenuItem miToggleSync = ActionTools.createCheckMenuItem(defaultActions.TOGGLE_SYNCHRONIZE_VIEWERS, null);</b>
<b class="fc"><i>2353</i>&nbsp;		MenuItem miMatchResolutions = ActionTools.createMenuItem(defaultActions.MATCH_VIEWER_RESOLUTIONS);</b>
<b class="fc"><i>2354</i>&nbsp;		Menu menuMultiview = MenuTools.createMenu(</b>
<i>2355</i>&nbsp;				&quot;Multi-view&quot;,
<i>2356</i>&nbsp;				miToggleSync,
<i>2357</i>&nbsp;				miMatchResolutions,
<i>2358</i>&nbsp;				miCloseViewer,
<i>2359</i>&nbsp;				null,
<i>2360</i>&nbsp;				miResizeGrid,
<i>2361</i>&nbsp;				null,
<i>2362</i>&nbsp;//				miSplitQuadrants,
<i>2363</i>&nbsp;//				null,
<i>2364</i>&nbsp;				miAddRow,
<i>2365</i>&nbsp;				miAddColumn,
<i>2366</i>&nbsp;				null,
<i>2367</i>&nbsp;				miRemoveRow,
<i>2368</i>&nbsp;				miRemoveColumn
<i>2369</i>&nbsp;				);
<i>2370</i>&nbsp;		
<b class="fc"><i>2371</i>&nbsp;		Menu menuView = MenuTools.createMenu(</b>
<i>2372</i>&nbsp;				&quot;Display&quot;,
<b class="fc"><i>2373</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.SHOW_ANALYSIS_PANE, null),</b>
<i>2374</i>&nbsp;				defaultActions.BRIGHTNESS_CONTRAST,
<i>2375</i>&nbsp;				null,
<b class="fc"><i>2376</i>&nbsp;				ActionTools.createAction(() -&gt; Commands.setViewerDownsample(viewer, 0.25), &quot;400%&quot;),</b>
<b class="fc"><i>2377</i>&nbsp;				ActionTools.createAction(() -&gt; Commands.setViewerDownsample(viewer, 1), &quot;100%&quot;),</b>
<b class="fc"><i>2378</i>&nbsp;				ActionTools.createAction(() -&gt; Commands.setViewerDownsample(viewer, 2), &quot;50%&quot;),</b>
<b class="fc"><i>2379</i>&nbsp;				ActionTools.createAction(() -&gt; Commands.setViewerDownsample(viewer, 10), &quot;10%&quot;),</b>
<b class="fc"><i>2380</i>&nbsp;				ActionTools.createAction(() -&gt; Commands.setViewerDownsample(viewer, 100), &quot;1%&quot;)</b>
<i>2381</i>&nbsp;				);
<i>2382</i>&nbsp;		
<b class="fc"><i>2383</i>&nbsp;		ToggleGroup groupTools = new ToggleGroup();</b>
<b class="fc"><i>2384</i>&nbsp;		Menu menuTools = MenuTools.createMenu(</b>
<i>2385</i>&nbsp;				&quot;Set tool&quot;,
<b class="fc"><i>2386</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.MOVE_TOOL, groupTools),</b>
<b class="fc"><i>2387</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.RECTANGLE_TOOL, groupTools),</b>
<b class="fc"><i>2388</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.ELLIPSE_TOOL, groupTools),</b>
<b class="fc"><i>2389</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.LINE_TOOL, groupTools),</b>
<b class="fc"><i>2390</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.POLYGON_TOOL, groupTools),</b>
<b class="fc"><i>2391</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.POLYLINE_TOOL, groupTools),</b>
<b class="fc"><i>2392</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.BRUSH_TOOL, groupTools),</b>
<b class="fc"><i>2393</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.POINTS_TOOL, groupTools)</b>
<i>2394</i>&nbsp;//				ActionTools.getActionCheckBoxMenuItem(actionManager.WAND_TOOL, groupTools)
<i>2395</i>&nbsp;				);
<i>2396</i>&nbsp;
<i>2397</i>&nbsp;		
<i>2398</i>&nbsp;		// Handle awkward &#39;TMA core missing&#39; option
<b class="fc"><i>2399</i>&nbsp;		CheckMenuItem miTMAValid = new CheckMenuItem(&quot;Set core valid&quot;);</b>
<b class="fc"><i>2400</i>&nbsp;		miTMAValid.setOnAction(e -&gt; setTMACoreMissing(viewer.getHierarchy(), false));</b>
<b class="fc"><i>2401</i>&nbsp;		CheckMenuItem miTMAMissing = new CheckMenuItem(&quot;Set core missing&quot;);</b>
<b class="fc"><i>2402</i>&nbsp;		miTMAMissing.setOnAction(e -&gt; setTMACoreMissing(viewer.getHierarchy(), true));</b>
<i>2403</i>&nbsp;		
<b class="fc"><i>2404</i>&nbsp;		Menu menuTMA = new Menu(&quot;TMA&quot;);</b>
<b class="fc"><i>2405</i>&nbsp;		MenuTools.addMenuItems(</b>
<i>2406</i>&nbsp;				menuTMA,
<i>2407</i>&nbsp;				miTMAValid,
<i>2408</i>&nbsp;				miTMAMissing,
<i>2409</i>&nbsp;				null,
<i>2410</i>&nbsp;				defaultActions.TMA_ADD_NOTE,
<i>2411</i>&nbsp;				null,
<b class="fc"><i>2412</i>&nbsp;				MenuTools.createMenu(</b>
<i>2413</i>&nbsp;						&quot;Add&quot;,
<b class="fc"><i>2414</i>&nbsp;					createImageDataAction(imageData -&gt; TMACommands.promptToAddRowBeforeSelected(imageData), &quot;Add TMA row before&quot;),</b>
<b class="fc"><i>2415</i>&nbsp;					createImageDataAction(imageData -&gt; TMACommands.promptToAddRowAfterSelected(imageData), &quot;Add TMA row after&quot;),</b>
<b class="fc"><i>2416</i>&nbsp;					createImageDataAction(imageData -&gt; TMACommands.promptToAddColumnBeforeSelected(imageData), &quot;Add TMA column before&quot;),</b>
<b class="fc"><i>2417</i>&nbsp;					createImageDataAction(imageData -&gt; TMACommands.promptToAddColumnAfterSelected(imageData), &quot;Add TMA column after&quot;)</b>
<i>2418</i>&nbsp;					),
<b class="fc"><i>2419</i>&nbsp;				MenuTools.createMenu(</b>
<i>2420</i>&nbsp;						&quot;Remove&quot;,
<b class="fc"><i>2421</i>&nbsp;					createImageDataAction(imageData -&gt; TMACommands.promptToDeleteTMAGridRow(imageData), &quot;Remove TMA row&quot;),</b>
<b class="fc"><i>2422</i>&nbsp;					createImageDataAction(imageData -&gt; TMACommands.promptToDeleteTMAGridColumn(imageData), &quot;column&quot;)</b>
<i>2423</i>&nbsp;					)
<i>2424</i>&nbsp;				);
<i>2425</i>&nbsp;		
<i>2426</i>&nbsp;		
<i>2427</i>&nbsp;		// Create an empty placeholder menu
<b class="fc"><i>2428</i>&nbsp;		Menu menuSetClass = MenuTools.createMenu(&quot;Set class&quot;);</b>
<i>2429</i>&nbsp;		
<i>2430</i>&nbsp;		
<i>2431</i>&nbsp;//		CheckMenuItem miTMAValid = new CheckMenuItem(&quot;Set core valid&quot;);
<i>2432</i>&nbsp;//		miTMAValid.setOnAction(e -&gt; setTMACoreMissing(viewer.getHierarchy(), false));
<i>2433</i>&nbsp;//		CheckMenuItem miTMAMissing = new CheckMenuItem(&quot;Set core missing&quot;);
<i>2434</i>&nbsp;//		miTMAMissing.setOnAction(e -&gt; setTMACoreMissing(viewer.getHierarchy(), true));
<i>2435</i>&nbsp;		
<i>2436</i>&nbsp;		
<b class="fc"><i>2437</i>&nbsp;		Menu menuCells = MenuTools.createMenu(</b>
<i>2438</i>&nbsp;				&quot;Cells&quot;,
<b class="fc"><i>2439</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.SHOW_CELL_BOUNDARIES_AND_NUCLEI, null),</b>
<b class="fc"><i>2440</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.SHOW_CELL_NUCLEI, null),</b>
<b class="fc"><i>2441</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.SHOW_CELL_BOUNDARIES, null),</b>
<b class="fc"><i>2442</i>&nbsp;				ActionTools.createCheckMenuItem(defaultActions.SHOW_CELL_CENTROIDS, null)</b>
<i>2443</i>&nbsp;				);
<i>2444</i>&nbsp;
<i>2445</i>&nbsp;		
<i>2446</i>&nbsp;		
<b class="fc"><i>2447</i>&nbsp;		MenuItem miClearSelectedObjects = new MenuItem(&quot;Delete object&quot;);</b>
<b class="fc"><i>2448</i>&nbsp;		miClearSelectedObjects.setOnAction(e -&gt; {</b>
<b class="nc"><i>2449</i>&nbsp;			PathObjectHierarchy hierarchy = viewer.getHierarchy();</b>
<b class="nc"><i>2450</i>&nbsp;			if (hierarchy == null)</b>
<b class="nc"><i>2451</i>&nbsp;				return;</b>
<b class="nc"><i>2452</i>&nbsp;			if (hierarchy.getSelectionModel().singleSelection()) {</b>
<b class="nc"><i>2453</i>&nbsp;				GuiTools.promptToRemoveSelectedObject(hierarchy.getSelectionModel().getSelectedObject(), hierarchy);</b>
<i>2454</i>&nbsp;			} else {
<b class="nc"><i>2455</i>&nbsp;				GuiTools.promptToClearAllSelectedObjects(viewer.getImageData());</b>
<i>2456</i>&nbsp;			}
<b class="nc"><i>2457</i>&nbsp;		});</b>
<i>2458</i>&nbsp;		
<i>2459</i>&nbsp;		// Create a standard annotations menu
<b class="fc"><i>2460</i>&nbsp;		Menu menuAnnotations = GuiTools.populateAnnotationsMenu(this, new Menu(&quot;Annotations&quot;));</b>
<i>2461</i>&nbsp;		
<b class="fc"><i>2462</i>&nbsp;		SeparatorMenuItem topSeparator = new SeparatorMenuItem();</b>
<b class="fc"><i>2463</i>&nbsp;		popup.setOnShowing(e -&gt; {</b>
<i>2464</i>&nbsp;			// Check if we have any cells
<b class="nc"><i>2465</i>&nbsp;			ImageData&lt;?&gt; imageData = viewer.getImageData();</b>
<b class="nc"><i>2466</i>&nbsp;			if (imageData == null)</b>
<b class="nc"><i>2467</i>&nbsp;				menuCells.setVisible(false);</b>
<i>2468</i>&nbsp;			else
<b class="nc"><i>2469</i>&nbsp;				menuCells.setVisible(!imageData.getHierarchy().getDetectionObjects().isEmpty());</b>
<i>2470</i>&nbsp;			
<i>2471</i>&nbsp;			
<i>2472</i>&nbsp;			// Check what to show for TMA cores or annotations
<b class="nc"><i>2473</i>&nbsp;			Collection&lt;PathObject&gt; selectedObjects = viewer.getAllSelectedObjects();</b>
<b class="nc"><i>2474</i>&nbsp;			PathObject pathObject = viewer.getSelectedObject();</b>
<b class="nc"><i>2475</i>&nbsp;			menuTMA.setVisible(false);</b>
<b class="nc"><i>2476</i>&nbsp;			if (pathObject instanceof TMACoreObject) {</b>
<b class="nc"><i>2477</i>&nbsp;				boolean isMissing = ((TMACoreObject)pathObject).isMissing();</b>
<b class="nc"><i>2478</i>&nbsp;				miTMAValid.setSelected(!isMissing);</b>
<b class="nc"><i>2479</i>&nbsp;				miTMAMissing.setSelected(isMissing);</b>
<b class="nc"><i>2480</i>&nbsp;				menuTMA.setVisible(true);</b>
<i>2481</i>&nbsp;			}
<i>2482</i>&nbsp;			
<i>2483</i>&nbsp;			// Add clear objects option if we have more than one non-TMA object
<b class="nc"><i>2484</i>&nbsp;			if (imageData == null || imageData.getHierarchy().getSelectionModel().noSelection() || imageData.getHierarchy().getSelectionModel().getSelectedObject() instanceof TMACoreObject)</b>
<b class="nc"><i>2485</i>&nbsp;				miClearSelectedObjects.setVisible(false);</b>
<i>2486</i>&nbsp;			else {
<b class="nc"><i>2487</i>&nbsp;				if (imageData.getHierarchy().getSelectionModel().singleSelection()) {</b>
<b class="nc"><i>2488</i>&nbsp;					miClearSelectedObjects.setText(&quot;Delete object&quot;);</b>
<b class="nc"><i>2489</i>&nbsp;					miClearSelectedObjects.setVisible(true);</b>
<i>2490</i>&nbsp;				} else {
<b class="nc"><i>2491</i>&nbsp;					miClearSelectedObjects.setText(&quot;Delete objects&quot;);</b>
<b class="nc"><i>2492</i>&nbsp;					miClearSelectedObjects.setVisible(true);					</b>
<i>2493</i>&nbsp;				}
<i>2494</i>&nbsp;			}
<i>2495</i>&nbsp;			
<b class="nc"><i>2496</i>&nbsp;			boolean hasAnnotations = pathObject instanceof PathAnnotationObject || (!selectedObjects.isEmpty() &amp;&amp; selectedObjects.stream().allMatch(p -&gt; p.isAnnotation()));</b>
<i>2497</i>&nbsp;			
<b class="nc"><i>2498</i>&nbsp;			updateSetAnnotationPathClassMenu(menuSetClass, viewer);</b>
<b class="nc"><i>2499</i>&nbsp;			menuAnnotations.setVisible(hasAnnotations);</b>
<b class="nc"><i>2500</i>&nbsp;			topSeparator.setVisible(hasAnnotations || pathObject instanceof TMACoreObject);</b>
<i>2501</i>&nbsp;			// Occasionally, the newly-visible top part of a popup menu can have the wrong size?
<b class="nc"><i>2502</i>&nbsp;			popup.setWidth(popup.getPrefWidth());</b>
<b class="nc"><i>2503</i>&nbsp;		});</b>
<i>2504</i>&nbsp;		
<i>2505</i>&nbsp;		
<i>2506</i>&nbsp;//		popup.add(menuClassify);
<b class="fc"><i>2507</i>&nbsp;		popup.getItems().addAll(</b>
<i>2508</i>&nbsp;				miClearSelectedObjects,
<i>2509</i>&nbsp;				menuTMA,
<i>2510</i>&nbsp;				menuSetClass,
<i>2511</i>&nbsp;				menuAnnotations,
<i>2512</i>&nbsp;				topSeparator,
<i>2513</i>&nbsp;				menuMultiview,
<i>2514</i>&nbsp;				menuCells,
<i>2515</i>&nbsp;				menuView,
<i>2516</i>&nbsp;				menuTools
<i>2517</i>&nbsp;				);
<i>2518</i>&nbsp;		
<b class="fc"><i>2519</i>&nbsp;		popup.setAutoHide(true);</b>
<i>2520</i>&nbsp;		
<i>2521</i>&nbsp;		// Enable circle pop-up for quick classification on right-click
<b class="fc"><i>2522</i>&nbsp;		CirclePopupMenu circlePopup = new CirclePopupMenu(viewer.getView(), null);</b>
<b class="fc"><i>2523</i>&nbsp;		viewer.getView().addEventHandler(MouseEvent.MOUSE_PRESSED, e -&gt; {</b>
<b class="nc"><i>2524</i>&nbsp;			if ((e.isPopupTrigger() || e.isSecondaryButtonDown()) &amp;&amp; e.isShiftDown() &amp;&amp; !getAvailablePathClasses().isEmpty()) {</b>
<b class="nc"><i>2525</i>&nbsp;				circlePopup.setAnimationDuration(Duration.millis(200));</b>
<b class="nc"><i>2526</i>&nbsp;				updateSetAnnotationPathClassMenu(circlePopup, viewer);</b>
<b class="nc"><i>2527</i>&nbsp;				circlePopup.show(e.getScreenX(), e.getScreenY());</b>
<b class="nc"><i>2528</i>&nbsp;				e.consume();</b>
<b class="nc"><i>2529</i>&nbsp;				return;</b>
<b class="nc"><i>2530</i>&nbsp;			} else if (circlePopup.isShown())</b>
<b class="nc"><i>2531</i>&nbsp;				circlePopup.hide();</b>
<i>2532</i>&nbsp;				
<b class="nc"><i>2533</i>&nbsp;			if (e.isPopupTrigger() || e.isSecondaryButtonDown()) {</b>
<b class="nc"><i>2534</i>&nbsp;				popup.show(viewer.getView().getScene().getWindow(), e.getScreenX(), e.getScreenY());				</b>
<b class="nc"><i>2535</i>&nbsp;				e.consume();</b>
<i>2536</i>&nbsp;			}
<b class="nc"><i>2537</i>&nbsp;		});</b>
<i>2538</i>&nbsp;		
<i>2539</i>&nbsp;//		// It&#39;s necessary to make the Window the owner, since otherwise the context menu does not disappear when clicking elsewhere on the viewer
<i>2540</i>&nbsp;//		viewer.getView().setOnContextMenuRequested(e -&gt; {
<i>2541</i>&nbsp;//			popup.show(viewer.getView().getScene().getWindow(), e.getScreenX(), e.getScreenY());
<i>2542</i>&nbsp;////			popup.show(viewer.getView(), e.getScreenX(), e.getScreenY());
<i>2543</i>&nbsp;//		});
<i>2544</i>&nbsp;			
<b class="fc"><i>2545</i>&nbsp;	}</b>
<i>2546</i>&nbsp;
<i>2547</i>&nbsp;	/**
<i>2548</i>&nbsp;	 * Set selected TMA cores to have the specified &#39;missing&#39; status.
<i>2549</i>&nbsp;	 * 
<i>2550</i>&nbsp;	 * @param hierarchy
<i>2551</i>&nbsp;	 * @param setToMissing
<i>2552</i>&nbsp;	 */
<i>2553</i>&nbsp;	private static void setTMACoreMissing(final PathObjectHierarchy hierarchy, final boolean setToMissing) {
<b class="nc"><i>2554</i>&nbsp;		if (hierarchy == null)</b>
<b class="nc"><i>2555</i>&nbsp;			return;</b>
<b class="nc"><i>2556</i>&nbsp;		PathObject pathObject = hierarchy.getSelectionModel().getSelectedObject();</b>
<b class="nc"><i>2557</i>&nbsp;		List&lt;PathObject&gt; changed = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>2558</i>&nbsp;		if (pathObject instanceof TMACoreObject) {</b>
<b class="nc"><i>2559</i>&nbsp;			TMACoreObject core = (TMACoreObject)pathObject;</b>
<b class="nc"><i>2560</i>&nbsp;			core.setMissing(setToMissing);</b>
<b class="nc"><i>2561</i>&nbsp;			changed.add(core);</b>
<i>2562</i>&nbsp;			// Update any other selected cores to have the same status
<b class="nc"><i>2563</i>&nbsp;			for (PathObject pathObject2 : hierarchy.getSelectionModel().getSelectedObjects()) {</b>
<b class="nc"><i>2564</i>&nbsp;				if (pathObject2 instanceof TMACoreObject) {</b>
<b class="nc"><i>2565</i>&nbsp;					core = (TMACoreObject)pathObject2;</b>
<b class="nc"><i>2566</i>&nbsp;					if (core.isMissing() != setToMissing) {</b>
<b class="nc"><i>2567</i>&nbsp;						core.setMissing(setToMissing);</b>
<b class="nc"><i>2568</i>&nbsp;						changed.add(core);</b>
<i>2569</i>&nbsp;					}
<i>2570</i>&nbsp;				}
<b class="nc"><i>2571</i>&nbsp;			}</b>
<i>2572</i>&nbsp;		}
<b class="nc"><i>2573</i>&nbsp;		if (!changed.isEmpty())</b>
<b class="nc"><i>2574</i>&nbsp;			hierarchy.fireObjectsChangedEvent(getInstance(), changed);</b>
<b class="nc"><i>2575</i>&nbsp;	}</b>
<i>2576</i>&nbsp;		
<i>2577</i>&nbsp;	
<i>2578</i>&nbsp;	/**
<i>2579</i>&nbsp;	 * Update a &#39;set annotation class&#39; menu for a viewer immediately prior to display
<i>2580</i>&nbsp;	 * 
<i>2581</i>&nbsp;	 * @param menuSetClass
<i>2582</i>&nbsp;	 * @param viewer
<i>2583</i>&nbsp;	 */
<i>2584</i>&nbsp;	void updateSetAnnotationPathClassMenu(final Menu menuSetClass, final QuPathViewer viewer) {
<b class="nc"><i>2585</i>&nbsp;		updateSetAnnotationPathClassMenu(menuSetClass.getItems(), viewer, false);</b>
<b class="nc"><i>2586</i>&nbsp;		menuSetClass.setVisible(!menuSetClass.getItems().isEmpty());</b>
<b class="nc"><i>2587</i>&nbsp;	}</b>
<i>2588</i>&nbsp;	
<i>2589</i>&nbsp;	
<i>2590</i>&nbsp;	void updateSetAnnotationPathClassMenu(final CirclePopupMenu menuSetClass, final QuPathViewer viewer) {
<b class="nc"><i>2591</i>&nbsp;		updateSetAnnotationPathClassMenu(menuSetClass.getItems(), viewer, true);</b>
<b class="nc"><i>2592</i>&nbsp;	}</b>
<i>2593</i>&nbsp;
<i>2594</i>&nbsp;		
<i>2595</i>&nbsp;	void updateSetAnnotationPathClassMenu(final ObservableList&lt;MenuItem&gt; menuSetClassItems, final QuPathViewer viewer, final boolean useFancyIcons) {
<i>2596</i>&nbsp;		// We need a viewer and an annotation, as well as some PathClasses, otherwise we just need to ensure the menu isn&#39;t visible
<b class="nc"><i>2597</i>&nbsp;		if (viewer == null || !(viewer.getSelectedObject() instanceof PathAnnotationObject) || availablePathClasses.isEmpty()) {</b>
<b class="nc"><i>2598</i>&nbsp;			menuSetClassItems.clear();</b>
<b class="nc"><i>2599</i>&nbsp;			return;</b>
<i>2600</i>&nbsp;		}
<i>2601</i>&nbsp;		
<b class="nc"><i>2602</i>&nbsp;		PathObject mainPathObject = viewer.getSelectedObject();</b>
<b class="nc"><i>2603</i>&nbsp;		PathClass currentClass = mainPathObject.getPathClass();</b>
<i>2604</i>&nbsp;		
<b class="nc"><i>2605</i>&nbsp;		ToggleGroup group = new ToggleGroup();</b>
<b class="nc"><i>2606</i>&nbsp;		List&lt;MenuItem&gt; itemList = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>2607</i>&nbsp;		RadioMenuItem selected = null;</b>
<b class="nc"><i>2608</i>&nbsp;		for (PathClass pathClass : availablePathClasses) {</b>
<b class="nc"><i>2609</i>&nbsp;			PathClass pathClassToSet = pathClass.getName() == null ? null : pathClass;</b>
<b class="nc"><i>2610</i>&nbsp;			String name = pathClass.getName() == null ? &quot;None&quot; : pathClass.toString();</b>
<b class="nc"><i>2611</i>&nbsp;			Action actionSetClass = new Action(name, e -&gt; {</b>
<b class="nc"><i>2612</i>&nbsp;				List&lt;PathObject&gt; changed = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>2613</i>&nbsp;				for (PathObject pathObject : viewer.getAllSelectedObjects()) {</b>
<b class="nc"><i>2614</i>&nbsp;					if (!pathObject.isAnnotation() || pathObject.getPathClass() == pathClassToSet)</b>
<b class="nc"><i>2615</i>&nbsp;						continue;</b>
<b class="nc"><i>2616</i>&nbsp;					pathObject.setPathClass(pathClassToSet);</b>
<b class="nc"><i>2617</i>&nbsp;					changed.add(pathObject);</b>
<b class="nc"><i>2618</i>&nbsp;				}</b>
<b class="nc"><i>2619</i>&nbsp;				if (!changed.isEmpty())</b>
<b class="nc"><i>2620</i>&nbsp;					viewer.getHierarchy().fireObjectClassificationsChangedEvent(this, changed);				</b>
<b class="nc"><i>2621</i>&nbsp;			});</b>
<i>2622</i>&nbsp;			Node shape;
<b class="nc"><i>2623</i>&nbsp;			if (useFancyIcons) {</b>
<b class="nc"><i>2624</i>&nbsp;				Ellipse r = new Ellipse(TOOLBAR_ICON_SIZE/2.0, TOOLBAR_ICON_SIZE/2.0, TOOLBAR_ICON_SIZE, TOOLBAR_ICON_SIZE);</b>
<b class="nc"><i>2625</i>&nbsp;				if (&quot;None&quot;.equals(name)) {</b>
<b class="nc"><i>2626</i>&nbsp;					r.setFill(Color.rgb(255, 255, 255, 0.75));</b>
<i>2627</i>&nbsp;					
<i>2628</i>&nbsp;				}
<i>2629</i>&nbsp;				else
<b class="nc"><i>2630</i>&nbsp;					r.setFill(ColorToolsFX.getCachedColor(pathClass.getColor()));</b>
<b class="nc"><i>2631</i>&nbsp;				r.setOpacity(0.8);</b>
<b class="nc"><i>2632</i>&nbsp;				DropShadow effect = new DropShadow(6, -3, 3, Color.GRAY);</b>
<b class="nc"><i>2633</i>&nbsp;				r.setEffect(effect);</b>
<b class="nc"><i>2634</i>&nbsp;				shape = r;</b>
<b class="nc"><i>2635</i>&nbsp;			} else {</b>
<b class="nc"><i>2636</i>&nbsp;				Rectangle r = new Rectangle(0, 0, 8, 8);</b>
<b class="nc"><i>2637</i>&nbsp;				r.setFill(&quot;None&quot;.equals(name) ? Color.TRANSPARENT : ColorToolsFX.getCachedColor(pathClass.getColor()));</b>
<b class="nc"><i>2638</i>&nbsp;				shape = r;</b>
<i>2639</i>&nbsp;			}
<i>2640</i>&nbsp;//			actionSetClass.setGraphic(r);
<b class="nc"><i>2641</i>&nbsp;			RadioMenuItem item = ActionUtils.createRadioMenuItem(actionSetClass);</b>
<b class="nc"><i>2642</i>&nbsp;			item.graphicProperty().unbind();</b>
<b class="nc"><i>2643</i>&nbsp;			item.setGraphic(shape);</b>
<b class="nc"><i>2644</i>&nbsp;			item.setToggleGroup(group);</b>
<b class="nc"><i>2645</i>&nbsp;			itemList.add(item);</b>
<b class="nc"><i>2646</i>&nbsp;			if (pathClassToSet == currentClass)</b>
<b class="nc"><i>2647</i>&nbsp;				selected = item;</b>
<b class="nc"><i>2648</i>&nbsp;		}</b>
<b class="nc"><i>2649</i>&nbsp;		group.selectToggle(selected);</b>
<b class="nc"><i>2650</i>&nbsp;		menuSetClassItems.setAll(itemList);</b>
<b class="nc"><i>2651</i>&nbsp;	}</b>
<i>2652</i>&nbsp;	
<i>2653</i>&nbsp;	
<i>2654</i>&nbsp;	/**
<i>2655</i>&nbsp;	 * Open the image represented by the specified ProjectImageEntry.
<i>2656</i>&nbsp;	 * &lt;p&gt;
<i>2657</i>&nbsp;	 * If an image is currently open, this command will prompt to save any changes.
<i>2658</i>&nbsp;	 * 
<i>2659</i>&nbsp;	 * @param entry
<i>2660</i>&nbsp;	 * @return 
<i>2661</i>&nbsp;	 */
<i>2662</i>&nbsp;	public boolean openImageEntry(ProjectImageEntry&lt;BufferedImage&gt; entry) {
<b class="nc"><i>2663</i>&nbsp;		Project&lt;BufferedImage&gt; project = getProject();</b>
<b class="nc"><i>2664</i>&nbsp;		if (entry == null || project == null)</b>
<b class="nc"><i>2665</i>&nbsp;			return false;</b>
<i>2666</i>&nbsp;		
<i>2667</i>&nbsp;		// Check if we&#39;re changing ImageData at all
<b class="nc"><i>2668</i>&nbsp;		var viewer = getViewer();</b>
<b class="nc"><i>2669</i>&nbsp;		ImageData&lt;BufferedImage&gt; imageData = viewer.getImageData();</b>
<b class="nc"><i>2670</i>&nbsp;		if (imageData != null &amp;&amp; project.getEntry(imageData) == entry) {</b>
<b class="nc"><i>2671</i>&nbsp;			return false;</b>
<i>2672</i>&nbsp;		}
<i>2673</i>&nbsp;//		if (imageData != null &amp;&amp; imageData.getServerPath().equals(entry.getServerPath()))
<i>2674</i>&nbsp;//			return false;
<i>2675</i>&nbsp;		
<i>2676</i>&nbsp;		// Check to see if the ImageData is already open in another viewer - if so, just activate it
<i>2677</i>&nbsp;//		String path = entry.getServerPath();
<b class="nc"><i>2678</i>&nbsp;		for (QuPathViewerPlus v : viewerManager.getViewers()) {</b>
<b class="nc"><i>2679</i>&nbsp;			ImageData&lt;BufferedImage&gt; data = v.getImageData();</b>
<b class="nc"><i>2680</i>&nbsp;			if (data != null &amp;&amp; project.getEntry(data) == entry) {</b>
<i>2681</i>&nbsp;//			if (data != null &amp;&amp; data.getServer().getPath().equals(path)) {
<b class="nc"><i>2682</i>&nbsp;				viewerManager.setActiveViewer(v);</b>
<b class="nc"><i>2683</i>&nbsp;				return true;</b>
<i>2684</i>&nbsp;			}
<b class="nc"><i>2685</i>&nbsp;		}</b>
<i>2686</i>&nbsp;		
<i>2687</i>&nbsp;		// If the current ImageData belongs to the current project, check if there are changes to save
<b class="nc"><i>2688</i>&nbsp;		if (imageData != null &amp;&amp; project != null) {</b>
<b class="nc"><i>2689</i>&nbsp;			if (!checkSaveChanges(imageData))</b>
<b class="nc"><i>2690</i>&nbsp;				return false;</b>
<i>2691</i>&nbsp;		}
<i>2692</i>&nbsp;
<i>2693</i>&nbsp;		// Check if we need to rotate the image
<i>2694</i>&nbsp;		try {
<b class="nc"><i>2695</i>&nbsp;			imageData = entry.readImageData();</b>
<b class="nc"><i>2696</i>&nbsp;			viewer.setImageData(imageData);</b>
<i>2697</i>&nbsp;//			setInitialLocationAndMagnification(viewer);
<b class="nc"><i>2698</i>&nbsp;			if (imageData != null &amp;&amp; (imageData.getImageType() == null || imageData.getImageType() == ImageType.UNSET)) {</b>
<b class="nc"><i>2699</i>&nbsp;				var setType = PathPrefs.imageTypeSettingProperty().get();</b>
<b class="nc"><i>2700</i>&nbsp;				if (setType == ImageTypeSetting.AUTO_ESTIMATE) {</b>
<b class="nc"><i>2701</i>&nbsp;					var type = GuiTools.estimateImageType(imageData.getServer(), imageRegionStore.getThumbnail(imageData.getServer(), 0, 0, true));</b>
<b class="nc"><i>2702</i>&nbsp;					logger.info(&quot;Image type estimated to be {}&quot;, type);</b>
<b class="nc"><i>2703</i>&nbsp;					imageData.setImageType(type);</b>
<b class="nc"><i>2704</i>&nbsp;					imageData.setChanged(false); // Don&#39;t want to retain this as a change resulting in a prompt to save the data</b>
<b class="nc"><i>2705</i>&nbsp;				} else if (setType == ImageTypeSetting.PROMPT) {</b>
<b class="nc"><i>2706</i>&nbsp;					ImageDetailsPane.promptToSetImageType(imageData);</b>
<i>2707</i>&nbsp;				}
<i>2708</i>&nbsp;			}
<b class="nc"><i>2709</i>&nbsp;			return true;</b>
<b class="nc"><i>2710</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>2711</i>&nbsp;			Dialogs.showErrorMessage(&quot;Load ImageData&quot;, e);</b>
<b class="nc"><i>2712</i>&nbsp;			return false;</b>
<i>2713</i>&nbsp;		}
<i>2714</i>&nbsp;	}
<i>2715</i>&nbsp;	
<i>2716</i>&nbsp;	
<i>2717</i>&nbsp;	ProjectImageEntry&lt;BufferedImage&gt; getProjectImageEntry(ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>2718</i>&nbsp;		var project = getProject();</b>
<b class="nc"><i>2719</i>&nbsp;		return project == null ? null : project.getEntry(imageData);</b>
<i>2720</i>&nbsp;	}
<i>2721</i>&nbsp;	
<i>2722</i>&nbsp;	/**
<i>2723</i>&nbsp;	 * Check if changes need to be saved for an ImageData, prompting the user if necessary.
<i>2724</i>&nbsp;	 * &lt;p&gt;
<i>2725</i>&nbsp;	 * This will return true if the matter is adequately dealt with (no changes needed, 
<i>2726</i>&nbsp;	 * user saves changes, user declines to save changes) and false otherwise (i.e. user cancelled).
<i>2727</i>&nbsp;	 * 
<i>2728</i>&nbsp;	 * @param imageData
<i>2729</i>&nbsp;	 * @return
<i>2730</i>&nbsp;	 */
<i>2731</i>&nbsp;	boolean checkSaveChanges(ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>2732</i>&nbsp;		if (!imageData.isChanged())</b>
<b class="nc"><i>2733</i>&nbsp;			return true;</b>
<b class="nc"><i>2734</i>&nbsp;		ProjectImageEntry&lt;BufferedImage&gt; entry = getProjectImageEntry(imageData);</b>
<b class="nc"><i>2735</i>&nbsp;		String name = entry == null ? ServerTools.getDisplayableImageName(imageData.getServer()) : entry.getImageName();</b>
<b class="nc"><i>2736</i>&nbsp;		var response = Dialogs.showYesNoCancelDialog(&quot;Save changes&quot;, &quot;Save changes to &quot; + name + &quot;?&quot;);</b>
<b class="nc"><i>2737</i>&nbsp;		if (response == DialogButton.CANCEL)</b>
<b class="nc"><i>2738</i>&nbsp;			return false;</b>
<b class="nc"><i>2739</i>&nbsp;		if (response == DialogButton.NO)</b>
<b class="nc"><i>2740</i>&nbsp;			return true;</b>
<i>2741</i>&nbsp;		
<i>2742</i>&nbsp;		try {
<b class="nc"><i>2743</i>&nbsp;			if (entry == null) {</b>
<b class="nc"><i>2744</i>&nbsp;				String lastPath = imageData.getLastSavedPath();</b>
<b class="nc"><i>2745</i>&nbsp;				File lastFile = lastPath == null ? null : new File(lastPath);</b>
<b class="nc"><i>2746</i>&nbsp;				File dirBase = lastFile == null ? null : lastFile.getParentFile();</b>
<b class="nc"><i>2747</i>&nbsp;				String defaultName = lastFile == null ? null : lastFile.getName();</b>
<b class="nc"><i>2748</i>&nbsp;				File file = Dialogs.promptToSaveFile(&quot;Save data&quot;, dirBase, defaultName, &quot;QuPath data files&quot;, PathPrefs.getSerializationExtension());</b>
<b class="nc"><i>2749</i>&nbsp;				if (file == null)</b>
<b class="nc"><i>2750</i>&nbsp;					return false;</b>
<b class="nc"><i>2751</i>&nbsp;				PathIO.writeImageData(file, imageData);</b>
<b class="nc"><i>2752</i>&nbsp;			} else {</b>
<b class="nc"><i>2753</i>&nbsp;				entry.saveImageData(imageData);</b>
<b class="nc"><i>2754</i>&nbsp;				var project = getProject();</b>
<b class="nc"><i>2755</i>&nbsp;				if (project != null)</b>
<b class="nc"><i>2756</i>&nbsp;					project.syncChanges();</b>
<i>2757</i>&nbsp;			}
<b class="nc"><i>2758</i>&nbsp;			return true;</b>
<b class="nc"><i>2759</i>&nbsp;		} catch (IOException e) {</b>
<b class="nc"><i>2760</i>&nbsp;			Dialogs.showErrorMessage(&quot;Save ImageData&quot;, e);</b>
<b class="nc"><i>2761</i>&nbsp;			return false;</b>
<i>2762</i>&nbsp;		}
<i>2763</i>&nbsp;	}
<i>2764</i>&nbsp;	
<i>2765</i>&nbsp;		
<i>2766</i>&nbsp;	
<i>2767</i>&nbsp;	
<i>2768</i>&nbsp;	/**
<i>2769</i>&nbsp;	 * Open a new whole slide image server or ImageData.
<i>2770</i>&nbsp;	 * If the path is the same as a currently-open server, do nothing.
<i>2771</i>&nbsp;	 * &lt;p&gt;
<i>2772</i>&nbsp;	 * If this encounters an exception, an error message will be shown.
<i>2773</i>&nbsp;	 * @param pathNew 
<i>2774</i>&nbsp;	 * @param prompt if true, give the user the opportunity to cancel opening if a whole slide server is already set
<i>2775</i>&nbsp;	 * @param includeURLs 
<i>2776</i>&nbsp;	 * @return true if the server was set for this GUI, false otherwise
<i>2777</i>&nbsp;	 */
<i>2778</i>&nbsp;	public boolean openImage(String pathNew, boolean prompt, boolean includeURLs) {
<i>2779</i>&nbsp;		try {
<b class="fc"><i>2780</i>&nbsp;			return openImage(getViewer(), pathNew, prompt, includeURLs);</b>
<b class="nc"><i>2781</i>&nbsp;		} catch (IOException e) {</b>
<b class="nc"><i>2782</i>&nbsp;			Dialogs.showErrorMessage(&quot;Open image&quot;, e);</b>
<b class="nc"><i>2783</i>&nbsp;			return false;</b>
<i>2784</i>&nbsp;		}
<i>2785</i>&nbsp;	}
<i>2786</i>&nbsp;
<i>2787</i>&nbsp;	/**
<i>2788</i>&nbsp;	 * Open a new whole slide image server, or ImageData.
<i>2789</i>&nbsp;	 * If the path is the same as a currently-open server, do nothing.
<i>2790</i>&nbsp;	 * 
<i>2791</i>&nbsp;	 * @param viewer the viewer into which the image should be opened
<i>2792</i>&nbsp;	 * @param pathNew 
<i>2793</i>&nbsp;	 * @param prompt if true, give the user the opportunity to cancel opening if a whole slide server is already set
<i>2794</i>&nbsp;	 * @param includeURLs if true, any prompt should support URL input and not only a file chooser
<i>2795</i>&nbsp;	 * @return true if the server was set for this GUI, false otherwise
<i>2796</i>&nbsp;	 * @throws IOException 
<i>2797</i>&nbsp;	 */
<i>2798</i>&nbsp;	public boolean openImage(QuPathViewer viewer, String pathNew, boolean prompt, boolean includeURLs) throws IOException {
<i>2799</i>&nbsp;		
<b class="fc"><i>2800</i>&nbsp;		if (viewer == null) {</b>
<b class="nc"><i>2801</i>&nbsp;			if (getViewers().size() == 1)</b>
<b class="nc"><i>2802</i>&nbsp;				viewer = getViewer();</b>
<i>2803</i>&nbsp;			else {
<b class="nc"><i>2804</i>&nbsp;				Dialogs.showErrorMessage(&quot;Open image&quot;, &quot;Please specify the viewer where the image should be opened!&quot;);</b>
<b class="nc"><i>2805</i>&nbsp;				return false;</b>
<i>2806</i>&nbsp;			}
<i>2807</i>&nbsp;		}
<i>2808</i>&nbsp;		
<b class="fc"><i>2809</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = viewer.getServer();</b>
<b class="fc"><i>2810</i>&nbsp;		String pathOld = null;</b>
<b class="fc"><i>2811</i>&nbsp;		File fileBase = null;</b>
<b class="fc"><i>2812</i>&nbsp;		if (server != null) {</b>
<b class="nc"><i>2813</i>&nbsp;			var uris = server.getURIs();</b>
<b class="nc"><i>2814</i>&nbsp;			if (uris.size() == 1) {</b>
<b class="nc"><i>2815</i>&nbsp;				var uri = uris.iterator().next();</b>
<b class="nc"><i>2816</i>&nbsp;				pathOld = uri.toString();</b>
<i>2817</i>&nbsp;				try {
<b class="nc"><i>2818</i>&nbsp;					var path = GeneralTools.toPath(uri);</b>
<b class="nc"><i>2819</i>&nbsp;					if (path != null)</b>
<b class="nc"><i>2820</i>&nbsp;						fileBase = path.toFile().getParentFile();</b>
<b class="nc"><i>2821</i>&nbsp;				} catch (Exception e) {};</b>
<i>2822</i>&nbsp;			}
<i>2823</i>&nbsp;//			pathOld = server.getPath();
<i>2824</i>&nbsp;//			try {
<i>2825</i>&nbsp;//				fileBase = new File(pathOld).getParentFile();
<i>2826</i>&nbsp;//			} catch (Exception e) {};
<i>2827</i>&nbsp;		}
<i>2828</i>&nbsp;		// Prompt for a path, if required
<b class="fc"><i>2829</i>&nbsp;		File fileNew = null;</b>
<b class="fc"><i>2830</i>&nbsp;		if (pathNew == null) {</b>
<b class="fc"><i>2831</i>&nbsp;			if (includeURLs) {</b>
<b class="nc"><i>2832</i>&nbsp;				pathNew = Dialogs.promptForFilePathOrURL(&quot;Choose path&quot;, pathOld, fileBase, null);</b>
<b class="nc"><i>2833</i>&nbsp;				if (pathNew == null)</b>
<b class="nc"><i>2834</i>&nbsp;					return false;</b>
<b class="nc"><i>2835</i>&nbsp;				fileNew = new File(pathNew);</b>
<i>2836</i>&nbsp;			} else {
<b class="fc"><i>2837</i>&nbsp;				fileNew = Dialogs.promptForFile(null, fileBase, null);</b>
<b class="fc"><i>2838</i>&nbsp;				if (fileNew == null)</b>
<b class="nc"><i>2839</i>&nbsp;					return false;</b>
<b class="fc"><i>2840</i>&nbsp;				pathNew = fileNew.getAbsolutePath();</b>
<i>2841</i>&nbsp;			}
<i>2842</i>&nbsp;		} else
<b class="nc"><i>2843</i>&nbsp;			fileNew = new File(pathNew);</b>
<i>2844</i>&nbsp;		
<i>2845</i>&nbsp;		// If we have a file, check if it is a data file - if so, handle differently
<b class="fc"><i>2846</i>&nbsp;		if (fileNew.isFile() &amp;&amp; GeneralTools.checkExtensions(pathNew, PathPrefs.getSerializationExtension()))</b>
<b class="nc"><i>2847</i>&nbsp;			return openSavedData(viewer, fileNew, false, true);</b>
<i>2848</i>&nbsp;
<i>2849</i>&nbsp;		// Check for project file
<b class="fc"><i>2850</i>&nbsp;		if (fileNew.isFile() &amp;&amp; GeneralTools.checkExtensions(pathNew, ProjectIO.getProjectExtension())) {</b>
<b class="nc"><i>2851</i>&nbsp;				logger.info(&quot;Trying to load project {}&quot;, fileNew.getAbsolutePath());</b>
<i>2852</i>&nbsp;				try {
<b class="nc"><i>2853</i>&nbsp;					Project&lt;BufferedImage&gt; project = ProjectIO.loadProject(fileNew, BufferedImage.class);</b>
<b class="nc"><i>2854</i>&nbsp;					if (project != null) {</b>
<b class="nc"><i>2855</i>&nbsp;						setProject(project);</b>
<b class="nc"><i>2856</i>&nbsp;						return true;</b>
<i>2857</i>&nbsp;					}
<b class="nc"><i>2858</i>&nbsp;				} catch (Exception e) {</b>
<b class="nc"><i>2859</i>&nbsp;					Dialogs.showErrorMessage(&quot;Open project&quot;, e);</b>
<b class="nc"><i>2860</i>&nbsp;					logger.error(&quot;Error opening project &quot; + fileNew.getAbsolutePath(), e);</b>
<b class="nc"><i>2861</i>&nbsp;					return false;</b>
<b class="nc"><i>2862</i>&nbsp;				}</b>
<i>2863</i>&nbsp;		}
<i>2864</i>&nbsp;
<i>2865</i>&nbsp;		
<i>2866</i>&nbsp;		// Try opening an image, unless it&#39;s the same as the image currently open
<b class="fc"><i>2867</i>&nbsp;		if (!pathNew.equals(pathOld)) {</b>
<i>2868</i>&nbsp;			// If we have a project, show the import dialog
<b class="fc"><i>2869</i>&nbsp;			if (getProject() != null) {</b>
<b class="nc"><i>2870</i>&nbsp;				List&lt;ProjectImageEntry&lt;BufferedImage&gt;&gt; entries = ProjectCommands.promptToImportImages(this, pathNew);</b>
<b class="nc"><i>2871</i>&nbsp;				if (entries.isEmpty())</b>
<b class="nc"><i>2872</i>&nbsp;					return false;</b>
<b class="nc"><i>2873</i>&nbsp;				return openImageEntry(entries.get(0));</b>
<i>2874</i>&nbsp;			}
<b class="fc"><i>2875</i>&nbsp;			ImageServer&lt;BufferedImage&gt; serverNew = null;</b>
<i>2876</i>&nbsp;
<b class="fc"><i>2877</i>&nbsp;			UriImageSupport&lt;BufferedImage&gt; support = ImageServerProvider.getPreferredUriImageSupport(BufferedImage.class, pathNew);</b>
<b class="fc"><i>2878</i>&nbsp;			List&lt;ServerBuilder&lt;BufferedImage&gt;&gt; builders = support == null ? Collections.emptyList() : support.getBuilders();</b>
<i>2879</i>&nbsp;//			List&lt;ImageServer&lt;BufferedImage&gt;&gt; serverList = ImageServerProvider.getServerList(pathNew, BufferedImage.class);
<i>2880</i>&nbsp;			
<b class="fc"><i>2881</i>&nbsp;			if (builders.isEmpty()) {</b>
<b class="nc"><i>2882</i>&nbsp;				String message = &quot;Unable to build ImageServer for &quot; + pathNew + &quot;.\nSee View &gt; Show log for more details&quot;;</b>
<b class="nc"><i>2883</i>&nbsp;				Dialogs.showErrorMessage(&quot;Unable to build server&quot;, message);</b>
<b class="nc"><i>2884</i>&nbsp;				return false;</b>
<i>2885</i>&nbsp;			}
<b class="fc"><i>2886</i>&nbsp;			else if (builders.size() == 1) {</b>
<i>2887</i>&nbsp;				try {
<b class="fc"><i>2888</i>&nbsp;					serverNew = builders.get(0).build();</b>
<b class="nc"><i>2889</i>&nbsp;				} catch (Exception e) {	</b>
<b class="nc"><i>2890</i>&nbsp;					logger.error(&quot;Error building server: &quot; + e.getLocalizedMessage(), e);</b>
<b class="fc"><i>2891</i>&nbsp;				}</b>
<i>2892</i>&nbsp;			} else {
<b class="nc"><i>2893</i>&nbsp;				var selector = new ServerSelector(builders);</b>
<b class="nc"><i>2894</i>&nbsp;				serverNew = selector.promptToSelectServer();</b>
<b class="nc"><i>2895</i>&nbsp;				if (serverNew == null)</b>
<b class="nc"><i>2896</i>&nbsp;					return false;</b>
<i>2897</i>&nbsp;			}
<i>2898</i>&nbsp;
<b class="fc"><i>2899</i>&nbsp;			if (serverNew != null) {</b>
<b class="fc"><i>2900</i>&nbsp;				if (pathOld != null &amp;&amp; prompt &amp;&amp; !viewer.getHierarchy().isEmpty()) {</b>
<b class="nc"><i>2901</i>&nbsp;					if (!Dialogs.showYesNoDialog(&quot;Replace open image&quot;, &quot;Close &quot; + ServerTools.getDisplayableImageName(server) + &quot;?&quot;))</b>
<b class="nc"><i>2902</i>&nbsp;						return false;</b>
<i>2903</i>&nbsp;				}
<b class="fc"><i>2904</i>&nbsp;				ImageData&lt;BufferedImage&gt; imageData = null;</b>
<b class="fc"><i>2905</i>&nbsp;				if (serverNew != null) {</b>
<b class="fc"><i>2906</i>&nbsp;					int minSize = PathPrefs.minPyramidDimensionProperty().get();</b>
<b class="fc"><i>2907</i>&nbsp;					if (serverNew.nResolutions() == 1 &amp;&amp; Math.max(serverNew.getWidth(), serverNew.getHeight()) &gt; minSize) {</b>
<i>2908</i>&nbsp;						// Check if we have any hope at all with the current settings
<b class="nc"><i>2909</i>&nbsp;						long estimatedBytes = (long)serverNew.getWidth() * (long)serverNew.getHeight() * (long)serverNew.nChannels() * (long)serverNew.getPixelType().getBytesPerPixel();</b>
<b class="nc"><i>2910</i>&nbsp;						double requiredBytes = estimatedBytes * (4.0/3.0);</b>
<b class="nc"><i>2911</i>&nbsp;						if (prompt &amp;&amp; imageRegionStore != null &amp;&amp; requiredBytes &gt;= imageRegionStore.getTileCacheSize()) {</b>
<b class="nc"><i>2912</i>&nbsp;							logger.warn(&quot;Selected image is {} x {} x {} pixels ({})&quot;, serverNew.getWidth(), serverNew.getHeight(), serverNew.nChannels(), serverNew.getPixelType());</b>
<b class="nc"><i>2913</i>&nbsp;							Dialogs.showErrorMessage(&quot;Image too large&quot;,</b>
<i>2914</i>&nbsp;									&quot;Non-pyramidal image is too large for the available tile cache!\n&quot; +
<i>2915</i>&nbsp;									&quot;Try converting the image to a pyramidal file format, or increasing the memory available to QuPath.&quot;);
<b class="nc"><i>2916</i>&nbsp;							return false;</b>
<i>2917</i>&nbsp;						}
<i>2918</i>&nbsp;						// Offer to pyramidalize
<b class="nc"><i>2919</i>&nbsp;						var serverWrapped = ImageServers.pyramidalize(serverNew);</b>
<b class="nc"><i>2920</i>&nbsp;						if (serverWrapped.nResolutions() &gt; 1) {</b>
<b class="nc"><i>2921</i>&nbsp;							if (prompt) {</b>
<b class="nc"><i>2922</i>&nbsp;								var response = Dialogs.showYesNoCancelDialog(&quot;Auto pyramidalize&quot;,</b>
<i>2923</i>&nbsp;										&quot;QuPath works best with large images saved in a pyramidal format.\n\n&quot; +
<b class="nc"><i>2924</i>&nbsp;										&quot;Do you want to generate a pyramid dynamically from &quot; + ServerTools.getDisplayableImageName(serverNew) + &quot;?&quot; +</b>
<i>2925</i>&nbsp;										&quot;\n(This requires more memory, but is usually worth it)&quot;);
<b class="nc"><i>2926</i>&nbsp;								if (response == DialogButton.CANCEL)</b>
<b class="nc"><i>2927</i>&nbsp;									return false;</b>
<b class="nc"><i>2928</i>&nbsp;								if (response == DialogButton.YES)</b>
<b class="nc"><i>2929</i>&nbsp;									serverNew = serverWrapped;</b>
<i>2930</i>&nbsp;							}
<i>2931</i>&nbsp;						}
<i>2932</i>&nbsp;					}
<b class="fc"><i>2933</i>&nbsp;					imageData = createNewImageData(serverNew);</b>
<i>2934</i>&nbsp;				}
<i>2935</i>&nbsp;				
<b class="fc"><i>2936</i>&nbsp;				viewer.setImageData(imageData);</b>
<i>2937</i>&nbsp;//				setInitialLocationAndMagnification(viewer);
<i>2938</i>&nbsp;
<b class="fc"><i>2939</i>&nbsp;				if (imageData.getImageType() == ImageType.UNSET &amp;&amp; PathPrefs.imageTypeSettingProperty().get() == ImageTypeSetting.PROMPT)</b>
<b class="fc"><i>2940</i>&nbsp;					ImageDetailsPane.promptToSetImageType(imageData);</b>
<i>2941</i>&nbsp;
<i>2942</i>&nbsp;//				// Reset the object hierarchy to clear any ROIs etc.
<i>2943</i>&nbsp;//				hierarchy.clearAll();
<i>2944</i>&nbsp;//				hierarchy.getSelectionModel().resetSelection();
<i>2945</i>&nbsp;				
<b class="fc"><i>2946</i>&nbsp;				return true;</b>
<i>2947</i>&nbsp;			} else {
<i>2948</i>&nbsp;				// Show an error message if we can&#39;t open the file
<b class="nc"><i>2949</i>&nbsp;				Dialogs.showErrorNotification(&quot;Open image&quot;, &quot;Sorry, I can&#39;t open &quot; + pathNew);</b>
<i>2950</i>&nbsp;//				logger.error(&quot;Unable to build whole slide server for path &#39;{}&#39;&quot;, pathNew);
<i>2951</i>&nbsp;			}
<i>2952</i>&nbsp;		}
<b class="nc"><i>2953</i>&nbsp;		return false;</b>
<i>2954</i>&nbsp;	}
<i>2955</i>&nbsp;	
<i>2956</i>&nbsp;
<i>2957</i>&nbsp;	
<i>2958</i>&nbsp;	/**
<i>2959</i>&nbsp;	 * Create a new {@link ImageData} from the specified server.
<i>2960</i>&nbsp;	 * @param server
<i>2961</i>&nbsp;	 * @return
<i>2962</i>&nbsp;	 */
<i>2963</i>&nbsp;	private ImageData&lt;BufferedImage&gt; createNewImageData(final ImageServer&lt;BufferedImage&gt; server) {
<b class="fc"><i>2964</i>&nbsp;		return createNewImageData(server, PathPrefs.imageTypeSettingProperty().get() == ImageTypeSetting.AUTO_ESTIMATE);</b>
<i>2965</i>&nbsp;	}
<i>2966</i>&nbsp;	
<i>2967</i>&nbsp;	/**
<i>2968</i>&nbsp;	 * Create a new ImageData, optionally estimating the image type.
<i>2969</i>&nbsp;	 * 
<i>2970</i>&nbsp;	 * @param server
<i>2971</i>&nbsp;	 * @param estimateImageType
<i>2972</i>&nbsp;	 * @return
<i>2973</i>&nbsp;	 */
<i>2974</i>&nbsp;	public ImageData&lt;BufferedImage&gt; createNewImageData(final ImageServer&lt;BufferedImage&gt; server, final boolean estimateImageType) {
<b class="fc"><i>2975</i>&nbsp;		return new ImageData&lt;BufferedImage&gt;(server, estimateImageType ? GuiTools.estimateImageType(server, imageRegionStore.getThumbnail(server, 0, 0, true)) : ImageData.ImageType.UNSET);</b>
<i>2976</i>&nbsp;	}
<i>2977</i>&nbsp;	
<i>2978</i>&nbsp;	
<i>2979</i>&nbsp;	
<i>2980</i>&nbsp;	/**
<i>2981</i>&nbsp;	 * Check the user directory, and run a Groovy script called &quot;startup.groovy&quot; - if it exists.
<i>2982</i>&nbsp;	 * @throws ScriptException 
<i>2983</i>&nbsp;	 * @throws FileNotFoundException 
<i>2984</i>&nbsp;	 */
<i>2985</i>&nbsp;	private void runStartupScript() throws FileNotFoundException, ScriptException {
<b class="fc"><i>2986</i>&nbsp;		String pathUsers = PathPrefs.getUserPath();</b>
<b class="fc"><i>2987</i>&nbsp;		File fileScript = pathUsers == null ? null : new File(pathUsers, &quot;startup.groovy&quot;);</b>
<b class="fc"><i>2988</i>&nbsp;		if (fileScript != null &amp;&amp; fileScript.exists()) {</b>
<b class="nc"><i>2989</i>&nbsp;			logger.info(&quot;Startup script found at {}&quot;, fileScript.getAbsolutePath());</b>
<b class="nc"><i>2990</i>&nbsp;			if (PathPrefs.runStartupScriptProperty().get()) {</b>
<b class="nc"><i>2991</i>&nbsp;				logger.info(&quot;Running startup script (you can turn this setting off in the preferences panel)&quot;);</b>
<i>2992</i>&nbsp;				try {
<b class="nc"><i>2993</i>&nbsp;					runScript(fileScript, null);</b>
<b class="nc"><i>2994</i>&nbsp;				} catch (Exception e) {</b>
<b class="nc"><i>2995</i>&nbsp;					logger.error(&quot;Error running startup.groovy: &quot; + e.getLocalizedMessage(), e);</b>
<b class="nc"><i>2996</i>&nbsp;				}</b>
<i>2997</i>&nbsp;			} else {
<b class="nc"><i>2998</i>&nbsp;				logger.warn(&quot;You need to enable the startup script in the Preferences if you want to run it&quot;);</b>
<i>2999</i>&nbsp;			}
<i>3000</i>&nbsp;		} else {
<b class="fc"><i>3001</i>&nbsp;			logger.debug(&quot;No startup script found&quot;);</b>
<i>3002</i>&nbsp;		}
<b class="fc"><i>3003</i>&nbsp;	}</b>
<i>3004</i>&nbsp;	
<i>3005</i>&nbsp;	
<i>3006</i>&nbsp;	/**
<i>3007</i>&nbsp;	 * Install a Groovy script as a new command in QuPath.
<i>3008</i>&nbsp;	 * @param menuPath menu where the command should be installed; see {@link #lookupMenuItem(String)} for the specification.
<i>3009</i>&nbsp;	 *                 If only a name is provided, the command will be added to the &quot;Extensions&quot; menu.
<i>3010</i>&nbsp;	 *                 If a menu item already exists for the given path, it will be removed.
<i>3011</i>&nbsp;	 * @param file the Groovy script to run; note that this will be reloaded each time it is required
<i>3012</i>&nbsp;	 * @return the {@link MenuItem} for the command
<i>3013</i>&nbsp;	 * @see #installGroovyCommand(String, String)
<i>3014</i>&nbsp;	 */
<i>3015</i>&nbsp;	public MenuItem installGroovyCommand(String menuPath, final File file) {
<b class="nc"><i>3016</i>&nbsp;		return installCommand(menuPath, () -&gt; {</b>
<i>3017</i>&nbsp;			try {
<b class="nc"><i>3018</i>&nbsp;				runScript(file, getImageData());</b>
<b class="nc"><i>3019</i>&nbsp;			} catch (IOException e) {</b>
<b class="nc"><i>3020</i>&nbsp;				Dialogs.showErrorMessage(&quot;Script error&quot;, e);</b>
<b class="nc"><i>3021</i>&nbsp;			}</b>
<b class="nc"><i>3022</i>&nbsp;		});</b>
<i>3023</i>&nbsp;	}
<i>3024</i>&nbsp;	
<i>3025</i>&nbsp;	/**
<i>3026</i>&nbsp;	 * Install a Groovy script as a new command in QuPath.
<i>3027</i>&nbsp;	 * @param menuPath menu where the command should be installed; see {@link #lookupMenuItem(String)} for the specification.
<i>3028</i>&nbsp;	 *                 If only a name is provided, the command will be added to the &quot;Extensions&quot; menu.
<i>3029</i>&nbsp;	 *                 If a menu item already exists for the given path, it will be removed.
<i>3030</i>&nbsp;	 * @param script the Groovy script to run
<i>3031</i>&nbsp;	 * @return the {@link MenuItem} for the command
<i>3032</i>&nbsp;	 * @see #installGroovyCommand(String, File)
<i>3033</i>&nbsp;	 */
<i>3034</i>&nbsp;	public MenuItem installGroovyCommand(String menuPath, final String script) {
<b class="nc"><i>3035</i>&nbsp;		return installCommand(menuPath, () -&gt; runScript(script, getImageData()));</b>
<i>3036</i>&nbsp;	}
<i>3037</i>&nbsp;	
<i>3038</i>&nbsp;	/**
<i>3039</i>&nbsp;	 * Install a new command in QuPath that takes the current {@link ImageData} as input.
<i>3040</i>&nbsp;	 * The command will only be enabled when an image is available.
<i>3041</i>&nbsp;	 * @param menuPath menu where the command should be installed; see {@link #lookupMenuItem(String)} for the specification.
<i>3042</i>&nbsp;	 *                 If only a name is provided, the command will be added to the &quot;Extensions&quot; menu.
<i>3043</i>&nbsp;	 *                 If a menu item already exists for the given path, it will be removed.
<i>3044</i>&nbsp;	 * @param command the command to run
<i>3045</i>&nbsp;	 * @return the {@link MenuItem} for the command
<i>3046</i>&nbsp;	 * @see #installCommand(String, Runnable)
<i>3047</i>&nbsp;	 */
<i>3048</i>&nbsp;	public MenuItem installImageDataCommand(String menuPath, final Consumer&lt;ImageData&lt;BufferedImage&gt;&gt; command) {
<b class="nc"><i>3049</i>&nbsp;		if (!Platform.isFxApplicationThread()) {</b>
<b class="nc"><i>3050</i>&nbsp;			return GuiTools.callOnApplicationThread(() -&gt; installImageDataCommand(menuPath, command));</b>
<i>3051</i>&nbsp;		}
<b class="nc"><i>3052</i>&nbsp;		Menu menu = parseMenu(menuPath, &quot;Extensions&quot;, true);</b>
<b class="nc"><i>3053</i>&nbsp;		String name = parseName(menuPath);</b>
<b class="nc"><i>3054</i>&nbsp;		var action = createImageDataAction(command, name);</b>
<b class="nc"><i>3055</i>&nbsp;		var item = ActionTools.createMenuItem(action);</b>
<b class="nc"><i>3056</i>&nbsp;		addOrReplaceItem(menu.getItems(), item);</b>
<b class="nc"><i>3057</i>&nbsp;		return item;</b>
<i>3058</i>&nbsp;	}
<i>3059</i>&nbsp;	
<i>3060</i>&nbsp;	/**
<i>3061</i>&nbsp;	 * Install a new command in QuPath.
<i>3062</i>&nbsp;	 * @param menuPath menu where the command should be installed; see {@link #lookupMenuItem(String)} for the specification.
<i>3063</i>&nbsp;	 *                 If only a name is provided, the command will be added to the &quot;Extensions&quot; menu.
<i>3064</i>&nbsp;	 *                 If a menu item already exists for the given path, it will be removed.
<i>3065</i>&nbsp;	 * @param runnable the command to run
<i>3066</i>&nbsp;	 * @return the {@link MenuItem} for the command. This can be further customized if needed.
<i>3067</i>&nbsp;	 */
<i>3068</i>&nbsp;	public MenuItem installCommand(String menuPath, Runnable runnable) {
<b class="nc"><i>3069</i>&nbsp;		if (!Platform.isFxApplicationThread()) {</b>
<b class="nc"><i>3070</i>&nbsp;			return GuiTools.callOnApplicationThread(() -&gt; installCommand(menuPath, runnable));</b>
<i>3071</i>&nbsp;		}
<b class="nc"><i>3072</i>&nbsp;		Menu menu = parseMenu(menuPath, &quot;Extensions&quot;, true);</b>
<b class="nc"><i>3073</i>&nbsp;		String name = parseName(menuPath);</b>
<b class="nc"><i>3074</i>&nbsp;		var action = ActionTools.createAction(runnable, name);</b>
<b class="nc"><i>3075</i>&nbsp;		var item = ActionTools.createMenuItem(action);</b>
<b class="nc"><i>3076</i>&nbsp;		addOrReplaceItem(menu.getItems(), item);</b>
<b class="nc"><i>3077</i>&nbsp;		return item;</b>
<i>3078</i>&nbsp;	}
<i>3079</i>&nbsp;	
<i>3080</i>&nbsp;	private void addOrReplaceItem(List&lt;MenuItem&gt; items, MenuItem item) {
<b class="nc"><i>3081</i>&nbsp;		String name = item.getText();</b>
<b class="nc"><i>3082</i>&nbsp;		if (name != null) {</b>
<b class="nc"><i>3083</i>&nbsp;			for (int i = 0; i &lt; items.size(); i++) {</b>
<b class="nc"><i>3084</i>&nbsp;				if (name.equals(items.get(i).getText())) {</b>
<b class="nc"><i>3085</i>&nbsp;					items.set(i, item);</b>
<b class="nc"><i>3086</i>&nbsp;					return;</b>
<i>3087</i>&nbsp;				}
<i>3088</i>&nbsp;			}
<i>3089</i>&nbsp;		}
<b class="nc"><i>3090</i>&nbsp;		items.add(item);</b>
<b class="nc"><i>3091</i>&nbsp;	}</b>
<i>3092</i>&nbsp;	
<i>3093</i>&nbsp;	/**
<i>3094</i>&nbsp;	 * Identify a menu by parsing a menu path.
<i>3095</i>&nbsp;	 * @param menuPath the path to the menu, separated by {@code &gt;}
<i>3096</i>&nbsp;	 * @param defaultMenu the default menu to use, if no other menu can be found
<i>3097</i>&nbsp;	 * @param create if true, create the menu if it does not already exist.
<i>3098</i>&nbsp;	 * @return
<i>3099</i>&nbsp;	 */
<i>3100</i>&nbsp;	private Menu parseMenu(String menuPath, String defaultMenu, boolean create) {
<b class="nc"><i>3101</i>&nbsp;		int separator = menuPath.lastIndexOf(&quot;&gt;&quot;);</b>
<b class="nc"><i>3102</i>&nbsp;		if (separator &lt; 0) {</b>
<b class="nc"><i>3103</i>&nbsp;			return getMenu(defaultMenu, create);</b>
<i>3104</i>&nbsp;		} else {
<b class="nc"><i>3105</i>&nbsp;			return getMenu(menuPath.substring(0, separator), create);</b>
<i>3106</i>&nbsp;		}
<i>3107</i>&nbsp;	}
<i>3108</i>&nbsp;	
<i>3109</i>&nbsp;	private String parseName(String menuPath) {
<b class="nc"><i>3110</i>&nbsp;		int separator = menuPath.lastIndexOf(&quot;&gt;&quot;);</b>
<b class="nc"><i>3111</i>&nbsp;		if (separator &lt; 0) {</b>
<b class="nc"><i>3112</i>&nbsp;			return menuPath;</b>
<i>3113</i>&nbsp;		} else {
<b class="nc"><i>3114</i>&nbsp;			return menuPath.substring(separator+1);</b>
<i>3115</i>&nbsp;		}
<i>3116</i>&nbsp;	}
<i>3117</i>&nbsp;		
<i>3118</i>&nbsp;	
<i>3119</i>&nbsp;	/**
<i>3120</i>&nbsp;	 * Convenience method to execute a Groovy script.
<i>3121</i>&nbsp;	 * @param script the script to run
<i>3122</i>&nbsp;	 * @param imageData an {@link ImageData} object for the current image (may be null)
<i>3123</i>&nbsp;	 * @return result of the script execution
<i>3124</i>&nbsp;	 */
<i>3125</i>&nbsp;	private Object runScript(final String script, final ImageData&lt;BufferedImage&gt; imageData) {
<b class="nc"><i>3126</i>&nbsp;		return DefaultScriptEditor.executeScript(Language.GROOVY, script, getProject(), imageData, true, null);</b>
<i>3127</i>&nbsp;	}
<i>3128</i>&nbsp;	
<i>3129</i>&nbsp;	/**
<i>3130</i>&nbsp;	 * Convenience method to execute a Groovy from a file.
<i>3131</i>&nbsp;	 * The file will be reloaded each time it is required.
<i>3132</i>&nbsp;	 * @param file File containing the script to run
<i>3133</i>&nbsp;	 * @param imageData an {@link ImageData} object for the current image (may be null)
<i>3134</i>&nbsp;	 * @return result of the script execution
<i>3135</i>&nbsp;	 * @throws IOException 
<i>3136</i>&nbsp;	 */
<i>3137</i>&nbsp;	private Object runScript(final File file, final ImageData&lt;BufferedImage&gt; imageData) throws IOException {
<b class="nc"><i>3138</i>&nbsp;		var script = GeneralTools.readFileAsString(file.getAbsolutePath());</b>
<b class="nc"><i>3139</i>&nbsp;		return runScript(script, imageData);</b>
<i>3140</i>&nbsp;	}
<i>3141</i>&nbsp;	
<i>3142</i>&nbsp;	
<i>3143</i>&nbsp;	
<i>3144</i>&nbsp;	/**
<i>3145</i>&nbsp;	 * Open a saved data file within a particular viewer, optionally keeping the same ImageServer as is currently open.
<i>3146</i>&nbsp;	 * The purpose of this is to make it possible for a project (for example) to open the correct server prior to
<i>3147</i>&nbsp;	 * opening the data file, enabling it to make use of relative path names and not have to rely on the absolute path
<i>3148</i>&nbsp;	 * encoded within the ImageData.
<i>3149</i>&nbsp;	 * 
<i>3150</i>&nbsp;	 * @param viewer
<i>3151</i>&nbsp;	 * @param file
<i>3152</i>&nbsp;	 * @param keepExistingServer if true and the viewer already has an ImageServer, then any ImageServer path recorded within the data file will be ignored
<i>3153</i>&nbsp;	 * @param promptToSaveChanges if true, the user will be prompted to ask whether to save changes or not
<i>3154</i>&nbsp;	 * @return
<i>3155</i>&nbsp;	 * @throws IOException 
<i>3156</i>&nbsp;	 */
<i>3157</i>&nbsp;	public boolean openSavedData(QuPathViewer viewer, final File file, final boolean keepExistingServer, boolean promptToSaveChanges) throws IOException {
<i>3158</i>&nbsp;		
<b class="nc"><i>3159</i>&nbsp;		if (viewer == null) {</b>
<b class="nc"><i>3160</i>&nbsp;			if (getViewers().size() == 1)</b>
<b class="nc"><i>3161</i>&nbsp;				viewer = getViewer();</b>
<i>3162</i>&nbsp;			else {
<b class="nc"><i>3163</i>&nbsp;				Dialogs.showErrorMessage(&quot;Open saved data&quot;, &quot;Please specify the viewer where the data should be opened!&quot;);</b>
<b class="nc"><i>3164</i>&nbsp;				return false;</b>
<i>3165</i>&nbsp;			}
<i>3166</i>&nbsp;		}
<i>3167</i>&nbsp;		
<i>3168</i>&nbsp;		// First check to see if the ImageData is already open - if so, just activate the viewer
<b class="nc"><i>3169</i>&nbsp;		for (QuPathViewerPlus v : viewerManager.getViewers()) {</b>
<b class="nc"><i>3170</i>&nbsp;			ImageData&lt;?&gt; data = v.getImageData();</b>
<b class="nc"><i>3171</i>&nbsp;			if (data != null &amp;&amp; data.getLastSavedPath() != null &amp;&amp; new File(data.getLastSavedPath()).equals(file)) {</b>
<b class="nc"><i>3172</i>&nbsp;				viewerManager.setActiveViewer(v);</b>
<b class="nc"><i>3173</i>&nbsp;				return true;</b>
<i>3174</i>&nbsp;			}
<b class="nc"><i>3175</i>&nbsp;		}</b>
<i>3176</i>&nbsp;		
<b class="nc"><i>3177</i>&nbsp;		String serverPath = null;</b>
<b class="nc"><i>3178</i>&nbsp;		ImageData&lt;BufferedImage&gt; imageData = viewer.getImageData();</b>
<i>3179</i>&nbsp;		
<i>3180</i>&nbsp;		// If we are loading data related to the same image server, load into that - otherwise open a new image if we can find it
<i>3181</i>&nbsp;		try {
<b class="nc"><i>3182</i>&nbsp;			serverPath = PathIO.readSerializedServerPath(file);</b>
<b class="nc"><i>3183</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>3184</i>&nbsp;			logger.warn(&quot;Unable to read server path from file: {}&quot;, e.getLocalizedMessage());</b>
<b class="nc"><i>3185</i>&nbsp;		}</b>
<b class="nc"><i>3186</i>&nbsp;		boolean sameServer = serverPath == null || (imageData != null &amp;&amp; imageData.getServerPath().equals(serverPath));			</b>
<i>3187</i>&nbsp;		
<i>3188</i>&nbsp;		
<i>3189</i>&nbsp;		// If we don&#39;t have the same server, try to check the path is valid.
<i>3190</i>&nbsp;		// If it isn&#39;t, then prompt to enter a new path.
<i>3191</i>&nbsp;		// Currently, URLs are always assumed to be valid, but files may have moved.
<i>3192</i>&nbsp;		// TODO: Make it possible to recover data if a stored URL ceases to be valid.
<b class="nc"><i>3193</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = null;</b>
<b class="nc"><i>3194</i>&nbsp;		if (sameServer || (imageData != null &amp;&amp; keepExistingServer))</b>
<b class="nc"><i>3195</i>&nbsp;			server = imageData.getServer();</b>
<i>3196</i>&nbsp;		else {
<i>3197</i>&nbsp;			try {
<b class="nc"><i>3198</i>&nbsp;				server = ImageServerProvider.buildServer(serverPath, BufferedImage.class);</b>
<b class="nc"><i>3199</i>&nbsp;			} catch (IOException e) {</b>
<b class="nc"><i>3200</i>&nbsp;				logger.error(&quot;Unable to open server path &quot; + serverPath, e);</b>
<b class="nc"><i>3201</i>&nbsp;			}</b>
<b class="nc"><i>3202</i>&nbsp;			if (server == null) {</b>
<i>3203</i>&nbsp;//				boolean pathValid = new File(serverPath).isFile() || URLHelpers.checkURL(serverPath);
<i>3204</i>&nbsp;//				if (!pathValid) {
<b class="nc"><i>3205</i>&nbsp;					serverPath = Dialogs.promptForFilePathOrURL(&quot;Set path to missing file&quot;, serverPath, new File(serverPath).getParentFile(), null);</b>
<b class="nc"><i>3206</i>&nbsp;					if (serverPath == null)</b>
<b class="nc"><i>3207</i>&nbsp;						return false;</b>
<b class="nc"><i>3208</i>&nbsp;					server = ImageServerProvider.buildServer(serverPath, BufferedImage.class);</b>
<b class="nc"><i>3209</i>&nbsp;					if (server == null)</b>
<b class="nc"><i>3210</i>&nbsp;						return false;</b>
<i>3211</i>&nbsp;//				}
<i>3212</i>&nbsp;			}
<i>3213</i>&nbsp;			
<i>3214</i>&nbsp;			// Small optimization... put in a thumbnail request early in a background thread.
<i>3215</i>&nbsp;			// This way that it will be fetched while the image data is being read -
<i>3216</i>&nbsp;			// generally leading to improved performance in the viewer&#39;s setImageData method
<i>3217</i>&nbsp;			// (specifically the updating of the ImageDisplay, which needs a thumbnail)
<b class="nc"><i>3218</i>&nbsp;			final ImageServer&lt;BufferedImage&gt; serverTemp = server;</b>
<b class="nc"><i>3219</i>&nbsp;			poolMultipleThreads.submit(() -&gt; {</b>
<b class="nc"><i>3220</i>&nbsp;					imageRegionStore.getThumbnail(serverTemp, 0, 0, true);</b>
<b class="nc"><i>3221</i>&nbsp;			});</b>
<i>3222</i>&nbsp;		}
<i>3223</i>&nbsp;		
<i>3224</i>&nbsp;		
<b class="nc"><i>3225</i>&nbsp;		if (promptToSaveChanges &amp;&amp; imageData != null &amp;&amp; imageData.isChanged()) {</b>
<b class="nc"><i>3226</i>&nbsp;			if (!promptToSaveChangesOrCancel(&quot;Save changes&quot;, imageData))</b>
<b class="nc"><i>3227</i>&nbsp;				return false;</b>
<i>3228</i>&nbsp;		}
<i>3229</i>&nbsp;		
<i>3230</i>&nbsp;		try {
<b class="nc"><i>3231</i>&nbsp;			ImageData&lt;BufferedImage&gt; imageData2 = PathIO.readImageData(file, imageData, server, BufferedImage.class);</b>
<b class="nc"><i>3232</i>&nbsp;			if (imageData2 != imageData) {</b>
<b class="nc"><i>3233</i>&nbsp;				viewer.setImageData(imageData2);</b>
<i>3234</i>&nbsp;			}
<b class="nc"><i>3235</i>&nbsp;		} catch (IOException e) {</b>
<b class="nc"><i>3236</i>&nbsp;			Dialogs.showErrorMessage(&quot;Read image data&quot;, e);</b>
<b class="nc"><i>3237</i>&nbsp;		}</b>
<i>3238</i>&nbsp;		
<b class="nc"><i>3239</i>&nbsp;		return true;</b>
<i>3240</i>&nbsp;	}
<i>3241</i>&nbsp;	
<i>3242</i>&nbsp;	
<i>3243</i>&nbsp;	/**
<i>3244</i>&nbsp;	 * Get a reference to the {@link PreferencePane}.
<i>3245</i>&nbsp;	 * 
<i>3246</i>&nbsp;	 * This can be used by extensions to add in their own preferences.
<i>3247</i>&nbsp;	 * 
<i>3248</i>&nbsp;	 * @return
<i>3249</i>&nbsp;	 */
<i>3250</i>&nbsp;	public PreferencePane getPreferencePane() {
<b class="fc"><i>3251</i>&nbsp;		return prefsPane;</b>
<i>3252</i>&nbsp;	}
<i>3253</i>&nbsp;	
<i>3254</i>&nbsp;	
<i>3255</i>&nbsp;	/**
<i>3256</i>&nbsp;	 * Add menus to a MenuBar.
<i>3257</i>&nbsp;	 * 
<i>3258</i>&nbsp;	 * @param menuBar
<i>3259</i>&nbsp;	 * @param menus
<i>3260</i>&nbsp;	 * @return
<i>3261</i>&nbsp;	 */
<i>3262</i>&nbsp;	static MenuBar addToMenuBar(final MenuBar menuBar, final Menu... menus) {
<b class="nc"><i>3263</i>&nbsp;		menuBar.getMenus().addAll(menus);</b>
<b class="nc"><i>3264</i>&nbsp;		return menuBar;</b>
<i>3265</i>&nbsp;	}
<i>3266</i>&nbsp;	
<i>3267</i>&nbsp;	
<i>3268</i>&nbsp;	
<i>3269</i>&nbsp;	
<i>3270</i>&nbsp;	/**
<i>3271</i>&nbsp;	 * Create an executor using a single thread.
<i>3272</i>&nbsp;	 * &lt;p&gt;
<i>3273</i>&nbsp;	 * Optionally specify an owner, in which case the same Executor will be returned for the owner 
<i>3274</i>&nbsp;	 * for so long as the Executor has not been shut down; if it has been shut down, a new Executor will be returned.
<i>3275</i>&nbsp;	 * &lt;p&gt;
<i>3276</i>&nbsp;	 * Specifying an owner is a good idea if there is a chance that any submitted tasks could block,
<i>3277</i>&nbsp;	 * since the same Executor will be returned for all requests that give a null owner.
<i>3278</i>&nbsp;	 * &lt;p&gt;
<i>3279</i>&nbsp;	 * The advantage of using this over creating an ExecutorService some other way is that
<i>3280</i>&nbsp;	 * shutdown will be called on any pools created this way whenever QuPath is quit.
<i>3281</i>&nbsp;	 * 
<i>3282</i>&nbsp;	 * @param owner
<i>3283</i>&nbsp;	 * @return 
<i>3284</i>&nbsp;	 * 
<i>3285</i>&nbsp;	 */
<i>3286</i>&nbsp;	public ExecutorService createSingleThreadExecutor(final Object owner) {
<b class="nc"><i>3287</i>&nbsp;		ExecutorService pool = mapSingleThreadPools.get(owner);</b>
<b class="nc"><i>3288</i>&nbsp;		if (pool == null || pool.isShutdown()) {</b>
<b class="nc"><i>3289</i>&nbsp;			pool = Executors.newSingleThreadExecutor(ThreadTools.createThreadFactory(owner.getClass().getSimpleName().toLowerCase() + &quot;-&quot;, false));</b>
<b class="nc"><i>3290</i>&nbsp;			mapSingleThreadPools.put(owner, pool);</b>
<i>3291</i>&nbsp;		}
<b class="nc"><i>3292</i>&nbsp;		return pool;</b>
<i>3293</i>&nbsp;	}
<i>3294</i>&nbsp;	
<i>3295</i>&nbsp;	/**
<i>3296</i>&nbsp;	 * Create a completion service that uses a shared threadpool for the application.
<i>3297</i>&nbsp;	 * @param &lt;V&gt; 
<i>3298</i>&nbsp;	 * 
<i>3299</i>&nbsp;	 * @param cls
<i>3300</i>&nbsp;	 * @return 
<i>3301</i>&nbsp;	 */
<i>3302</i>&nbsp;	public &lt;V&gt; ExecutorCompletionService&lt;V&gt; createSharedPoolCompletionService(Class&lt;V&gt; cls) {
<b class="nc"><i>3303</i>&nbsp;		return new ExecutorCompletionService&lt;V&gt;(poolMultipleThreads);</b>
<i>3304</i>&nbsp;	}
<i>3305</i>&nbsp;	
<i>3306</i>&nbsp;	/**
<i>3307</i>&nbsp;	 * Submit a short task to a shared thread pool
<i>3308</i>&nbsp;	 * 
<i>3309</i>&nbsp;	 * @param runnable
<i>3310</i>&nbsp;	 */
<i>3311</i>&nbsp;	public void submitShortTask(final Runnable runnable) {
<b class="nc"><i>3312</i>&nbsp;		poolMultipleThreads.submit(runnable);</b>
<b class="nc"><i>3313</i>&nbsp;	}</b>
<i>3314</i>&nbsp;	
<i>3315</i>&nbsp;	
<i>3316</i>&nbsp;	private Menu createRecentProjectsMenu() {
<i>3317</i>&nbsp;		
<i>3318</i>&nbsp;		// Create a recent projects list in the File menu
<b class="fc"><i>3319</i>&nbsp;		ObservableList&lt;URI&gt; recentProjects = PathPrefs.getRecentProjectList();</b>
<b class="fc"><i>3320</i>&nbsp;		Menu menuRecent = MenuTools.createMenu(&quot;Recent projects...&quot;);</b>
<i>3321</i>&nbsp;		
<b class="fc"><i>3322</i>&nbsp;		EventHandler&lt;Event&gt; validationHandler = e -&gt; {</b>
<b class="fc"><i>3323</i>&nbsp;			menuRecent.getItems().clear();</b>
<b class="fc"><i>3324</i>&nbsp;			for (URI uri : recentProjects) {</b>
<b class="nc"><i>3325</i>&nbsp;				if (uri == null)</b>
<b class="nc"><i>3326</i>&nbsp;					continue;</b>
<b class="nc"><i>3327</i>&nbsp;				String name = Project.getNameFromURI(uri);</b>
<b class="nc"><i>3328</i>&nbsp;				name = &quot;.../&quot; + name;</b>
<b class="nc"><i>3329</i>&nbsp;				MenuItem item = new MenuItem(name);</b>
<b class="nc"><i>3330</i>&nbsp;				item.setOnAction(e2 -&gt; {</b>
<i>3331</i>&nbsp;					Project&lt;BufferedImage&gt; project;
<i>3332</i>&nbsp;					try {
<b class="nc"><i>3333</i>&nbsp;						project = ProjectIO.loadProject(uri, BufferedImage.class);</b>
<b class="nc"><i>3334</i>&nbsp;						setProject(project);</b>
<b class="nc"><i>3335</i>&nbsp;					} catch (Exception e1) {</b>
<b class="nc"><i>3336</i>&nbsp;						Dialogs.showErrorMessage(&quot;Project error&quot;, &quot;Cannot find project &quot; + uri);</b>
<b class="nc"><i>3337</i>&nbsp;						logger.error(&quot;Error loading project&quot;, e1);</b>
<b class="nc"><i>3338</i>&nbsp;					}</b>
<b class="nc"><i>3339</i>&nbsp;				});</b>
<b class="nc"><i>3340</i>&nbsp;				menuRecent.getItems().add(item);</b>
<b class="nc"><i>3341</i>&nbsp;			}</b>
<b class="fc"><i>3342</i>&nbsp;		};</b>
<i>3343</i>&nbsp;		
<i>3344</i>&nbsp;		// Ensure the menu is populated
<b class="fc"><i>3345</i>&nbsp;		menuRecent.parentMenuProperty().addListener((v, o, n) -&gt; {</b>
<b class="fc"><i>3346</i>&nbsp;			if (o != null &amp;&amp; o.getOnMenuValidation() == validationHandler)</b>
<b class="nc"><i>3347</i>&nbsp;				o.setOnMenuValidation(null);</b>
<b class="fc"><i>3348</i>&nbsp;			if (n != null)</b>
<b class="fc"><i>3349</i>&nbsp;				n.setOnMenuValidation(validationHandler);</b>
<b class="fc"><i>3350</i>&nbsp;		});</b>
<i>3351</i>&nbsp;		
<b class="fc"><i>3352</i>&nbsp;		return menuRecent;</b>
<i>3353</i>&nbsp;	}
<i>3354</i>&nbsp;	
<i>3355</i>&nbsp;	
<i>3356</i>&nbsp;	
<i>3357</i>&nbsp;	/**
<i>3358</i>&nbsp;	 * Create an action for a plugin to be run through this QuPath instance.
<i>3359</i>&nbsp;	 * @param name name of the plugin
<i>3360</i>&nbsp;	 * @param pluginClass class of the plugin
<i>3361</i>&nbsp;	 * @param arg optional argument (may be required by some plugins)
<i>3362</i>&nbsp;	 * @return
<i>3363</i>&nbsp;	 */
<i>3364</i>&nbsp;	public Action createPluginAction(final String name, final Class&lt;? extends PathPlugin&gt; pluginClass, final String arg) {
<b class="fc"><i>3365</i>&nbsp;		return createPluginAction(name, pluginClass, this, arg);</b>
<i>3366</i>&nbsp;	}
<i>3367</i>&nbsp;
<i>3368</i>&nbsp;	
<i>3369</i>&nbsp;	/**
<i>3370</i>&nbsp;	 * Create an Action to call the specified plugin for the current image.
<i>3371</i>&nbsp;	 * @param name plugin name
<i>3372</i>&nbsp;	 * @param plugin the plugin to call
<i>3373</i>&nbsp;	 * @param arg any argument required by the plugin
<i>3374</i>&nbsp;	 * @return an action that may be called to run the plugin
<i>3375</i>&nbsp;	 */
<i>3376</i>&nbsp;	public Action createPluginAction(final String name, final PathPlugin&lt;BufferedImage&gt; plugin, final String arg) {
<b class="fc"><i>3377</i>&nbsp;		var action = new Action(name, event -&gt; {</b>
<i>3378</i>&nbsp;			try {
<b class="nc"><i>3379</i>&nbsp;				if (plugin instanceof PathInteractivePlugin) {</b>
<b class="nc"><i>3380</i>&nbsp;					var imageData = getImageData();</b>
<b class="nc"><i>3381</i>&nbsp;					if (imageData == null) {</b>
<b class="nc"><i>3382</i>&nbsp;						Dialogs.showNoImageError(name);</b>
<b class="nc"><i>3383</i>&nbsp;						return;</b>
<i>3384</i>&nbsp;					}
<b class="nc"><i>3385</i>&nbsp;					PathInteractivePlugin&lt;BufferedImage&gt; pluginInteractive = (PathInteractivePlugin&lt;BufferedImage&gt;)plugin;</b>
<b class="nc"><i>3386</i>&nbsp;					ParameterDialogWrapper&lt;BufferedImage&gt; dialog = new ParameterDialogWrapper&lt;&gt;(pluginInteractive, pluginInteractive.getDefaultParameterList(imageData), new PluginRunnerFX(this));</b>
<b class="nc"><i>3387</i>&nbsp;					dialog.showDialog();</b>
<i>3388</i>&nbsp;//					((PathInteractivePlugin&lt;BufferedImage&gt;)plugin).runInteractive(new PluginRunnerFX(this, false), arg);
<b class="nc"><i>3389</i>&nbsp;				}</b>
<i>3390</i>&nbsp;				else
<b class="nc"><i>3391</i>&nbsp;					((PathPlugin&lt;BufferedImage&gt;)plugin).runPlugin(new PluginRunnerFX(this), arg);</b>
<i>3392</i>&nbsp;
<b class="nc"><i>3393</i>&nbsp;			} catch (Exception e) {</b>
<b class="nc"><i>3394</i>&nbsp;				Dialogs.showErrorMessage(&quot;Error&quot;, &quot;Error running &quot; + plugin.getName());</b>
<b class="nc"><i>3395</i>&nbsp;			}</b>
<b class="nc"><i>3396</i>&nbsp;		});</b>
<i>3397</i>&nbsp;		// We assume that plugins require image data
<b class="fc"><i>3398</i>&nbsp;		action.disabledProperty().bind(noImageData);</b>
<b class="fc"><i>3399</i>&nbsp;		return action;</b>
<i>3400</i>&nbsp;	}
<i>3401</i>&nbsp;	
<i>3402</i>&nbsp;	
<i>3403</i>&nbsp;	/**
<i>3404</i>&nbsp;	 * Request to quit QuPath.
<i>3405</i>&nbsp;	 */
<i>3406</i>&nbsp;	void tryToQuit() {
<b class="nc"><i>3407</i>&nbsp;		var stage = getStage();</b>
<b class="nc"><i>3408</i>&nbsp;		if (stage == null || !stage.isShowing())</b>
<b class="nc"><i>3409</i>&nbsp;			return;</b>
<b class="nc"><i>3410</i>&nbsp;		stage.fireEvent(</b>
<i>3411</i>&nbsp;				new WindowEvent(
<i>3412</i>&nbsp;				        stage,
<i>3413</i>&nbsp;				        WindowEvent.WINDOW_CLOSE_REQUEST
<i>3414</i>&nbsp;				    )
<i>3415</i>&nbsp;				);
<b class="nc"><i>3416</i>&nbsp;	}</b>
<i>3417</i>&nbsp;	
<i>3418</i>&nbsp;	
<i>3419</i>&nbsp;	/**
<i>3420</i>&nbsp;	 * Create an Action to construct and run a plugin interactively.
<i>3421</i>&nbsp;	 * 
<i>3422</i>&nbsp;	 * @param name
<i>3423</i>&nbsp;	 * @param pluginClass
<i>3424</i>&nbsp;	 * @param qupath
<i>3425</i>&nbsp;	 * @param arg
<i>3426</i>&nbsp;	 * @return
<i>3427</i>&nbsp;	 */
<i>3428</i>&nbsp;	private static Action createPluginAction(final String name, final Class&lt;? extends PathPlugin&gt; pluginClass, final QuPathGUI qupath, final String arg) {
<i>3429</i>&nbsp;		try {
<b class="fc"><i>3430</i>&nbsp;			var action = new Action(name, event -&gt; {</b>
<b class="nc"><i>3431</i>&nbsp;				PathPlugin&lt;BufferedImage&gt; plugin = qupath.createPlugin(pluginClass);</b>
<b class="nc"><i>3432</i>&nbsp;				qupath.runPlugin(plugin, arg, true);</b>
<b class="nc"><i>3433</i>&nbsp;			});</b>
<b class="fc"><i>3434</i>&nbsp;			action.disabledProperty().bind(qupath.noImageData);</b>
<b class="fc"><i>3435</i>&nbsp;			ActionTools.parseAnnotations(action, pluginClass);</b>
<b class="fc"><i>3436</i>&nbsp;			return action;</b>
<b class="nc"><i>3437</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>3438</i>&nbsp;			logger.error(&quot;Unable to initialize class &quot; + pluginClass, e);</b>
<i>3439</i>&nbsp;		}
<b class="nc"><i>3440</i>&nbsp;		return null;</b>
<i>3441</i>&nbsp;	}
<i>3442</i>&nbsp;	
<i>3443</i>&nbsp;	
<i>3444</i>&nbsp;	/**
<i>3445</i>&nbsp;	 * Run a plugin, interactively (i.e. launching a dialog) if necessary.
<i>3446</i>&nbsp;	 * 
<i>3447</i>&nbsp;	 * @param plugin
<i>3448</i>&nbsp;	 * @param arg
<i>3449</i>&nbsp;	 * @param doInteractive
<i>3450</i>&nbsp;	 */
<i>3451</i>&nbsp;	public void runPlugin(final PathPlugin&lt;BufferedImage&gt; plugin, final String arg, final boolean doInteractive) {
<i>3452</i>&nbsp;		try {
<i>3453</i>&nbsp;			// TODO: Check safety...
<b class="nc"><i>3454</i>&nbsp;			if (doInteractive &amp;&amp; plugin instanceof PathInteractivePlugin) {</b>
<b class="nc"><i>3455</i>&nbsp;				PathInteractivePlugin&lt;BufferedImage&gt; pluginInteractive = (PathInteractivePlugin&lt;BufferedImage&gt;)plugin;</b>
<b class="nc"><i>3456</i>&nbsp;				ParameterList params = pluginInteractive.getDefaultParameterList(getImageData());</b>
<i>3457</i>&nbsp;				// Update parameter list, if necessary
<b class="nc"><i>3458</i>&nbsp;				if (arg != null) {</b>
<b class="nc"><i>3459</i>&nbsp;					Map&lt;String, String&gt; map = GeneralTools.parseArgStringValues(arg);</b>
<i>3460</i>&nbsp;					// We use the US locale because we need to ensure decimal points (not commas)
<b class="nc"><i>3461</i>&nbsp;					ParameterList.updateParameterList(params, map, Locale.US);</b>
<i>3462</i>&nbsp;				}
<b class="nc"><i>3463</i>&nbsp;				ParameterDialogWrapper&lt;BufferedImage&gt; dialog = new ParameterDialogWrapper&lt;&gt;(pluginInteractive, params, new PluginRunnerFX(this));</b>
<b class="nc"><i>3464</i>&nbsp;				dialog.showDialog();</b>
<b class="nc"><i>3465</i>&nbsp;			}</b>
<i>3466</i>&nbsp;			else
<b class="nc"><i>3467</i>&nbsp;				plugin.runPlugin(new PluginRunnerFX(this), arg);</b>
<i>3468</i>&nbsp;
<b class="nc"><i>3469</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>3470</i>&nbsp;			logger.error(&quot;Unable to run plugin &quot; + plugin, e);</b>
<b class="nc"><i>3471</i>&nbsp;		}</b>
<b class="nc"><i>3472</i>&nbsp;	}</b>
<i>3473</i>&nbsp;	
<i>3474</i>&nbsp;	/**
<i>3475</i>&nbsp;	 * Create a plugin from a specified class.
<i>3476</i>&nbsp;	 * 
<i>3477</i>&nbsp;	 * @param pluginClass
<i>3478</i>&nbsp;	 * @return
<i>3479</i>&nbsp;	 */
<i>3480</i>&nbsp;	@SuppressWarnings(&quot;unchecked&quot;)
<i>3481</i>&nbsp;	public PathPlugin&lt;BufferedImage&gt; createPlugin(final Class&lt;? extends PathPlugin&gt; pluginClass) {
<b class="nc"><i>3482</i>&nbsp;		PathPlugin&lt;BufferedImage&gt; plugin = null;</b>
<i>3483</i>&nbsp;		try {
<b class="nc"><i>3484</i>&nbsp;			plugin = pluginClass.getConstructor().newInstance();</b>
<b class="nc"><i>3485</i>&nbsp;		} catch (Exception e1) {</b>
<b class="nc"><i>3486</i>&nbsp;			logger.error(&quot;Unable to construct plugin {}&quot;, pluginClass, e1);</b>
<b class="nc"><i>3487</i>&nbsp;		}</b>
<b class="nc"><i>3488</i>&nbsp;		return plugin;</b>
<i>3489</i>&nbsp;	}
<i>3490</i>&nbsp;	
<i>3491</i>&nbsp;
<i>3492</i>&nbsp;	/**
<i>3493</i>&nbsp;	 * Get the action that corresponds to a specific {@link PathTool}, creating a new action if one does not already exist.
<i>3494</i>&nbsp;	 * @param tool
<i>3495</i>&nbsp;	 * @return
<i>3496</i>&nbsp;	 */
<i>3497</i>&nbsp;	public Action getToolAction(PathTool tool) {
<b class="fc"><i>3498</i>&nbsp;		var action = toolActions.get(tool);</b>
<b class="fc"><i>3499</i>&nbsp;		if (action == null) {</b>
<b class="fc"><i>3500</i>&nbsp;			action = createToolAction(tool);</b>
<b class="fc"><i>3501</i>&nbsp;			toolActions.put(tool, action);</b>
<i>3502</i>&nbsp;		}
<i>3503</i>&nbsp;		// Make sure the accelerator is registered
<b class="fc"><i>3504</i>&nbsp;		registerAccelerator(action);</b>
<b class="fc"><i>3505</i>&nbsp;		return action;</b>
<i>3506</i>&nbsp;	}
<i>3507</i>&nbsp;	
<i>3508</i>&nbsp;	private Action createToolAction(final PathTool tool) {
<b class="fc"><i>3509</i>&nbsp;		  var action = createSelectableCommandAction(new SelectableItem&lt;&gt;(selectedToolProperty, tool), tool.getName(), tool.getIcon(), null);</b>
<b class="fc"><i>3510</i>&nbsp;		  action.disabledProperty().bind(Bindings.createBooleanBinding(() -&gt; !tools.contains(tool) || selectedToolLocked.get(), selectedToolLocked, tools));</b>
<b class="fc"><i>3511</i>&nbsp;		  registerAccelerator(action);</b>
<b class="fc"><i>3512</i>&nbsp;		  return action;</b>
<i>3513</i>&nbsp;	}
<i>3514</i>&nbsp;
<i>3515</i>&nbsp;	private static &lt;T&gt; Action createSelectableCommandAction(final SelectableItem&lt;T&gt; command, final String name, final Node icon, final KeyCombination accelerator) {
<b class="fc"><i>3516</i>&nbsp;		var action = ActionTools.actionBuilder(e -&gt; command.setSelected(true))</b>
<b class="fc"><i>3517</i>&nbsp;				.text(name)</b>
<b class="fc"><i>3518</i>&nbsp;				.accelerator(accelerator)</b>
<b class="fc"><i>3519</i>&nbsp;				.selectable(true)</b>
<b class="fc"><i>3520</i>&nbsp;				.selected(command.selectedProperty())</b>
<b class="fc"><i>3521</i>&nbsp;				.graphic(icon)</b>
<b class="fc"><i>3522</i>&nbsp;				.build();</b>
<b class="fc"><i>3523</i>&nbsp;		return action;</b>
<i>3524</i>&nbsp;	}
<i>3525</i>&nbsp;	
<i>3526</i>&nbsp;	private static &lt;T&gt; Action createSelectableCommandAction(final SelectableItem&lt;T&gt; command, final String name) {
<b class="fc"><i>3527</i>&nbsp;		return createSelectableCommandAction(command, name, null, null);</b>
<i>3528</i>&nbsp;	}
<i>3529</i>&nbsp;
<i>3530</i>&nbsp;	/**
<i>3531</i>&nbsp;	 * Register the accelerator so we can still trigger the event if it is not otherwise called (e.g. if it doesn&#39;t require a 
<i>3532</i>&nbsp;	 * shortcut key, and macOS drops it).
<i>3533</i>&nbsp;	 * @param action the action to register; nothing will be done if it has no accelerator set
<i>3534</i>&nbsp;	 * @return the same action as provided as a parameter
<i>3535</i>&nbsp;	 */
<i>3536</i>&nbsp;	private Action registerAccelerator(Action action) {
<b class="fc"><i>3537</i>&nbsp;		var accelerator = action.getAccelerator();</b>
<b class="fc"><i>3538</i>&nbsp;		if (accelerator == null)</b>
<b class="fc"><i>3539</i>&nbsp;			return action;</b>
<b class="fc"><i>3540</i>&nbsp;		var previous = comboMap.put(accelerator, action);</b>
<b class="fc"><i>3541</i>&nbsp;		if (previous != null &amp;&amp; previous != action)</b>
<b class="nc"><i>3542</i>&nbsp;			logger.warn(&quot;Multiple actions registered for {}, will keep {} and drop {}&quot;, accelerator, action.getText(), previous.getText());</b>
<b class="fc"><i>3543</i>&nbsp;		return action;</b>
<i>3544</i>&nbsp;	}
<i>3545</i>&nbsp;	
<i>3546</i>&nbsp;	/**
<i>3547</i>&nbsp;	 * Get the main toolbar.
<i>3548</i>&nbsp;	 * @return
<i>3549</i>&nbsp;	 */
<i>3550</i>&nbsp;	public ToolBar getToolBar() {
<b class="fc"><i>3551</i>&nbsp;		return toolbar.getToolBar();</b>
<i>3552</i>&nbsp;	}
<i>3553</i>&nbsp;	
<i>3554</i>&nbsp;	
<i>3555</i>&nbsp;	/**
<i>3556</i>&nbsp;	 * Get the {@link UndoRedoManager}, which can be useful if needing to clear it in cases where available memory is low.
<i>3557</i>&nbsp;	 * @return
<i>3558</i>&nbsp;	 */
<i>3559</i>&nbsp;	public UndoRedoManager getUndoRedoManager() {
<b class="fc"><i>3560</i>&nbsp;		return undoRedoManager;</b>
<i>3561</i>&nbsp;	}
<i>3562</i>&nbsp;	
<i>3563</i>&nbsp;	/**
<i>3564</i>&nbsp;	 * Toggle whether the user is permitted to switch to a new active {@link PathTool}.
<i>3565</i>&nbsp;	 * This can be used to lock a tool temporarily.
<i>3566</i>&nbsp;	 * @param enabled
<i>3567</i>&nbsp;	 */
<i>3568</i>&nbsp;	public void setToolSwitchingEnabled(final boolean enabled) {
<b class="nc"><i>3569</i>&nbsp;		selectedToolLocked.set(!enabled);</b>
<b class="nc"><i>3570</i>&nbsp;	}</b>
<i>3571</i>&nbsp;	
<i>3572</i>&nbsp;	/**
<i>3573</i>&nbsp;	 * Returns true if the user is able to activate another {@link PathTool}, false otherwise.
<i>3574</i>&nbsp;	 * @return
<i>3575</i>&nbsp;	 */
<i>3576</i>&nbsp;	public boolean isToolSwitchingEnabled() {
<b class="fc"><i>3577</i>&nbsp;		return !selectedToolLocked.get();</b>
<i>3578</i>&nbsp;	}
<i>3579</i>&nbsp;	
<i>3580</i>&nbsp;	
<i>3581</i>&nbsp;	/**
<i>3582</i>&nbsp;	 * Get a list of the current available tools.
<i>3583</i>&nbsp;	 * Tools may be removed from this list, but {@link #installTool(PathTool, KeyCodeCombination)} is the preferred way 
<i>3584</i>&nbsp;	 * to add a new tool, to ensure that any accelerator is properly managed.
<i>3585</i>&nbsp;	 * @return
<i>3586</i>&nbsp;	 */
<i>3587</i>&nbsp;	public ObservableList&lt;PathTool&gt; getAvailableTools() {
<b class="fc"><i>3588</i>&nbsp;		return tools;</b>
<i>3589</i>&nbsp;	}
<i>3590</i>&nbsp;	
<i>3591</i>&nbsp;	/**
<i>3592</i>&nbsp;	 * Install a new tool for interacting with viewers.
<i>3593</i>&nbsp;	 * @param tool the tool to add
<i>3594</i>&nbsp;	 * @param accelerator an optional accelerator (may be null)
<i>3595</i>&nbsp;	 * @return true if the tool was added, false otherwise (e.g. if the tool had already been added)
<i>3596</i>&nbsp;	 */
<i>3597</i>&nbsp;	public boolean installTool(PathTool tool, KeyCodeCombination accelerator) {
<b class="fc"><i>3598</i>&nbsp;		if (tool == null || tools.contains(tool))</b>
<b class="nc"><i>3599</i>&nbsp;			return false;</b>
<i>3600</i>&nbsp;		// Keep the points tool last
<b class="fc"><i>3601</i>&nbsp;		if (accelerator != null) {</b>
<b class="fc"><i>3602</i>&nbsp;			var action = getToolAction(tool);</b>
<b class="fc"><i>3603</i>&nbsp;			if (accelerator != null) {</b>
<b class="fc"><i>3604</i>&nbsp;				action.setAccelerator(accelerator);</b>
<b class="fc"><i>3605</i>&nbsp;				registerAccelerator(action);</b>
<i>3606</i>&nbsp;			}
<i>3607</i>&nbsp;		}
<b class="fc"><i>3608</i>&nbsp;		int ind = tools.indexOf(PathTools.POINTS);</b>
<b class="fc"><i>3609</i>&nbsp;		if (ind &lt; 0)</b>
<b class="nc"><i>3610</i>&nbsp;			tools.add(tool);</b>
<i>3611</i>&nbsp;		else
<b class="fc"><i>3612</i>&nbsp;			tools.add(ind, tool);</b>
<b class="fc"><i>3613</i>&nbsp;		return true;</b>
<i>3614</i>&nbsp;	}
<i>3615</i>&nbsp;	
<i>3616</i>&nbsp;	/**
<i>3617</i>&nbsp;	 * Programmatically select the active {@link PathTool}.
<i>3618</i>&nbsp;	 * This may fail if {@link #isToolSwitchingEnabled()} returns false.
<i>3619</i>&nbsp;	 * @param tool
<i>3620</i>&nbsp;	 */
<i>3621</i>&nbsp;	public void setSelectedTool(PathTool tool) {
<b class="fc"><i>3622</i>&nbsp;		if (!Platform.isFxApplicationThread()) {</b>
<b class="nc"><i>3623</i>&nbsp;			Platform.runLater(() -&gt; setSelectedTool(tool));</b>
<b class="nc"><i>3624</i>&nbsp;			return;</b>
<i>3625</i>&nbsp;		}
<b class="fc"><i>3626</i>&nbsp;		if (!isToolSwitchingEnabled()) {</b>
<b class="nc"><i>3627</i>&nbsp;			logger.warn(&quot;Mode switching currently disabled - cannot change to {}&quot;, tool);</b>
<b class="nc"><i>3628</i>&nbsp;			return;</b>
<i>3629</i>&nbsp;		}
<b class="fc"><i>3630</i>&nbsp;		this.selectedToolProperty.set(tool);</b>
<b class="fc"><i>3631</i>&nbsp;	}</b>
<i>3632</i>&nbsp;	
<i>3633</i>&nbsp;	
<i>3634</i>&nbsp;	/**
<i>3635</i>&nbsp;	 * Request that a specified Jar file be added to the extension classpath.
<i>3636</i>&nbsp;	 * &lt;p&gt;
<i>3637</i>&nbsp;	 * Note: This is really intended for dependencies that should remain where they are 
<i>3638</i>&nbsp;	 * on disk (e.g. because they are included in other applications).
<i>3639</i>&nbsp;	 * &lt;p&gt;
<i>3640</i>&nbsp;	 * Jars containing QuPath extensions should be copied directly into the extensions 
<i>3641</i>&nbsp;	 * directory instead.
<i>3642</i>&nbsp;	 * 
<i>3643</i>&nbsp;	 * @param file
<i>3644</i>&nbsp;	 * @return
<i>3645</i>&nbsp;	 */
<i>3646</i>&nbsp;	public boolean addExtensionJar(final File file) {
<b class="nc"><i>3647</i>&nbsp;		return extensionClassLoader.addJAR(file);</b>
<i>3648</i>&nbsp;	}
<i>3649</i>&nbsp;	
<i>3650</i>&nbsp;	
<i>3651</i>&nbsp;	
<i>3652</i>&nbsp;	/**
<i>3653</i>&nbsp;	 * Set the cursor for all the viewers.
<i>3654</i>&nbsp;	 */
<i>3655</i>&nbsp;	void updateCursor() {
<b class="fc"><i>3656</i>&nbsp;		if (stage == null || stage.getScene() == null)</b>
<b class="nc"><i>3657</i>&nbsp;			return;</b>
<b class="fc"><i>3658</i>&nbsp;		var mode = getSelectedTool();</b>
<b class="fc"><i>3659</i>&nbsp;		if (mode == PathTools.MOVE)</b>
<b class="fc"><i>3660</i>&nbsp;			updateCursor(Cursor.HAND);</b>
<i>3661</i>&nbsp;		else
<b class="nc"><i>3662</i>&nbsp;			updateCursor(Cursor.DEFAULT);</b>
<b class="fc"><i>3663</i>&nbsp;	}</b>
<i>3664</i>&nbsp;	
<i>3665</i>&nbsp;	/**
<i>3666</i>&nbsp;	 * Set the cursor for all the viewers.
<i>3667</i>&nbsp;	 * 
<i>3668</i>&nbsp;	 * @param cursor
<i>3669</i>&nbsp;	 */
<i>3670</i>&nbsp;	void updateCursor(final Cursor cursor) {
<b class="fc"><i>3671</i>&nbsp;		for (QuPathViewer viewer : getViewers())</b>
<b class="fc"><i>3672</i>&nbsp;			viewer.getView().setCursor(cursor);</b>
<b class="fc"><i>3673</i>&nbsp;	}</b>
<i>3674</i>&nbsp;
<i>3675</i>&nbsp;	
<i>3676</i>&nbsp;	/**
<i>3677</i>&nbsp;	 * Get a reference to the current {@link ScriptEditor} (which may or may not be open at the moment).
<i>3678</i>&nbsp;	 * 
<i>3679</i>&nbsp;	 * @return
<i>3680</i>&nbsp;	 */
<i>3681</i>&nbsp;	public ScriptEditor getScriptEditor() {
<b class="fc"><i>3682</i>&nbsp;		if (scriptEditor == null) {</b>
<b class="nc"><i>3683</i>&nbsp;			setScriptEditor(new DefaultScriptEditor(this));</b>
<i>3684</i>&nbsp;		}
<b class="fc"><i>3685</i>&nbsp;		return scriptEditor;</b>
<i>3686</i>&nbsp;	}
<i>3687</i>&nbsp;	
<i>3688</i>&nbsp;	
<i>3689</i>&nbsp;	/**
<i>3690</i>&nbsp;	 * Set a new ScriptEditor, which will be used from now on.
<i>3691</i>&nbsp;	 * 
<i>3692</i>&nbsp;	 * @param scriptEditor
<i>3693</i>&nbsp;	 */
<i>3694</i>&nbsp;	public void setScriptEditor(final ScriptEditor scriptEditor) {
<b class="fc"><i>3695</i>&nbsp;		this.scriptEditor = scriptEditor;</b>
<i>3696</i>&nbsp;		// Try to bind to whether a script is running or not
<b class="fc"><i>3697</i>&nbsp;		scriptRunning.unbind();</b>
<b class="fc"><i>3698</i>&nbsp;		if (scriptEditor instanceof DefaultScriptEditor)</b>
<b class="fc"><i>3699</i>&nbsp;			scriptRunning.bind(((DefaultScriptEditor)scriptEditor).scriptRunning());</b>
<i>3700</i>&nbsp;		else
<b class="nc"><i>3701</i>&nbsp;			scriptRunning.set(false);</b>
<b class="fc"><i>3702</i>&nbsp;	}</b>
<i>3703</i>&nbsp;	
<i>3704</i>&nbsp;	
<i>3705</i>&nbsp;	
<i>3706</i>&nbsp;	/**
<i>3707</i>&nbsp;	 * Repaint the viewer.  In the future, if multiple viewers are registered with the GUI 
<i>3708</i>&nbsp;	 * (not yet possible) then this may result in all being repainted.
<i>3709</i>&nbsp;	 */
<i>3710</i>&nbsp;	public void repaintViewers() {
<b class="nc"><i>3711</i>&nbsp;		viewerManager.repaintViewers();</b>
<b class="nc"><i>3712</i>&nbsp;	}</b>
<i>3713</i>&nbsp;	
<i>3714</i>&nbsp;	/**
<i>3715</i>&nbsp;	 * Get the value of {@link #selectedToolProperty()}.
<i>3716</i>&nbsp;	 * @return
<i>3717</i>&nbsp;	 */
<i>3718</i>&nbsp;	public PathTool getSelectedTool() {
<b class="fc"><i>3719</i>&nbsp;		return selectedToolProperty().get();</b>
<i>3720</i>&nbsp;	}
<i>3721</i>&nbsp;	
<i>3722</i>&nbsp;	/**
<i>3723</i>&nbsp;	 * Property containing the currently-selected {@link PathTool}.
<i>3724</i>&nbsp;	 * @return
<i>3725</i>&nbsp;	 */
<i>3726</i>&nbsp;	public ObjectProperty&lt;PathTool&gt; selectedToolProperty() {
<b class="fc"><i>3727</i>&nbsp;		return selectedToolProperty;</b>
<i>3728</i>&nbsp;	}
<i>3729</i>&nbsp;	
<i>3730</i>&nbsp;	/**
<i>3731</i>&nbsp;	 * Flag to indicate that menus are being initialized.
<i>3732</i>&nbsp;	 * All menu items should be &#39;visible&#39; during this time, and the system menubar shouldn&#39;t be used.
<i>3733</i>&nbsp;	 * This is an attempt to workaround a Java issue (at least on OS X) where IndexOutOfBoundsExceptions occur 
<i>3734</i>&nbsp;	 * when messing around with the system menubar with visible/invisible items.
<i>3735</i>&nbsp;	 */
<b class="fc"><i>3736</i>&nbsp;	private static BooleanProperty initializingMenus = new SimpleBooleanProperty(false);</b>
<i>3737</i>&nbsp;	
<b class="fc"><i>3738</i>&nbsp;	private static BooleanBinding showExperimentalOptions = PathPrefs.showExperimentalOptionsProperty().or(initializingMenus);</b>
<b class="fc"><i>3739</i>&nbsp;	private static BooleanBinding showTMAOptions = PathPrefs.showTMAOptionsProperty().or(initializingMenus);</b>
<b class="fc"><i>3740</i>&nbsp;	private static BooleanBinding showLegacyOptions = PathPrefs.showLegacyOptionsProperty().or(initializingMenus);</b>
<i>3741</i>&nbsp;	
<i>3742</i>&nbsp;	private static &lt;T extends MenuItem&gt; T bindVisibilityForExperimental(final T menuItem) {
<b class="fc"><i>3743</i>&nbsp;		String text = menuItem.getText();</b>
<b class="fc"><i>3744</i>&nbsp;		if (text == null)</b>
<b class="fc"><i>3745</i>&nbsp;			return menuItem;</b>
<b class="fc"><i>3746</i>&nbsp;		text = text.toLowerCase().trim();</b>
<b class="fc"><i>3747</i>&nbsp;		if (text.equals(&quot;experimental&quot;) || text.endsWith(&quot;experimental)&quot;))</b>
<b class="fc"><i>3748</i>&nbsp;			menuItem.visibleProperty().bind(showExperimentalOptions);</b>
<b class="fc"><i>3749</i>&nbsp;		else if (text.equals(&quot;tma&quot;) || text.endsWith(&quot;tma)&quot;))</b>
<b class="fc"><i>3750</i>&nbsp;			menuItem.visibleProperty().bind(showTMAOptions);</b>
<b class="fc"><i>3751</i>&nbsp;		else if (text.equals(&quot;legacy&quot;) || text.endsWith(&quot;legacy)&quot;))</b>
<b class="nc"><i>3752</i>&nbsp;			menuItem.visibleProperty().bind(showLegacyOptions);</b>
<b class="fc"><i>3753</i>&nbsp;		return menuItem;</b>
<i>3754</i>&nbsp;	}
<i>3755</i>&nbsp;	
<i>3756</i>&nbsp;	/**
<i>3757</i>&nbsp;	 * Return the global {@link OverlayOptions} instance, used to control display within viewers by default.
<i>3758</i>&nbsp;	 * @return
<i>3759</i>&nbsp;	 */
<i>3760</i>&nbsp;	public OverlayOptions getOverlayOptions() {
<b class="fc"><i>3761</i>&nbsp;		return overlayOptions;</b>
<i>3762</i>&nbsp;	}
<i>3763</i>&nbsp;
<i>3764</i>&nbsp;	/**
<i>3765</i>&nbsp;	 * Return the global {@link DefaultImageRegionStore} instance, used to cache and paint image tiles.
<i>3766</i>&nbsp;	 * @return
<i>3767</i>&nbsp;	 */
<i>3768</i>&nbsp;	public DefaultImageRegionStore getImageRegionStore() {
<b class="nc"><i>3769</i>&nbsp;		return imageRegionStore;</b>
<i>3770</i>&nbsp;	}
<i>3771</i>&nbsp;	
<i>3772</i>&nbsp;	
<i>3773</i>&nbsp;	private void initializeAnalysisPanel() {
<b class="fc"><i>3774</i>&nbsp;		analysisPanel.setTabClosingPolicy(TabClosingPolicy.UNAVAILABLE);</b>
<b class="fc"><i>3775</i>&nbsp;		projectBrowser = new ProjectBrowser(this);</b>
<i>3776</i>&nbsp;
<b class="fc"><i>3777</i>&nbsp;		analysisPanel.getTabs().add(new Tab(&quot;Project&quot;, projectBrowser.getPane()));</b>
<b class="fc"><i>3778</i>&nbsp;		ImageDetailsPane pathImageDetailsPanel = new ImageDetailsPane(this);</b>
<b class="fc"><i>3779</i>&nbsp;		analysisPanel.getTabs().add(new Tab(&quot;Image&quot;, pathImageDetailsPanel.getPane()));</b>
<i>3780</i>&nbsp;
<b class="fc"><i>3781</i>&nbsp;		final AnnotationPane panelAnnotations = new AnnotationPane(this);</b>
<b class="fc"><i>3782</i>&nbsp;		SplitPane splitAnnotations = new SplitPane();</b>
<b class="fc"><i>3783</i>&nbsp;		splitAnnotations.setOrientation(Orientation.VERTICAL);</b>
<b class="fc"><i>3784</i>&nbsp;		splitAnnotations.getItems().addAll(</b>
<b class="fc"><i>3785</i>&nbsp;				panelAnnotations.getPane(),</b>
<b class="fc"><i>3786</i>&nbsp;				new SelectedMeasurementTableView(this).getTable());</b>
<b class="fc"><i>3787</i>&nbsp;		analysisPanel.getTabs().add(new Tab(&quot;Annotations&quot;, splitAnnotations));</b>
<i>3788</i>&nbsp;
<b class="fc"><i>3789</i>&nbsp;		final PathObjectHierarchyView paneHierarchy = new PathObjectHierarchyView(this);</b>
<b class="fc"><i>3790</i>&nbsp;		SplitPane splitHierarchy = new SplitPane();</b>
<b class="fc"><i>3791</i>&nbsp;		splitHierarchy.setOrientation(Orientation.VERTICAL);</b>
<b class="fc"><i>3792</i>&nbsp;		splitHierarchy.getItems().addAll(</b>
<b class="fc"><i>3793</i>&nbsp;				paneHierarchy.getPane(),</b>
<b class="fc"><i>3794</i>&nbsp;				new SelectedMeasurementTableView(this).getTable());</b>
<b class="fc"><i>3795</i>&nbsp;		analysisPanel.getTabs().add(new Tab(&quot;Hierarchy&quot;, splitHierarchy));</b>
<i>3796</i>&nbsp;		
<i>3797</i>&nbsp;		// Bind the split pane dividers to create a more consistent appearance
<b class="fc"><i>3798</i>&nbsp;		splitAnnotations.getDividers().get(0).positionProperty().bindBidirectional(</b>
<b class="fc"><i>3799</i>&nbsp;				splitHierarchy.getDividers().get(0).positionProperty()</b>
<i>3800</i>&nbsp;				);
<i>3801</i>&nbsp;
<b class="fc"><i>3802</i>&nbsp;		var commandLogView = new WorkflowCommandLogView(this);</b>
<b class="fc"><i>3803</i>&nbsp;		TitledPane titledLog = new TitledPane(&quot;Command history&quot;, commandLogView.getPane());</b>
<b class="fc"><i>3804</i>&nbsp;		titledLog.setCollapsible(false);</b>
<b class="fc"><i>3805</i>&nbsp;		titledLog.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);</b>
<b class="fc"><i>3806</i>&nbsp;		var pane = new BorderPane(titledLog);</b>
<b class="fc"><i>3807</i>&nbsp;		analysisPanel.getTabs().add(new Tab(&quot;Workflow&quot;, pane));</b>
<b class="fc"><i>3808</i>&nbsp;	}</b>
<i>3809</i>&nbsp;	
<i>3810</i>&nbsp;	
<i>3811</i>&nbsp;	/**
<i>3812</i>&nbsp;	 * Create a default list model for storing available PathClasses.
<i>3813</i>&nbsp;	 * 
<i>3814</i>&nbsp;	 * @return
<i>3815</i>&nbsp;	 */
<i>3816</i>&nbsp;	public ObservableList&lt;PathClass&gt; getAvailablePathClasses() {
<b class="fc"><i>3817</i>&nbsp;		return availablePathClasses;</b>
<i>3818</i>&nbsp;	}
<i>3819</i>&nbsp;	
<i>3820</i>&nbsp;	
<i>3821</i>&nbsp;	/**
<i>3822</i>&nbsp;	 * Get the menubar for the main QuPath application.
<i>3823</i>&nbsp;	 * @return
<i>3824</i>&nbsp;	 */
<i>3825</i>&nbsp;	public MenuBar getMenuBar() {
<b class="fc"><i>3826</i>&nbsp;		return menuBar;</b>
<i>3827</i>&nbsp;	}
<i>3828</i>&nbsp;
<i>3829</i>&nbsp;	/**
<i>3830</i>&nbsp;	 * Get a reference to an existing menu from the main QuPath menubar, optionally creating a new menu if it is not present.
<i>3831</i>&nbsp;	 * 
<i>3832</i>&nbsp;	 * @param name
<i>3833</i>&nbsp;	 * @param createMenu
<i>3834</i>&nbsp;	 * @return
<i>3835</i>&nbsp;	 */
<i>3836</i>&nbsp;	public Menu getMenu(final String name, final boolean createMenu) {
<b class="fc"><i>3837</i>&nbsp;		var menubar = getMenuBar();</b>
<b class="fc"><i>3838</i>&nbsp;		if (menubar == null)</b>
<b class="nc"><i>3839</i>&nbsp;			return null;</b>
<b class="fc"><i>3840</i>&nbsp;		return MenuTools.getMenu(menuBar.getMenus(), name, createMenu);</b>
<i>3841</i>&nbsp;	}
<i>3842</i>&nbsp;
<i>3843</i>&nbsp;	/**
<i>3844</i>&nbsp;	 * Get the main QuPath stage.
<i>3845</i>&nbsp;	 * @return
<i>3846</i>&nbsp;	 */
<i>3847</i>&nbsp;	public Stage getStage() {
<b class="fc"><i>3848</i>&nbsp;		return stage;</b>
<i>3849</i>&nbsp;	}
<i>3850</i>&nbsp;	
<i>3851</i>&nbsp;	private void updateMagnificationString() {
<b class="fc"><i>3852</i>&nbsp;		if (toolbar == null)</b>
<b class="fc"><i>3853</i>&nbsp;			return;</b>
<b class="nc"><i>3854</i>&nbsp;		toolbar.updateMagnificationDisplay(getViewer());</b>
<b class="nc"><i>3855</i>&nbsp;	}</b>
<i>3856</i>&nbsp;	
<i>3857</i>&nbsp;	
<i>3858</i>&nbsp;	private String getDisplayedImageName(ImageData&lt;BufferedImage&gt; imageData) {
<b class="fc"><i>3859</i>&nbsp;		if (imageData == null)</b>
<b class="nc"><i>3860</i>&nbsp;			return null;</b>
<b class="fc"><i>3861</i>&nbsp;		var project = getProject();</b>
<b class="fc"><i>3862</i>&nbsp;		var entry = project == null ? null : project.getEntry(imageData);</b>
<b class="fc"><i>3863</i>&nbsp;		if (entry == null) {</b>
<b class="fc"><i>3864</i>&nbsp;			if (PathPrefs.maskImageNamesProperty().get())</b>
<b class="nc"><i>3865</i>&nbsp;				return &quot;(Name masked)&quot;;</b>
<b class="fc"><i>3866</i>&nbsp;			return ServerTools.getDisplayableImageName(imageData.getServer());</b>
<i>3867</i>&nbsp;		} else {
<i>3868</i>&nbsp;			// Make sure that the status of name masking has been set in the project (in case it hasn&#39;t been triggered yet...)
<b class="nc"><i>3869</i>&nbsp;			project.setMaskImageNames(PathPrefs.maskImageNamesProperty().get());</b>
<b class="nc"><i>3870</i>&nbsp;			return entry.getImageName();</b>
<i>3871</i>&nbsp;		}
<i>3872</i>&nbsp;	}
<i>3873</i>&nbsp;	
<i>3874</i>&nbsp;	/**
<i>3875</i>&nbsp;	 * Refresh the title bar in the main QuPath window.
<i>3876</i>&nbsp;	 */
<i>3877</i>&nbsp;	public void refreshTitle() {
<b class="nc"><i>3878</i>&nbsp;		if (Platform.isFxApplicationThread())</b>
<b class="nc"><i>3879</i>&nbsp;			titleBinding.invalidate();</b>
<i>3880</i>&nbsp;		else
<b class="nc"><i>3881</i>&nbsp;			Platform.runLater(() -&gt; refreshTitle());</b>
<b class="nc"><i>3882</i>&nbsp;	}</b>
<i>3883</i>&nbsp;	
<i>3884</i>&nbsp;	
<b class="fc"><i>3885</i>&nbsp;	private StringBinding titleBinding = Bindings.createStringBinding(</b>
<i>3886</i>&nbsp;				() -&gt; {
<b class="fc"><i>3887</i>&nbsp;					String name = &quot;QuPath&quot;;</b>
<b class="fc"><i>3888</i>&nbsp;					var versionString = getVersionString();</b>
<b class="fc"><i>3889</i>&nbsp;					if (versionString != null)</b>
<b class="nc"><i>3890</i>&nbsp;						name = name + &quot; (&quot; + versionString + &quot;)&quot;;</b>
<b class="fc"><i>3891</i>&nbsp;					var imageData = imageDataProperty.get();</b>
<b class="fc"><i>3892</i>&nbsp;					if (imageData == null || !PathPrefs.showImageNameInTitleProperty().get())</b>
<b class="fc"><i>3893</i>&nbsp;						return name;</b>
<b class="fc"><i>3894</i>&nbsp;					return name + &quot; - &quot; + getDisplayedImageName(imageData);</b>
<i>3895</i>&nbsp;				},
<b class="fc"><i>3896</i>&nbsp;				projectProperty, imageDataProperty, PathPrefs.showImageNameInTitleProperty(), PathPrefs.maskImageNamesProperty());</b>
<i>3897</i>&nbsp;	
<i>3898</i>&nbsp;	
<i>3899</i>&nbsp;	/**
<i>3900</i>&nbsp;	 * Get a String representing the QuPath version &amp;amp; build time.
<i>3901</i>&nbsp;	 * 
<i>3902</i>&nbsp;	 * @return
<i>3903</i>&nbsp;	 */
<i>3904</i>&nbsp;	public static String getBuildString() {
<b class="nc"><i>3905</i>&nbsp;		return BuildInfo.getInstance().getBuildString();</b>
<i>3906</i>&nbsp;	}
<i>3907</i>&nbsp;	
<i>3908</i>&nbsp;	private static String getVersionString() {
<b class="fc"><i>3909</i>&nbsp;		return BuildInfo.getInstance().getVersionString();</b>
<i>3910</i>&nbsp;	}
<i>3911</i>&nbsp;	
<i>3912</i>&nbsp;	/**
<i>3913</i>&nbsp;	 * Get the current QuPath version.
<i>3914</i>&nbsp;	 * @return
<i>3915</i>&nbsp;	 */
<i>3916</i>&nbsp;	public static Version getVersion() {
<b class="nc"><i>3917</i>&nbsp;		return BuildInfo.getInstance().getVersion();</b>
<i>3918</i>&nbsp;	}
<i>3919</i>&nbsp;	
<i>3920</i>&nbsp;	/**
<i>3921</i>&nbsp;	 * Read-only property containing the image open within the currently-active viewer.
<i>3922</i>&nbsp;	 * To change the open image data, you should do so directly within the viewer.
<i>3923</i>&nbsp;	 * @return
<i>3924</i>&nbsp;	 */
<i>3925</i>&nbsp;	public ReadOnlyObjectProperty&lt;ImageData&lt;BufferedImage&gt;&gt; imageDataProperty() {
<b class="fc"><i>3926</i>&nbsp;		return imageDataProperty;</b>
<i>3927</i>&nbsp;	}
<i>3928</i>&nbsp;	
<i>3929</i>&nbsp;	
<i>3930</i>&nbsp;	private void fireImageDataChangedEvent(final ImageData&lt;BufferedImage&gt; imageDataOld, ImageData&lt;BufferedImage&gt; imageDataNew) {		
<i>3931</i>&nbsp;		
<b class="fc"><i>3932</i>&nbsp;		imageDataProperty.set(imageDataNew);</b>
<i>3933</i>&nbsp;		
<i>3934</i>&nbsp;//		// A bit awkward, this... but make sure the extended scripting helper static class knows what&#39;s happened
<i>3935</i>&nbsp;//		QPEx.setBatchImageData(imageDataNew);
<i>3936</i>&nbsp;		
<b class="fc"><i>3937</i>&nbsp;	}</b>
<i>3938</i>&nbsp;	
<i>3939</i>&nbsp;	
<i>3940</i>&nbsp;	/**
<i>3941</i>&nbsp;	 * Set the active project, triggering any necessary GUI updates.
<i>3942</i>&nbsp;	 * 
<i>3943</i>&nbsp;	 * @param project
<i>3944</i>&nbsp;	 */
<i>3945</i>&nbsp;	public void setProject(final Project&lt;BufferedImage&gt; project) {
<b class="nc"><i>3946</i>&nbsp;		var currentProject = this.projectProperty.get();</b>
<b class="nc"><i>3947</i>&nbsp;		if (currentProject == project)</b>
<b class="nc"><i>3948</i>&nbsp;			return;</b>
<i>3949</i>&nbsp;		
<i>3950</i>&nbsp;		// Ensure we save the current project
<b class="nc"><i>3951</i>&nbsp;		if (currentProject != null) {</b>
<i>3952</i>&nbsp;			try {
<b class="nc"><i>3953</i>&nbsp;				currentProject.syncChanges();</b>
<b class="nc"><i>3954</i>&nbsp;			} catch (IOException e) {</b>
<b class="nc"><i>3955</i>&nbsp;				logger.error(&quot;Error syncing project&quot;, e);</b>
<b class="nc"><i>3956</i>&nbsp;				if (!Dialogs.showYesNoDialog(&quot;Project error&quot;, &quot;A problem occurred while saving the last project - do you want to continue?&quot;))</b>
<b class="nc"><i>3957</i>&nbsp;					return;</b>
<b class="nc"><i>3958</i>&nbsp;			}</b>
<i>3959</i>&nbsp;		}
<i>3960</i>&nbsp;		
<i>3961</i>&nbsp;		// Check if we want to save the current image; we could still veto the project change at this point
<b class="nc"><i>3962</i>&nbsp;		for (var viewer : getViewers()) {</b>
<b class="nc"><i>3963</i>&nbsp;			if (viewer == null || !viewer.hasServer())</b>
<b class="nc"><i>3964</i>&nbsp;				continue;</b>
<b class="nc"><i>3965</i>&nbsp;			var imageData = viewer.getImageData();</b>
<b class="nc"><i>3966</i>&nbsp;			if (imageData != null) {</b>
<i>3967</i>&nbsp;//				ProjectImageEntry&lt;BufferedImage&gt; entry = getProjectImageEntry(imageData);
<i>3968</i>&nbsp;	//			if (entry != null) {
<b class="nc"><i>3969</i>&nbsp;					if (!checkSaveChanges(imageData))</b>
<b class="nc"><i>3970</i>&nbsp;						return;</b>
<b class="nc"><i>3971</i>&nbsp;					viewer.setImageData(null);</b>
<i>3972</i>&nbsp;	//			} else
<i>3973</i>&nbsp;	//				ProjectImportImagesCommand.addSingleImageToProject(project, imageData.getServer(), null);
<i>3974</i>&nbsp;			}
<b class="nc"><i>3975</i>&nbsp;		}</b>
<i>3976</i>&nbsp;		
<i>3977</i>&nbsp;		// Confirm the URIs for the new project
<b class="nc"><i>3978</i>&nbsp;		if (project != null) {</b>
<i>3979</i>&nbsp;			try {
<i>3980</i>&nbsp;				// Show URI manager dialog if we have any missing URIs
<b class="nc"><i>3981</i>&nbsp;				if (!ProjectCommands.promptToCheckURIs(project, true))</b>
<b class="nc"><i>3982</i>&nbsp;					return;</b>
<b class="nc"><i>3983</i>&nbsp;			} catch (IOException e) {</b>
<b class="nc"><i>3984</i>&nbsp;				Dialogs.showErrorMessage(&quot;Update URIs&quot;, e);</b>
<b class="nc"><i>3985</i>&nbsp;				return;</b>
<b class="nc"><i>3986</i>&nbsp;			}</b>
<i>3987</i>&nbsp;		}
<i>3988</i>&nbsp;		
<i>3989</i>&nbsp;		// Store in recent list, if needed
<b class="nc"><i>3990</i>&nbsp;		URI uri = project == null ? null : project.getURI();</b>
<b class="nc"><i>3991</i>&nbsp;		if (uri != null) {</b>
<b class="nc"><i>3992</i>&nbsp;			ObservableList&lt;URI&gt; list = PathPrefs.getRecentProjectList();			</b>
<b class="nc"><i>3993</i>&nbsp;			if (list.contains(uri)) {</b>
<b class="nc"><i>3994</i>&nbsp;				if (!uri.equals(list.get(0))) {</b>
<b class="nc"><i>3995</i>&nbsp;					list.remove(uri);</b>
<b class="nc"><i>3996</i>&nbsp;					list.add(0, uri);</b>
<i>3997</i>&nbsp;				}
<i>3998</i>&nbsp;			} else
<b class="nc"><i>3999</i>&nbsp;				list.add(0, uri);</b>
<i>4000</i>&nbsp;		}
<i>4001</i>&nbsp;		
<b class="nc"><i>4002</i>&nbsp;		this.projectProperty.set(project);</b>
<b class="nc"><i>4003</i>&nbsp;		if (!this.projectBrowser.setProject(project)) {</b>
<b class="nc"><i>4004</i>&nbsp;			this.projectProperty.set(null);</b>
<b class="nc"><i>4005</i>&nbsp;			this.projectBrowser.setProject(null);</b>
<i>4006</i>&nbsp;		}
<i>4007</i>&nbsp;		
<i>4008</i>&nbsp;		// Update the PathClass list, if necessary
<b class="nc"><i>4009</i>&nbsp;		if (project != null) {</b>
<b class="nc"><i>4010</i>&nbsp;			List&lt;PathClass&gt; pathClasses = project.getPathClasses();</b>
<b class="nc"><i>4011</i>&nbsp;			if (pathClasses.isEmpty()) {</b>
<i>4012</i>&nbsp;				// Update the project according to the specified PathClasses
<b class="nc"><i>4013</i>&nbsp;				project.setPathClasses(getAvailablePathClasses());</b>
<i>4014</i>&nbsp;			} else {
<i>4015</i>&nbsp;				// Update the available classes
<b class="nc"><i>4016</i>&nbsp;				if (!pathClasses.contains(PathClassFactory.getPathClassUnclassified())) {</b>
<b class="nc"><i>4017</i>&nbsp;					pathClasses = new ArrayList&lt;&gt;(pathClasses);</b>
<b class="nc"><i>4018</i>&nbsp;					pathClasses.add(0, PathClassFactory.getPathClassUnclassified());</b>
<i>4019</i>&nbsp;				}
<b class="nc"><i>4020</i>&nbsp;				getAvailablePathClasses().setAll(pathClasses);</b>
<i>4021</i>&nbsp;			}
<i>4022</i>&nbsp;		}
<i>4023</i>&nbsp;		
<i>4024</i>&nbsp;		// Ensure we have the required directories
<i>4025</i>&nbsp;//		getProjectClassifierDirectory(true);
<i>4026</i>&nbsp;//		getProjectScriptsDirectory(true);
<i>4027</i>&nbsp;		
<b class="nc"><i>4028</i>&nbsp;		logger.info(&quot;Project set to {}&quot;, project);</b>
<b class="nc"><i>4029</i>&nbsp;	}</b>
<i>4030</i>&nbsp;	
<i>4031</i>&nbsp;	
<i>4032</i>&nbsp;	/**
<i>4033</i>&nbsp;	 * Refresh the project, updating the display if required.
<i>4034</i>&nbsp;	 * This can be called whenever the project has changed (e.g. by adding or removing items).
<i>4035</i>&nbsp;	 */
<i>4036</i>&nbsp;	public void refreshProject() {
<b class="nc"><i>4037</i>&nbsp;		projectBrowser.refreshProject();</b>
<b class="nc"><i>4038</i>&nbsp;	}</b>
<i>4039</i>&nbsp;	
<i>4040</i>&nbsp;	/**
<i>4041</i>&nbsp;	 * Read-only property representing the currently-open project.
<i>4042</i>&nbsp;	 * @return
<i>4043</i>&nbsp;	 */
<i>4044</i>&nbsp;	public ReadOnlyObjectProperty&lt;Project&lt;BufferedImage&gt;&gt; projectProperty() {
<b class="fc"><i>4045</i>&nbsp;		return projectProperty;</b>
<i>4046</i>&nbsp;	}
<i>4047</i>&nbsp;	
<i>4048</i>&nbsp;	/**
<i>4049</i>&nbsp;	 * Get the value of {@link #projectProperty()}.
<i>4050</i>&nbsp;	 * @return
<i>4051</i>&nbsp;	 */
<i>4052</i>&nbsp;	public Project&lt;BufferedImage&gt; getProject() {
<b class="fc"><i>4053</i>&nbsp;		return projectProperty.get();</b>
<i>4054</i>&nbsp;	}
<i>4055</i>&nbsp;	
<i>4056</i>&nbsp;	
<b class="fc"><i>4057</i>&nbsp;	private BooleanProperty showAnalysisPane = new SimpleBooleanProperty(true);</b>
<i>4058</i>&nbsp;	protected double lastDividerLocation;
<i>4059</i>&nbsp;	
<i>4060</i>&nbsp;	private void setAnalysisPaneVisible(boolean visible) {
<b class="fc"><i>4061</i>&nbsp;		if (visible) {</b>
<b class="fc"><i>4062</i>&nbsp;			if (analysisPanelVisible())</b>
<b class="fc"><i>4063</i>&nbsp;				return;</b>
<b class="nc"><i>4064</i>&nbsp;			splitPane.getItems().setAll(analysisPanel, mainViewerPane);</b>
<b class="nc"><i>4065</i>&nbsp;			splitPane.setDividerPosition(0, lastDividerLocation);</b>
<b class="nc"><i>4066</i>&nbsp;			pane.setCenter(splitPane);</b>
<i>4067</i>&nbsp;		} else {
<b class="nc"><i>4068</i>&nbsp;			if (!analysisPanelVisible())</b>
<b class="nc"><i>4069</i>&nbsp;				return;</b>
<b class="nc"><i>4070</i>&nbsp;			lastDividerLocation = splitPane.getDividers().get(0).getPosition();</b>
<b class="nc"><i>4071</i>&nbsp;			pane.setCenter(mainViewerPane);				</b>
<i>4072</i>&nbsp;		}
<b class="nc"><i>4073</i>&nbsp;	}</b>
<i>4074</i>&nbsp;	
<i>4075</i>&nbsp;	private boolean analysisPanelVisible() {
<b class="fc"><i>4076</i>&nbsp;		return pane.getCenter() == splitPane;</b>
<i>4077</i>&nbsp;	}
<i>4078</i>&nbsp;	
<i>4079</i>&nbsp;	
<i>4080</i>&nbsp;
<i>4081</i>&nbsp;	/**
<i>4082</i>&nbsp;	 * Get the value of {@link #imageDataProperty()}.
<i>4083</i>&nbsp;	 * @return
<i>4084</i>&nbsp;	 */
<i>4085</i>&nbsp;	public ImageData&lt;BufferedImage&gt; getImageData() {
<b class="fc"><i>4086</i>&nbsp;		return imageDataProperty().get();</b>
<i>4087</i>&nbsp;	}
<i>4088</i>&nbsp;	
<i>4089</i>&nbsp;	
<i>4090</i>&nbsp;	/**
<i>4091</i>&nbsp;	 * Property representing the viewer currently active.
<i>4092</i>&nbsp;	 * 
<i>4093</i>&nbsp;	 * @return
<i>4094</i>&nbsp;	 */
<i>4095</i>&nbsp;	public ReadOnlyObjectProperty&lt;QuPathViewerPlus&gt; viewerProperty() {
<b class="fc"><i>4096</i>&nbsp;		return viewerManager.activeViewerProperty();</b>
<i>4097</i>&nbsp;	}
<i>4098</i>&nbsp;	
<i>4099</i>&nbsp;	
<i>4100</i>&nbsp;	
<i>4101</i>&nbsp;	/**
<i>4102</i>&nbsp;	 * Show a prompt to save changes for an ImageData. 
<i>4103</i>&nbsp;	 * &lt;p&gt;
<i>4104</i>&nbsp;	 * Note the return value indicates whether the user cancelled or not, rather than whether the data 
<i>4105</i>&nbsp;	 * was saved or not.
<i>4106</i>&nbsp;	 * 
<i>4107</i>&nbsp;	 * @param dialogTitle
<i>4108</i>&nbsp;	 * @param imageData
<i>4109</i>&nbsp;	 * @return true if the prompt &#39;succeeded&#39; (i.e. user chose &#39;Yes&#39; or &#39;No&#39;), false if it was cancelled.
<i>4110</i>&nbsp;	 */
<i>4111</i>&nbsp;	private boolean promptToSaveChangesOrCancel(String dialogTitle, ImageData&lt;BufferedImage&gt; imageData) {
<b class="fc"><i>4112</i>&nbsp;		var project = getProject();</b>
<b class="fc"><i>4113</i>&nbsp;		var entry = project == null ? null : project.getEntry(imageData);</b>
<b class="fc"><i>4114</i>&nbsp;		File filePrevious = null;</b>
<b class="fc"><i>4115</i>&nbsp;		if (entry == null) {</b>
<b class="fc"><i>4116</i>&nbsp;			String lastPath = imageData.getLastSavedPath();</b>
<b class="fc"><i>4117</i>&nbsp;			filePrevious = lastPath == null ? null : new File(lastPath);</b>
<i>4118</i>&nbsp;		}
<b class="fc"><i>4119</i>&nbsp;		DialogButton response = DialogButton.YES;</b>
<b class="fc"><i>4120</i>&nbsp;		if (imageData.isChanged()) {</b>
<b class="fc"><i>4121</i>&nbsp;			response = Dialogs.showYesNoCancelDialog(dialogTitle, &quot;Save changes to &quot; + ServerTools.getDisplayableImageName(imageData.getServer()) + &quot;?&quot;);</b>
<i>4122</i>&nbsp;		}
<b class="fc"><i>4123</i>&nbsp;		if (response == DialogButton.CANCEL)</b>
<b class="nc"><i>4124</i>&nbsp;			return false;</b>
<b class="fc"><i>4125</i>&nbsp;		if (response == DialogButton.YES) {</b>
<b class="nc"><i>4126</i>&nbsp;			if (filePrevious == null &amp;&amp; entry == null) {</b>
<b class="nc"><i>4127</i>&nbsp;				filePrevious = Dialogs.promptToSaveFile(&quot;Save image data&quot;, filePrevious, ServerTools.getDisplayableImageName(imageData.getServer()), &quot;QuPath Serialized Data&quot;, PathPrefs.getSerializationExtension());</b>
<b class="nc"><i>4128</i>&nbsp;				if (filePrevious == null)</b>
<b class="nc"><i>4129</i>&nbsp;					return false;</b>
<i>4130</i>&nbsp;			}
<i>4131</i>&nbsp;			try {
<b class="nc"><i>4132</i>&nbsp;				if (entry != null) {</b>
<b class="nc"><i>4133</i>&nbsp;					entry.saveImageData(imageData);</b>
<b class="nc"><i>4134</i>&nbsp;					project.syncChanges(); // Should make sure we save the project in case metadata has changed as well</b>
<i>4135</i>&nbsp;				} else
<b class="nc"><i>4136</i>&nbsp;					PathIO.writeImageData(filePrevious, imageData);</b>
<b class="nc"><i>4137</i>&nbsp;			} catch (IOException e) {</b>
<b class="nc"><i>4138</i>&nbsp;				Dialogs.showErrorMessage(&quot;Save ImageData&quot;, e);</b>
<b class="nc"><i>4139</i>&nbsp;			}</b>
<i>4140</i>&nbsp;		}
<b class="fc"><i>4141</i>&nbsp;		return true;</b>
<i>4142</i>&nbsp;	}
<i>4143</i>&nbsp;	
<i>4144</i>&nbsp;	
<i>4145</i>&nbsp;	
<i>4146</i>&nbsp;	/**
<i>4147</i>&nbsp;	 * Calculate the appropriate tile cache size based upon the user preferences.
<i>4148</i>&nbsp;	 * @return tile cache size in bytes
<i>4149</i>&nbsp;	 */
<i>4150</i>&nbsp;	private static long getTileCacheSizeBytes() {
<i>4151</i>&nbsp;		// Try to compute a sensible value...
<b class="fc"><i>4152</i>&nbsp;		Runtime rt = Runtime.getRuntime();</b>
<b class="fc"><i>4153</i>&nbsp;		long maxAvailable = rt.maxMemory(); // Max available memory</b>
<b class="fc"><i>4154</i>&nbsp;		if (maxAvailable == Long.MAX_VALUE) {</b>
<b class="nc"><i>4155</i>&nbsp;			logger.warn(&quot;No inherent maximum memory set - for caching purposes, will assume 64 GB&quot;);</b>
<b class="nc"><i>4156</i>&nbsp;			maxAvailable = 64L * 1024L * 1024L * 1024L;</b>
<i>4157</i>&nbsp;		}
<b class="fc"><i>4158</i>&nbsp;		double percentage = PathPrefs.tileCachePercentageProperty().get();</b>
<b class="fc"><i>4159</i>&nbsp;		if (percentage &lt; 10) {</b>
<b class="nc"><i>4160</i>&nbsp;			logger.warn(&quot;At least 10% of available memory needs to be used for tile caching (you requested {}%)&quot;, percentage);</b>
<b class="nc"><i>4161</i>&nbsp;			percentage = 10;</b>
<b class="fc"><i>4162</i>&nbsp;		} else if (percentage &gt; 90) {</b>
<b class="nc"><i>4163</i>&nbsp;			logger.warn(&quot;No more than 90% of available memory can be used for tile caching (you requested {}%)&quot;, percentage);</b>
<b class="nc"><i>4164</i>&nbsp;			percentage = 00;			</b>
<i>4165</i>&nbsp;		}
<b class="fc"><i>4166</i>&nbsp;		long tileCacheSize = Math.round(maxAvailable * (percentage / 100.0));</b>
<b class="fc"><i>4167</i>&nbsp;		logger.info(String.format(&quot;Setting tile cache size to %.2f MB (%.1f%% max memory)&quot;, tileCacheSize/(1024.*1024.), percentage));</b>
<b class="fc"><i>4168</i>&nbsp;		return tileCacheSize;</b>
<i>4169</i>&nbsp;	}
<i>4170</i>&nbsp;
<i>4171</i>&nbsp;
<i>4172</i>&nbsp;
<i>4173</i>&nbsp;	class MultiviewManager implements QuPathViewerListener {
<i>4174</i>&nbsp;		
<b class="fc"><i>4175</i>&nbsp;		private List&lt;QuPathViewerPlus&gt; viewers = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>4176</i>&nbsp;		private SimpleObjectProperty&lt;QuPathViewerPlus&gt; activeViewerProperty = new SimpleObjectProperty&lt;&gt;();</b>
<i>4177</i>&nbsp;		
<i>4178</i>&nbsp;		private SplitPaneGrid splitPaneGrid;
<i>4179</i>&nbsp;		
<b class="fc"><i>4180</i>&nbsp;		private PathObject lastAnnotationObject = null;</b>
<i>4181</i>&nbsp;//		private ROI lastROI = null;
<i>4182</i>&nbsp;		
<b class="fc"><i>4183</i>&nbsp;		final int borderWidth = 4;</b>
<b class="fc"><i>4184</i>&nbsp;		final Color colorTransparent = Color.TRANSPARENT;</b>
<b class="fc"><i>4185</i>&nbsp;		final Color colorBorder = Color.rgb(180, 0, 0, 0.5);</b>
<i>4186</i>&nbsp;		
<b class="fc"><i>4187</i>&nbsp;		final Border borderTransparent = new Border(new BorderStroke(colorTransparent, null, null, null));</b>
<b class="fc"><i>4188</i>&nbsp;		final Border borderSelected = new Border(new BorderStroke(colorBorder, BorderStrokeStyle.SOLID, null, null));</b>
<i>4189</i>&nbsp;		
<i>4190</i>&nbsp;//		private boolean aligningCores = false;
<b class="fc"><i>4191</i>&nbsp;		private BooleanProperty synchronizeViewers = new SimpleBooleanProperty(true);</b>
<b class="fc"><i>4192</i>&nbsp;		private double lastX = Double.NaN;</b>
<b class="fc"><i>4193</i>&nbsp;		private double lastY = Double.NaN;</b>
<b class="fc"><i>4194</i>&nbsp;		private double lastDownsample = Double.NaN;</b>
<b class="fc"><i>4195</i>&nbsp;		private double lastRotation = Double.NaN;</b>
<i>4196</i>&nbsp;		
<b class="fc"><i>4197</i>&nbsp;		public MultiviewManager(final QuPathViewerPlus defaultViewer) {</b>
<b class="fc"><i>4198</i>&nbsp;			this.viewers.add(defaultViewer);</b>
<b class="fc"><i>4199</i>&nbsp;			if (defaultViewer != null)</b>
<b class="fc"><i>4200</i>&nbsp;				defaultViewer.addViewerListener(this);</b>
<b class="fc"><i>4201</i>&nbsp;			setActiveViewer(defaultViewer);</b>
<b class="fc"><i>4202</i>&nbsp;			splitPaneGrid = new SplitPaneGrid(defaultViewer.getView());</b>
<b class="fc"><i>4203</i>&nbsp;		}</b>
<i>4204</i>&nbsp;		
<i>4205</i>&nbsp;		public List&lt;QuPathViewerPlus&gt; getViewers() {
<b class="fc"><i>4206</i>&nbsp;			return Collections.unmodifiableList(viewers);</b>
<i>4207</i>&nbsp;		}
<i>4208</i>&nbsp;		
<i>4209</i>&nbsp;		/**
<i>4210</i>&nbsp;		 * Return a list of viewers which currently have an ImageData object set
<i>4211</i>&nbsp;		 * @return
<i>4212</i>&nbsp;		 */
<i>4213</i>&nbsp;		public List&lt;QuPathViewerPlus&gt; getOpenViewers() {
<b class="nc"><i>4214</i>&nbsp;			List&lt;QuPathViewerPlus&gt; openViewers = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>4215</i>&nbsp;			for (QuPathViewerPlus v : viewers) {</b>
<b class="nc"><i>4216</i>&nbsp;				if (v.getImageData() != null)</b>
<b class="nc"><i>4217</i>&nbsp;					openViewers.add(v);</b>
<b class="nc"><i>4218</i>&nbsp;			}</b>
<b class="nc"><i>4219</i>&nbsp;			return openViewers;</b>
<i>4220</i>&nbsp;		}
<i>4221</i>&nbsp;		
<i>4222</i>&nbsp;		/**
<i>4223</i>&nbsp;		 * Match the display resolutions (downsamples) of all viewers to match the current viewer.
<i>4224</i>&nbsp;		 * This uses calibrated pixel size information if available.
<i>4225</i>&nbsp;		 */
<i>4226</i>&nbsp;		public void matchResolutions() {
<b class="nc"><i>4227</i>&nbsp;			var viewer = getViewer();</b>
<b class="nc"><i>4228</i>&nbsp;			var activeViewers = getViewers().stream().filter(v -&gt; v.hasServer()).collect(Collectors.toList());</b>
<b class="nc"><i>4229</i>&nbsp;			if (activeViewers.size() &lt;= 1 || !viewer.hasServer())</b>
<b class="nc"><i>4230</i>&nbsp;				return;</b>
<b class="nc"><i>4231</i>&nbsp;			var cal = viewer.getServer().getPixelCalibration();</b>
<b class="nc"><i>4232</i>&nbsp;			double pixelSize = cal.getAveragedPixelSize().doubleValue();</b>
<b class="nc"><i>4233</i>&nbsp;			double downsample = viewer.getDownsampleFactor();</b>
<b class="nc"><i>4234</i>&nbsp;			for (var temp : activeViewers) {</b>
<b class="nc"><i>4235</i>&nbsp;				if (temp == viewer)</b>
<b class="nc"><i>4236</i>&nbsp;					continue;</b>
<b class="nc"><i>4237</i>&nbsp;				var cal2 = temp.getServer().getPixelCalibration();</b>
<i>4238</i>&nbsp;				double newDownsample;
<b class="nc"><i>4239</i>&nbsp;				double tempPixelSize = cal2.getAveragedPixelSize().doubleValue();</b>
<b class="nc"><i>4240</i>&nbsp;				if (Double.isFinite(tempPixelSize) &amp;&amp; Double.isFinite(pixelSize) &amp;&amp; cal2.getPixelWidthUnit().equals(cal.getPixelWidthUnit()) &amp;&amp; cal2.getPixelHeightUnit().equals(cal.getPixelHeightUnit())) {</b>
<b class="nc"><i>4241</i>&nbsp;					newDownsample = (pixelSize / tempPixelSize) * downsample;</b>
<i>4242</i>&nbsp;				} else {
<b class="nc"><i>4243</i>&nbsp;					newDownsample = downsample;</b>
<i>4244</i>&nbsp;				}
<b class="nc"><i>4245</i>&nbsp;				temp.setDownsampleFactor(newDownsample);</b>
<b class="nc"><i>4246</i>&nbsp;			}</b>
<b class="nc"><i>4247</i>&nbsp;		}</b>
<i>4248</i>&nbsp;		
<i>4249</i>&nbsp;		private void setActiveViewer(final QuPathViewerPlus viewer) {
<b class="fc"><i>4250</i>&nbsp;			QuPathViewerPlus previousActiveViewer = getActiveViewer();</b>
<b class="fc"><i>4251</i>&nbsp;			if (previousActiveViewer == viewer)</b>
<b class="nc"><i>4252</i>&nbsp;				return;</b>
<i>4253</i>&nbsp;			
<b class="fc"><i>4254</i>&nbsp;			ImageData&lt;BufferedImage&gt; imageDataOld = getImageData();</b>
<b class="fc"><i>4255</i>&nbsp;			ImageData&lt;BufferedImage&gt; imageDataNew = viewer == null ? null : viewer.getImageData();</b>
<b class="fc"><i>4256</i>&nbsp;			if (previousActiveViewer != null) {</b>
<b class="nc"><i>4257</i>&nbsp;				previousActiveViewer.setBorderColor(null);</b>
<i>4258</i>&nbsp;//				activeViewer.setBorder(BorderFactory.createLineBorder(colorTransparent, borderWidth));
<i>4259</i>&nbsp;//				activeViewer.setBorder(null);
<b class="nc"><i>4260</i>&nbsp;				deactivateTools(previousActiveViewer);</b>
<i>4261</i>&nbsp;				
<i>4262</i>&nbsp;				// Grab reference to the current annotation, if there is one
<b class="nc"><i>4263</i>&nbsp;				PathObject pathObjectSelected = previousActiveViewer.getSelectedObject();</b>
<b class="nc"><i>4264</i>&nbsp;				if (pathObjectSelected instanceof PathAnnotationObject) {</b>
<b class="nc"><i>4265</i>&nbsp;					lastAnnotationObject = pathObjectSelected;					</b>
<i>4266</i>&nbsp;				}
<i>4267</i>&nbsp;			}
<b class="fc"><i>4268</i>&nbsp;			this.activeViewerProperty.set(viewer);</b>
<b class="fc"><i>4269</i>&nbsp;			lastX = Double.NaN;</b>
<b class="fc"><i>4270</i>&nbsp;			lastY = Double.NaN;</b>
<b class="fc"><i>4271</i>&nbsp;			lastDownsample = Double.NaN;</b>
<b class="fc"><i>4272</i>&nbsp;			lastRotation = Double.NaN;</b>
<b class="fc"><i>4273</i>&nbsp;			if (viewer != null) {</b>
<i>4274</i>&nbsp;//				activeViewer.getView().setBorder(null);
<b class="fc"><i>4275</i>&nbsp;				viewer.setBorderColor(colorBorder);</b>
<i>4276</i>&nbsp;//				activeViewer.setBorder(BorderFactory.createLineBorder(colorBorder, borderWidth));
<b class="fc"><i>4277</i>&nbsp;				activateTools(viewer);</b>
<i>4278</i>&nbsp;//				QuPathGUI qupath = QuPathGUI.this; // New to me... http://stackoverflow.com/questions/1816458/getting-hold-of-the-outer-class-object-from-the-inner-class-object
<i>4279</i>&nbsp;//				if (qupath != null)
<i>4280</i>&nbsp;//					qupath.imageDataChanged(null, imageDataOld, imageDataNew);
<i>4281</i>&nbsp;				
<b class="fc"><i>4282</i>&nbsp;				if (viewer.getServer() != null) {</b>
<b class="nc"><i>4283</i>&nbsp;					lastX = viewer.getCenterPixelX();</b>
<b class="nc"><i>4284</i>&nbsp;					lastY = viewer.getCenterPixelY();</b>
<b class="nc"><i>4285</i>&nbsp;					lastDownsample = viewer.getDownsampleFactor();</b>
<b class="nc"><i>4286</i>&nbsp;					lastRotation = viewer.getRotation();</b>
<i>4287</i>&nbsp;				}
<i>4288</i>&nbsp;				
<b class="fc"><i>4289</i>&nbsp;				updateMagnificationString();</b>
<i>4290</i>&nbsp;
<i>4291</i>&nbsp;			}
<b class="fc"><i>4292</i>&nbsp;			logger.debug(&quot;Active viewer set to {}&quot;, viewer);</b>
<b class="fc"><i>4293</i>&nbsp;			fireImageDataChangedEvent(imageDataOld, imageDataNew);</b>
<b class="fc"><i>4294</i>&nbsp;		}</b>
<i>4295</i>&nbsp;		
<i>4296</i>&nbsp;		public QuPathViewerPlus getActiveViewer() {
<b class="fc"><i>4297</i>&nbsp;			return activeViewerProperty.get();</b>
<i>4298</i>&nbsp;		}
<i>4299</i>&nbsp;		
<i>4300</i>&nbsp;		public ReadOnlyObjectProperty&lt;QuPathViewerPlus&gt; activeViewerProperty() {
<b class="fc"><i>4301</i>&nbsp;			return activeViewerProperty;</b>
<i>4302</i>&nbsp;		}
<i>4303</i>&nbsp;		
<i>4304</i>&nbsp;		public Node getNode() {
<b class="fc"><i>4305</i>&nbsp;			return splitPaneGrid.getMainSplitPane();</b>
<i>4306</i>&nbsp;		}
<i>4307</i>&nbsp;		
<i>4308</i>&nbsp;		
<i>4309</i>&nbsp;		
<i>4310</i>&nbsp;		/**
<i>4311</i>&nbsp;		 * Create a viewer, adding it to the stored array but not adding it to any component (which is left up to the calling code to handle)
<i>4312</i>&nbsp;		 * @return
<i>4313</i>&nbsp;		 */
<i>4314</i>&nbsp;		protected QuPathViewerPlus createViewer() {
<b class="nc"><i>4315</i>&nbsp;			QuPathViewerPlus viewerNew = new QuPathViewerPlus(null, imageRegionStore, overlayOptions, viewerDisplayOptions);</b>
<b class="nc"><i>4316</i>&nbsp;			setupViewer(viewerNew);</b>
<b class="nc"><i>4317</i>&nbsp;			viewerNew.addViewerListener(this);</b>
<b class="nc"><i>4318</i>&nbsp;			viewers.add(viewerNew);</b>
<b class="nc"><i>4319</i>&nbsp;			return viewerNew;</b>
<i>4320</i>&nbsp;		}
<i>4321</i>&nbsp;		
<i>4322</i>&nbsp;		
<i>4323</i>&nbsp;		SplitPane getAncestorSplitPane(Node node) {
<b class="nc"><i>4324</i>&nbsp;			while (node != null &amp;&amp; !(node instanceof SplitPane))</b>
<b class="nc"><i>4325</i>&nbsp;				node = node.getParent();</b>
<b class="nc"><i>4326</i>&nbsp;			return (SplitPane)node;</b>
<i>4327</i>&nbsp;		}
<i>4328</i>&nbsp;		
<i>4329</i>&nbsp;		
<i>4330</i>&nbsp;		public void removeViewerRow(final QuPathViewerPlus viewer) {
<i>4331</i>&nbsp;//			if (viewer.getServer() != null)
<i>4332</i>&nbsp;//				System.err.println(viewer.getServer().getShortServerName());
<i>4333</i>&nbsp;			// Note: These are the internal row numbers... these don&#39;t necessarily match with the displayed row (?)
<b class="nc"><i>4334</i>&nbsp;			int row = splitPaneGrid.getRow(viewer.getView());</b>
<b class="nc"><i>4335</i>&nbsp; 			if (row &lt; 0) {</b>
<i>4336</i>&nbsp;				// Shouldn&#39;t occur...
<b class="nc"><i>4337</i>&nbsp;				Dialogs.showErrorMessage(&quot;Multiview error&quot;, &quot;Cannot find &quot; + viewer + &quot; in the grid!&quot;);</b>
<b class="nc"><i>4338</i>&nbsp;				return;</b>
<i>4339</i>&nbsp;			}
<b class="nc"><i>4340</i>&nbsp;			int nOpen = splitPaneGrid.countOpenViewersForRow(row);</b>
<b class="nc"><i>4341</i>&nbsp;			if (nOpen &gt; 0) {</b>
<b class="nc"><i>4342</i>&nbsp;				Dialogs.showErrorMessage(&quot;Close row error&quot;, &quot;Please close all open viewers in selected row, then try again&quot;);</b>
<i>4343</i>&nbsp;//				DisplayHelpers.showErrorMessage(&quot;Close row error&quot;, &quot;Please close all open viewers in row &quot; + row + &quot;, then try again&quot;);
<b class="nc"><i>4344</i>&nbsp;				return;</b>
<i>4345</i>&nbsp;			}
<b class="nc"><i>4346</i>&nbsp;			splitPaneGrid.removeRow(row);</b>
<b class="nc"><i>4347</i>&nbsp;			splitPaneGrid.resetGridSize();</b>
<i>4348</i>&nbsp;			// Make sure the viewer list is up-to-date
<b class="nc"><i>4349</i>&nbsp;			refreshViewerList();</b>
<b class="nc"><i>4350</i>&nbsp;		}</b>
<i>4351</i>&nbsp;		
<i>4352</i>&nbsp;		
<i>4353</i>&nbsp;		/**
<i>4354</i>&nbsp;		 * Check all viewers to see if they are associated with a scene, and remove them from the list if not.
<i>4355</i>&nbsp;		 */
<i>4356</i>&nbsp;		private void refreshViewerList() {
<i>4357</i>&nbsp;			// Remove viewers from the list if they aren&#39;t associated with anything
<i>4358</i>&nbsp;			// Easiest way is to check for a scene
<b class="nc"><i>4359</i>&nbsp;			Iterator&lt;? extends QuPathViewer&gt; iter = viewers.iterator();</b>
<b class="nc"><i>4360</i>&nbsp;			while (iter.hasNext()) {</b>
<b class="nc"><i>4361</i>&nbsp;				if (iter.next().getView().getScene() == null)</b>
<b class="nc"><i>4362</i>&nbsp;					iter.remove();</b>
<i>4363</i>&nbsp;			}
<b class="nc"><i>4364</i>&nbsp;		}</b>
<i>4365</i>&nbsp;		
<i>4366</i>&nbsp;		
<i>4367</i>&nbsp;		/**
<i>4368</i>&nbsp;		 * Close the image within a viewer, prompting to save changes if necessary.
<i>4369</i>&nbsp;		 * 
<i>4370</i>&nbsp;		 * @param viewer
<i>4371</i>&nbsp;		 * @return True if the viewer no longer contains an open image (either because it never did contain one, or 
<i>4372</i>&nbsp;		 * the image was successfully closed), false otherwise (e.g. if the user thwarted the close request)
<i>4373</i>&nbsp;		 */
<i>4374</i>&nbsp;		public boolean closeViewer(final QuPathViewer viewer) {
<b class="nc"><i>4375</i>&nbsp;			return closeViewer(&quot;Save changes&quot;, viewer);</b>
<i>4376</i>&nbsp;		}
<i>4377</i>&nbsp;		
<i>4378</i>&nbsp;		/**
<i>4379</i>&nbsp;		 * Close the image within a viewer, prompting to save changes if necessary.
<i>4380</i>&nbsp;		 * 
<i>4381</i>&nbsp;		 * @param dialogTitle Name to use within any displayed dialog box.
<i>4382</i>&nbsp;		 * @param viewer
<i>4383</i>&nbsp;		 * @return True if the viewer no longer contains an open image (either because it never did contain one, or 
<i>4384</i>&nbsp;		 * the image was successfully closed), false otherwise (e.g. if the user thwarted the close request)
<i>4385</i>&nbsp;		 */
<i>4386</i>&nbsp;		public boolean closeViewer(final String dialogTitle, final QuPathViewer viewer) {
<b class="fc"><i>4387</i>&nbsp;			ImageData&lt;BufferedImage&gt; imageData = viewer.getImageData();</b>
<b class="fc"><i>4388</i>&nbsp;			if (imageData == null)</b>
<b class="nc"><i>4389</i>&nbsp;				return true;</b>
<i>4390</i>&nbsp;			// Deal with saving, if necessary
<b class="fc"><i>4391</i>&nbsp;			if (imageData.isChanged()) {</b>
<b class="fc"><i>4392</i>&nbsp;				if (!promptToSaveChangesOrCancel(dialogTitle, imageData))</b>
<b class="nc"><i>4393</i>&nbsp;					return false;</b>
<i>4394</i>&nbsp;			}
<b class="fc"><i>4395</i>&nbsp;			viewer.setImageData(null);</b>
<b class="fc"><i>4396</i>&nbsp;			return true;</b>
<i>4397</i>&nbsp;		}
<i>4398</i>&nbsp;		
<i>4399</i>&nbsp;		
<i>4400</i>&nbsp;		
<i>4401</i>&nbsp;		public void removeViewerColumn(final QuPathViewerPlus viewer) {
<b class="nc"><i>4402</i>&nbsp;			int col = splitPaneGrid.getColumn(viewer.getView());</b>
<b class="nc"><i>4403</i>&nbsp;			if (col &lt; 0) {</b>
<i>4404</i>&nbsp;				// Shouldn&#39;t occur...
<b class="nc"><i>4405</i>&nbsp;				Dialogs.showErrorMessage(&quot;Multiview error&quot;, &quot;Cannot find &quot; + viewer + &quot; in the grid!&quot;);</b>
<b class="nc"><i>4406</i>&nbsp;				return;</b>
<i>4407</i>&nbsp;			}
<b class="nc"><i>4408</i>&nbsp;			int nOpen = splitPaneGrid.countOpenViewersForColumn(col);</b>
<b class="nc"><i>4409</i>&nbsp;			if (nOpen &gt; 0) {</b>
<b class="nc"><i>4410</i>&nbsp;				Dialogs.showErrorMessage(&quot;Close column error&quot;, &quot;Please close all open viewers in selected column, then try again&quot;);</b>
<i>4411</i>&nbsp;//				DisplayHelpers.showErrorMessage(&quot;Close column error&quot;, &quot;Please close all open viewers in column &quot; + col + &quot;, then try again&quot;);
<b class="nc"><i>4412</i>&nbsp;				return;</b>
<i>4413</i>&nbsp;			}
<b class="nc"><i>4414</i>&nbsp;			splitPaneGrid.removeColumn(col);</b>
<b class="nc"><i>4415</i>&nbsp;			splitPaneGrid.resetGridSize();</b>
<i>4416</i>&nbsp;			// Make sure the viewer list is up-to-date
<b class="nc"><i>4417</i>&nbsp;			refreshViewerList();</b>
<b class="nc"><i>4418</i>&nbsp;		}</b>
<i>4419</i>&nbsp;		
<i>4420</i>&nbsp;		
<i>4421</i>&nbsp;		public void addRow(final QuPathViewerPlus viewer) {
<b class="nc"><i>4422</i>&nbsp;			splitViewer(viewer, false);</b>
<b class="nc"><i>4423</i>&nbsp;			splitPaneGrid.resetGridSize();</b>
<b class="nc"><i>4424</i>&nbsp;		}</b>
<i>4425</i>&nbsp;
<i>4426</i>&nbsp;		public void addColumn(final QuPathViewerPlus viewer) {
<b class="nc"><i>4427</i>&nbsp;			splitViewer(viewer, true);</b>
<b class="nc"><i>4428</i>&nbsp;			splitPaneGrid.resetGridSize();</b>
<b class="nc"><i>4429</i>&nbsp;		}</b>
<i>4430</i>&nbsp;
<i>4431</i>&nbsp;		
<i>4432</i>&nbsp;		public void splitViewer(final QuPathViewerPlus viewer, final boolean splitVertical) {
<b class="nc"><i>4433</i>&nbsp;			if (!viewers.contains(viewer))</b>
<b class="nc"><i>4434</i>&nbsp;				return;</b>
<i>4435</i>&nbsp;			
<b class="nc"><i>4436</i>&nbsp;			if (splitVertical) {</b>
<b class="nc"><i>4437</i>&nbsp;				splitPaneGrid.addColumn(splitPaneGrid.getColumn(viewer.getView()));</b>
<i>4438</i>&nbsp;			} else {
<b class="nc"><i>4439</i>&nbsp;				splitPaneGrid.addRow(splitPaneGrid.getRow(viewer.getView()));</b>
<i>4440</i>&nbsp;			}
<b class="nc"><i>4441</i>&nbsp;		}</b>
<i>4442</i>&nbsp;		
<i>4443</i>&nbsp;		/**
<i>4444</i>&nbsp;		 * Remove viewer from display
<i>4445</i>&nbsp;		 * @param viewer
<i>4446</i>&nbsp;		 * @return 
<i>4447</i>&nbsp;		 */
<i>4448</i>&nbsp;		public boolean removeViewer(QuPathViewer viewer) {
<b class="nc"><i>4449</i>&nbsp;			if (viewers.size() == 1) {</b>
<b class="nc"><i>4450</i>&nbsp;				logger.error(&quot;Cannot remove last viewer!&quot;);</b>
<b class="nc"><i>4451</i>&nbsp;				return false;</b>
<i>4452</i>&nbsp;			}
<b class="nc"><i>4453</i>&nbsp;			return true;</b>
<i>4454</i>&nbsp;		}
<i>4455</i>&nbsp;		
<i>4456</i>&nbsp;		
<i>4457</i>&nbsp;		public void resetGridSize() {
<b class="nc"><i>4458</i>&nbsp;			splitPaneGrid.resetGridSize();</b>
<b class="nc"><i>4459</i>&nbsp;		}</b>
<i>4460</i>&nbsp;		
<i>4461</i>&nbsp;		
<i>4462</i>&nbsp;		public void repaintViewers() {
<b class="nc"><i>4463</i>&nbsp;			for (QuPathViewer v : viewers)</b>
<b class="nc"><i>4464</i>&nbsp;				v.repaint();</b>
<b class="nc"><i>4465</i>&nbsp;		}</b>
<i>4466</i>&nbsp;
<i>4467</i>&nbsp;		@Override
<i>4468</i>&nbsp;		public void imageDataChanged(QuPathViewer viewer, ImageData&lt;BufferedImage&gt; imageDataOld, ImageData&lt;BufferedImage&gt; imageDataNew) {
<b class="fc"><i>4469</i>&nbsp;			if (viewer != null &amp;&amp; viewer == getActiveViewer()) {</b>
<b class="fc"><i>4470</i>&nbsp;				if (viewer.getServer() != null) {</b>
<i>4471</i>&nbsp;					// Setting these to NaN prevents unexpected jumping when a new image is opened
<b class="fc"><i>4472</i>&nbsp;					lastX = Double.NaN;</b>
<b class="fc"><i>4473</i>&nbsp;					lastY = Double.NaN;</b>
<b class="fc"><i>4474</i>&nbsp;					lastDownsample = Double.NaN;</b>
<b class="fc"><i>4475</i>&nbsp;					lastRotation = Double.NaN;</b>
<i>4476</i>&nbsp;				}
<b class="fc"><i>4477</i>&nbsp;				fireImageDataChangedEvent(imageDataOld, viewer.getImageData());</b>
<i>4478</i>&nbsp;			}
<b class="fc"><i>4479</i>&nbsp;		}</b>
<i>4480</i>&nbsp;
<i>4481</i>&nbsp;		@Override
<i>4482</i>&nbsp;		public void visibleRegionChanged(QuPathViewer viewer, Shape shape) {
<b class="fc"><i>4483</i>&nbsp;			if (viewer == null)</b>
<b class="nc"><i>4484</i>&nbsp;				return;</b>
<b class="fc"><i>4485</i>&nbsp;			if (viewer != getActiveViewer() || viewer.isImageDataChanging() || zoomToFit.get()) {</b>
<i>4486</i>&nbsp;//				// Only change downsamples for non-active viewer
<i>4487</i>&nbsp;//				double downsample = viewer.getDownsampleFactor();
<i>4488</i>&nbsp;//				if (synchronizeViewers) {
<i>4489</i>&nbsp;//					for (QuPathViewer v : viewers) {
<i>4490</i>&nbsp;//						double oldDownsample = v.getDownsampleFactor();
<i>4491</i>&nbsp;//						if (!GeneralTools.almostTheSame(downsample, oldDownsample, 0.0001)) {
<i>4492</i>&nbsp;//							v.setDownsampleFactor(downsample);
<i>4493</i>&nbsp;//						}
<i>4494</i>&nbsp;//					}
<i>4495</i>&nbsp;//				}
<b class="fc"><i>4496</i>&nbsp;				return;</b>
<i>4497</i>&nbsp;			} else {
<i>4498</i>&nbsp;				// Update magnification info
<b class="nc"><i>4499</i>&nbsp;				updateMagnificationString();</b>
<i>4500</i>&nbsp;			}
<i>4501</i>&nbsp;			
<b class="nc"><i>4502</i>&nbsp;			QuPathViewerPlus activeViewer = getActiveViewer();</b>
<b class="nc"><i>4503</i>&nbsp;			double x = activeViewer.getCenterPixelX();</b>
<b class="nc"><i>4504</i>&nbsp;			double y = activeViewer.getCenterPixelY();</b>
<b class="nc"><i>4505</i>&nbsp;			double rotation = activeViewer.getRotation();</b>
<b class="nc"><i>4506</i>&nbsp;			double dx = Double.NaN, dy = Double.NaN, dr = Double.NaN;</b>
<i>4507</i>&nbsp;			
<b class="nc"><i>4508</i>&nbsp;			double downsample = viewer.getDownsampleFactor();</b>
<b class="nc"><i>4509</i>&nbsp;			double relativeDownsample = viewer.getDownsampleFactor() / lastDownsample;</b>
<i>4510</i>&nbsp;			
<i>4511</i>&nbsp;			// Shift as required, assuming we aren&#39;t aligning cores
<i>4512</i>&nbsp;//			if (!aligningCores) {
<i>4513</i>&nbsp;//			synchronizeViewers = true;
<b class="nc"><i>4514</i>&nbsp;			if (synchronizeViewers.get()) {</b>
<b class="nc"><i>4515</i>&nbsp;				if (!Double.isNaN(lastX + lastY)) {</b>
<b class="nc"><i>4516</i>&nbsp;					dx = x - lastX;</b>
<b class="nc"><i>4517</i>&nbsp;					dy = y - lastY;</b>
<b class="nc"><i>4518</i>&nbsp;					dr = rotation - lastRotation;</b>
<i>4519</i>&nbsp;				}
<i>4520</i>&nbsp;				
<b class="nc"><i>4521</i>&nbsp;				for (QuPathViewer v : viewers) {</b>
<b class="nc"><i>4522</i>&nbsp;					if (v == viewer)</b>
<b class="nc"><i>4523</i>&nbsp;						continue;</b>
<b class="nc"><i>4524</i>&nbsp;					if (!Double.isNaN(relativeDownsample))</b>
<b class="nc"><i>4525</i>&nbsp;						v.setDownsampleFactor(v.getDownsampleFactor() * relativeDownsample, -1, -1, false);</b>
<b class="nc"><i>4526</i>&nbsp;					if (!Double.isNaN(dr) &amp;&amp; dr != 0)</b>
<b class="nc"><i>4527</i>&nbsp;						v.setRotation(v.getRotation() + dr);</b>
<i>4528</i>&nbsp;					
<i>4529</i>&nbsp;					// Shift as required
<b class="nc"><i>4530</i>&nbsp;					double downsampleRatio = v.getDownsampleFactor() / downsample;</b>
<b class="nc"><i>4531</i>&nbsp;					if (!Double.isNaN(dx) &amp;&amp; !Double.isNaN(downsampleRatio)) {</b>
<b class="nc"><i>4532</i>&nbsp;						v.setCenterPixelLocation(v.getCenterPixelX() + dx*downsampleRatio, v.getCenterPixelY() + dy*downsampleRatio);</b>
<i>4533</i>&nbsp;					}
<b class="nc"><i>4534</i>&nbsp;				}</b>
<i>4535</i>&nbsp;			}
<i>4536</i>&nbsp;			
<b class="nc"><i>4537</i>&nbsp;			lastX = x;</b>
<b class="nc"><i>4538</i>&nbsp;			lastY = y;</b>
<b class="nc"><i>4539</i>&nbsp;			lastDownsample = downsample;</b>
<b class="nc"><i>4540</i>&nbsp;			lastRotation = rotation;</b>
<b class="nc"><i>4541</i>&nbsp;		}</b>
<i>4542</i>&nbsp;		
<i>4543</i>&nbsp;		
<i>4544</i>&nbsp;		public boolean getSynchronizeViewers() {
<b class="nc"><i>4545</i>&nbsp;			return synchronizeViewers.get();</b>
<i>4546</i>&nbsp;		}
<i>4547</i>&nbsp;		
<i>4548</i>&nbsp;		public void setSynchronizeViewers(final boolean synchronizeViewers) {
<b class="nc"><i>4549</i>&nbsp;			this.synchronizeViewers.set(synchronizeViewers);</b>
<b class="nc"><i>4550</i>&nbsp;		}</b>
<i>4551</i>&nbsp;		
<i>4552</i>&nbsp;		public ReadOnlyBooleanProperty synchronizeViewersProperty() {
<b class="fc"><i>4553</i>&nbsp;			return synchronizeViewers;</b>
<i>4554</i>&nbsp;		}
<i>4555</i>&nbsp;		
<i>4556</i>&nbsp;
<i>4557</i>&nbsp;		@Override
<i>4558</i>&nbsp;		public void selectedObjectChanged(QuPathViewer viewer, PathObject pathObjectSelected) {
<i>4559</i>&nbsp;			// Store any annotation ROIs, which might need to be transferred
<b class="fc"><i>4560</i>&nbsp;			if (pathObjectSelected instanceof PathAnnotationObject) {</b>
<b class="nc"><i>4561</i>&nbsp;				lastAnnotationObject = pathObjectSelected;</b>
<b class="nc"><i>4562</i>&nbsp;				return;</b>
<i>4563</i>&nbsp;			}
<i>4564</i>&nbsp;			
<i>4565</i>&nbsp;			// Don&#39;t handle unselected viewers
<b class="fc"><i>4566</i>&nbsp;			if (viewer != getActiveViewer()) {</b>
<b class="nc"><i>4567</i>&nbsp;				return;</b>
<i>4568</i>&nbsp;			}
<i>4569</i>&nbsp;			
<i>4570</i>&nbsp;			// Synchronize TMA cores
<b class="fc"><i>4571</i>&nbsp;			if (!(pathObjectSelected instanceof TMACoreObject))</b>
<b class="fc"><i>4572</i>&nbsp;				return;</b>
<i>4573</i>&nbsp;			
<i>4574</i>&nbsp;			// Thwart the upcoming region shift
<b class="nc"><i>4575</i>&nbsp;			lastX = Double.NaN;</b>
<b class="nc"><i>4576</i>&nbsp;			lastY = Double.NaN;</b>
<b class="nc"><i>4577</i>&nbsp;			lastDownsample = Double.NaN;</b>
<b class="nc"><i>4578</i>&nbsp;			lastRotation = Double.NaN;</b>
<i>4579</i>&nbsp;			
<i>4580</i>&nbsp;//			aligningCores = true;
<b class="nc"><i>4581</i>&nbsp;			String coreName = ((TMACoreObject)pathObjectSelected).getName();</b>
<b class="nc"><i>4582</i>&nbsp;			for (QuPathViewer v : viewers) {</b>
<b class="nc"><i>4583</i>&nbsp;				if (v == viewer)</b>
<b class="nc"><i>4584</i>&nbsp;					continue;</b>
<b class="nc"><i>4585</i>&nbsp;				PathObjectHierarchy hierarchy = v.getHierarchy();</b>
<b class="nc"><i>4586</i>&nbsp;				if (hierarchy == null || hierarchy.getTMAGrid() == null)</b>
<b class="nc"><i>4587</i>&nbsp;					continue;</b>
<i>4588</i>&nbsp;				
<b class="nc"><i>4589</i>&nbsp;				TMAGrid tmaGrid = hierarchy.getTMAGrid();</b>
<b class="nc"><i>4590</i>&nbsp;				TMACoreObject core = tmaGrid.getTMACore(coreName);</b>
<b class="nc"><i>4591</i>&nbsp;				if (core != null) {</b>
<b class="nc"><i>4592</i>&nbsp;					v.setSelectedObject(core);</b>
<b class="nc"><i>4593</i>&nbsp;					double cx = core.getROI().getCentroidX();</b>
<b class="nc"><i>4594</i>&nbsp;					double cy = core.getROI().getCentroidY();</b>
<b class="nc"><i>4595</i>&nbsp;					v.setCenterPixelLocation(cx, cy);</b>
<i>4596</i>&nbsp;				}
<b class="nc"><i>4597</i>&nbsp;			}</b>
<b class="nc"><i>4598</i>&nbsp;		}</b>
<i>4599</i>&nbsp;		
<i>4600</i>&nbsp;		
<i>4601</i>&nbsp;		
<i>4602</i>&nbsp;		public boolean applyLastAnnotationToActiveViewer() {
<b class="nc"><i>4603</i>&nbsp;			if (lastAnnotationObject == null) {</b>
<b class="nc"><i>4604</i>&nbsp;				logger.info(&quot;No annotation object to copy&quot;);</b>
<b class="nc"><i>4605</i>&nbsp;				return false;</b>
<i>4606</i>&nbsp;			}
<i>4607</i>&nbsp;			
<b class="nc"><i>4608</i>&nbsp;			QuPathViewerPlus activeViewer = getActiveViewer();</b>
<b class="nc"><i>4609</i>&nbsp;			if (activeViewer == null || activeViewer.getHierarchy() == null) {</b>
<b class="nc"><i>4610</i>&nbsp;				logger.info(&quot;No active viewer available&quot;);</b>
<b class="nc"><i>4611</i>&nbsp;				return false;</b>
<i>4612</i>&nbsp;			}
<i>4613</i>&nbsp;			
<b class="nc"><i>4614</i>&nbsp;			PathObjectHierarchy hierarchy = activeViewer.getHierarchy();</b>
<b class="nc"><i>4615</i>&nbsp;			if (PathObjectTools.hierarchyContainsObject(hierarchy, lastAnnotationObject)) {</b>
<b class="nc"><i>4616</i>&nbsp;				logger.info(&quot;Hierarchy already contains annotation object!&quot;);</b>
<b class="nc"><i>4617</i>&nbsp;				return false;</b>
<i>4618</i>&nbsp;			}
<i>4619</i>&nbsp;			
<b class="nc"><i>4620</i>&nbsp;			ROI roi = lastAnnotationObject.getROI().duplicate();</b>
<i>4621</i>&nbsp;			
<i>4622</i>&nbsp;			// If we are within a TMA core, try to apply any required translations
<b class="nc"><i>4623</i>&nbsp;			TMACoreObject coreNewParent = null;</b>
<b class="nc"><i>4624</i>&nbsp;			if (hierarchy.getTMAGrid() != null) {</b>
<b class="nc"><i>4625</i>&nbsp;				TMACoreObject coreParent = null;</b>
<b class="nc"><i>4626</i>&nbsp;				PathObject parent = lastAnnotationObject.getParent();</b>
<b class="nc"><i>4627</i>&nbsp;				while (parent != null) {</b>
<b class="nc"><i>4628</i>&nbsp;					if (parent instanceof TMACoreObject) {</b>
<b class="nc"><i>4629</i>&nbsp;						coreParent = (TMACoreObject)parent;</b>
<b class="nc"><i>4630</i>&nbsp;						break;</b>
<i>4631</i>&nbsp;					} else
<b class="nc"><i>4632</i>&nbsp;						parent = parent.getParent();</b>
<i>4633</i>&nbsp;				}
<b class="nc"><i>4634</i>&nbsp;				if (coreParent != null) {</b>
<b class="nc"><i>4635</i>&nbsp;					coreNewParent = hierarchy.getTMAGrid().getTMACore(coreParent.getName());</b>
<b class="nc"><i>4636</i>&nbsp;					if (coreNewParent != null) {</b>
<b class="nc"><i>4637</i>&nbsp;						double rotation = activeViewer.getRotation();</b>
<i>4638</i>&nbsp;//						if (rotation == 0) {
<b class="nc"><i>4639</i>&nbsp;							double dx = coreNewParent.getROI().getCentroidX() - coreParent.getROI().getCentroidX();</b>
<b class="nc"><i>4640</i>&nbsp;							double dy = coreNewParent.getROI().getCentroidY() - coreParent.getROI().getCentroidY();</b>
<b class="nc"><i>4641</i>&nbsp;							roi = roi.translate(dx, dy);</b>
<i>4642</i>&nbsp;							// TODO: Deal with rotations... it&#39;s a bit tricky...
<i>4643</i>&nbsp;//						} else {
<i>4644</i>&nbsp;						// TODO: Check how best to handle transferring ROIs with rotation involved
<b class="nc"><i>4645</i>&nbsp;						if (rotation != 0) {</b>
<b class="nc"><i>4646</i>&nbsp;							AffineTransform transform = new AffineTransform();</b>
<b class="nc"><i>4647</i>&nbsp;							transform.rotate(-rotation, coreNewParent.getROI().getCentroidX(), coreNewParent.getROI().getCentroidY());</b>
<b class="nc"><i>4648</i>&nbsp;							logger.info(&quot;ROTATING: &quot; + transform);</b>
<b class="nc"><i>4649</i>&nbsp;							Area area = RoiTools.getArea(roi);</b>
<b class="nc"><i>4650</i>&nbsp;							area.transform(transform);</b>
<b class="nc"><i>4651</i>&nbsp;							roi = RoiTools.getShapeROI(area, roi.getImagePlane());</b>
<i>4652</i>&nbsp;						}
<i>4653</i>&nbsp;					}
<i>4654</i>&nbsp;				}
<i>4655</i>&nbsp;			}
<i>4656</i>&nbsp;			
<i>4657</i>&nbsp;			
<b class="nc"><i>4658</i>&nbsp;			PathObject annotation = PathObjects.createAnnotationObject(roi, lastAnnotationObject.getPathClass());</b>
<i>4659</i>&nbsp;//			hierarchy.addPathObject(annotation, false);
<i>4660</i>&nbsp;			
<i>4661</i>&nbsp;//			// Make sure any core parent is set
<b class="nc"><i>4662</i>&nbsp;			hierarchy.addPathObjectBelowParent(coreNewParent, annotation, true);</b>
<i>4663</i>&nbsp;			
<b class="nc"><i>4664</i>&nbsp;			activeViewer.setSelectedObject(annotation);</b>
<b class="nc"><i>4665</i>&nbsp;			return true;</b>
<i>4666</i>&nbsp;		}
<i>4667</i>&nbsp;
<i>4668</i>&nbsp;		@Override
<i>4669</i>&nbsp;		public void viewerClosed(QuPathViewer viewer) {
<b class="nc"><i>4670</i>&nbsp;			removeViewer(viewer); // May be avoidable...?</b>
<b class="nc"><i>4671</i>&nbsp;		}</b>
<i>4672</i>&nbsp;
<i>4673</i>&nbsp;		public QuPathViewerPlus getViewer() {
<b class="nc"><i>4674</i>&nbsp;			return getActiveViewer();</b>
<i>4675</i>&nbsp;		}
<i>4676</i>&nbsp;		
<i>4677</i>&nbsp;		
<i>4678</i>&nbsp;		
<i>4679</i>&nbsp;		
<i>4680</i>&nbsp;		
<i>4681</i>&nbsp;		
<i>4682</i>&nbsp;		
<i>4683</i>&nbsp;		class SplitPaneGrid {
<i>4684</i>&nbsp;			
<b class="fc"><i>4685</i>&nbsp;			private SplitPane splitPaneMain = new SplitPane();</b>
<b class="fc"><i>4686</i>&nbsp;			private List&lt;SplitPane&gt; splitPaneRows = new ArrayList&lt;&gt;();</b>
<i>4687</i>&nbsp;			
<b class="fc"><i>4688</i>&nbsp;			SplitPaneGrid(final Node node) {</b>
<b class="fc"><i>4689</i>&nbsp;				splitPaneMain.setOrientation(Orientation.VERTICAL);</b>
<b class="fc"><i>4690</i>&nbsp;				SplitPane splitRow = new SplitPane();</b>
<b class="fc"><i>4691</i>&nbsp;				splitRow.setOrientation(Orientation.HORIZONTAL);</b>
<b class="fc"><i>4692</i>&nbsp;				splitRow.getItems().add(node);</b>
<b class="fc"><i>4693</i>&nbsp;				splitPaneRows.add(splitRow);</b>
<b class="fc"><i>4694</i>&nbsp;				splitPaneMain.getItems().add(splitRow);</b>
<b class="fc"><i>4695</i>&nbsp;			}</b>
<i>4696</i>&nbsp;			
<i>4697</i>&nbsp;			SplitPane getMainSplitPane() {
<b class="fc"><i>4698</i>&nbsp;				return splitPaneMain;</b>
<i>4699</i>&nbsp;			}
<i>4700</i>&nbsp;			
<i>4701</i>&nbsp;			
<i>4702</i>&nbsp;			void addRow(final int position) {
<b class="nc"><i>4703</i>&nbsp;				SplitPane splitRow = new SplitPane();</b>
<b class="nc"><i>4704</i>&nbsp;				splitRow.setOrientation(Orientation.HORIZONTAL);</b>
<i>4705</i>&nbsp;				
<i>4706</i>&nbsp;				// For now, we create a row with the same number of columns in every row
<i>4707</i>&nbsp;				// Create viewers &amp; bind dividers
<b class="nc"><i>4708</i>&nbsp;				splitRow.getItems().clear();</b>
<b class="nc"><i>4709</i>&nbsp;				SplitPane firstRow = splitPaneRows.get(0);</b>
<b class="nc"><i>4710</i>&nbsp;				splitRow.getItems().add(createViewer().getView());</b>
<b class="nc"><i>4711</i>&nbsp;				for (int i = 0; i &lt; firstRow.getDividers().size(); i++) {</b>
<b class="nc"><i>4712</i>&nbsp;					splitRow.getItems().add(createViewer().getView());</b>
<i>4713</i>&nbsp;//					splitRow.getDividers().get(i).positionProperty().bindBidirectional(firstRow.getDividers().get(i).positionProperty());
<i>4714</i>&nbsp;				}
<i>4715</i>&nbsp;				
<i>4716</i>&nbsp;				// Ensure the new divider takes up half the space
<b class="nc"><i>4717</i>&nbsp;				double lastDividerPosition = position == 0 ? 0 : splitPaneMain.getDividers().get(position-1).getPosition();</b>
<b class="nc"><i>4718</i>&nbsp;				double nextDividerPosition = position &gt;= splitPaneRows.size()-1 ? 1 : splitPaneMain.getDividers().get(position).getPosition();</b>
<b class="nc"><i>4719</i>&nbsp;				splitPaneRows.add(position, splitRow);</b>
<b class="nc"><i>4720</i>&nbsp;				splitPaneMain.getItems().add(position+1, splitRow);</b>
<b class="nc"><i>4721</i>&nbsp;				splitPaneMain.setDividerPosition(position, (lastDividerPosition + nextDividerPosition)/2);</b>
<i>4722</i>&nbsp;				
<b class="nc"><i>4723</i>&nbsp;				refreshDividerBindings();</b>
<b class="nc"><i>4724</i>&nbsp;			}</b>
<i>4725</i>&nbsp;			
<i>4726</i>&nbsp;			
<i>4727</i>&nbsp;			
<i>4728</i>&nbsp;			boolean removeRow(final int row) {
<b class="nc"><i>4729</i>&nbsp;				if (row &lt; 0 || row &gt;= splitPaneRows.size() || splitPaneRows.size() == 1) {</b>
<b class="nc"><i>4730</i>&nbsp;					logger.error(&quot;Cannot remove row {} from grid with {} rows&quot;, row, splitPaneRows.size());</b>
<b class="nc"><i>4731</i>&nbsp;					return false;</b>
<i>4732</i>&nbsp;				}
<b class="nc"><i>4733</i>&nbsp;				SplitPane splitPane = splitPaneRows.remove(row);</b>
<i>4734</i>&nbsp;//				// WeakHashMap should take care of this... but check anyway
<i>4735</i>&nbsp;//				for (Node node : splitPane.getItems())
<i>4736</i>&nbsp;//					viewerMap.remove(node);
<b class="nc"><i>4737</i>&nbsp;				splitPaneMain.getItems().remove(splitPane);</b>
<b class="nc"><i>4738</i>&nbsp;				refreshDividerBindings();</b>
<b class="nc"><i>4739</i>&nbsp;				return true;</b>
<i>4740</i>&nbsp;			}
<i>4741</i>&nbsp;			
<i>4742</i>&nbsp;			
<i>4743</i>&nbsp;			/**
<i>4744</i>&nbsp;			 * Restore all grid panels to be the same size
<i>4745</i>&nbsp;			 */
<i>4746</i>&nbsp;			public void resetGridSize() {
<b class="nc"><i>4747</i>&nbsp;				resetDividers(splitPaneRows.get(0)); // Because of property binding, this should be enough</b>
<b class="nc"><i>4748</i>&nbsp;				resetDividers(splitPaneMain);</b>
<b class="nc"><i>4749</i>&nbsp;			}</b>
<i>4750</i>&nbsp;			
<i>4751</i>&nbsp;			
<i>4752</i>&nbsp;			void resetDividers(final SplitPane splitPane) {
<b class="nc"><i>4753</i>&nbsp;				int n = splitPane.getItems().size();</b>
<b class="nc"><i>4754</i>&nbsp;				if (n &lt;= 1)</b>
<b class="nc"><i>4755</i>&nbsp;					return;</b>
<b class="nc"><i>4756</i>&nbsp;				if (n == 2) {</b>
<b class="nc"><i>4757</i>&nbsp;					splitPane.setDividerPosition(0, 0.5);</b>
<b class="nc"><i>4758</i>&nbsp;					return;</b>
<i>4759</i>&nbsp;				}
<b class="nc"><i>4760</i>&nbsp;				double[] positions = new double[n-1];</b>
<b class="nc"><i>4761</i>&nbsp;				for (int i = 0; i &lt; positions.length; i++)</b>
<b class="nc"><i>4762</i>&nbsp;					positions[i] = (i + 1.0) / (double)n;</b>
<b class="nc"><i>4763</i>&nbsp;				splitPane.setDividerPositions(positions);</b>
<b class="nc"><i>4764</i>&nbsp;			}</b>
<i>4765</i>&nbsp;
<i>4766</i>&nbsp;			
<i>4767</i>&nbsp;			boolean removeColumn(final int col) {
<b class="nc"><i>4768</i>&nbsp;				if (col &lt; 0 || col &gt;= nCols() || nCols() == 1) {</b>
<b class="nc"><i>4769</i>&nbsp;					logger.error(&quot;Cannot remove column {} from grid with {} columns&quot;, col, nCols());</b>
<b class="nc"><i>4770</i>&nbsp;					return false;</b>
<i>4771</i>&nbsp;				}
<b class="nc"><i>4772</i>&nbsp;				for (SplitPane splitRow : splitPaneRows) {</b>
<b class="nc"><i>4773</i>&nbsp;					splitRow.getItems().remove(col);</b>
<b class="nc"><i>4774</i>&nbsp;				}</b>
<b class="nc"><i>4775</i>&nbsp;				refreshDividerBindings();</b>
<b class="nc"><i>4776</i>&nbsp;				return true;</b>
<i>4777</i>&nbsp;			}
<i>4778</i>&nbsp;			
<i>4779</i>&nbsp;			
<i>4780</i>&nbsp;			int countOpenViewersForRow(final int row) {
<b class="nc"><i>4781</i>&nbsp;				int count = 0;</b>
<b class="nc"><i>4782</i>&nbsp;				for (QuPathViewer viewer : getViewers()) {</b>
<b class="nc"><i>4783</i>&nbsp;					if (row == getRow(viewer.getView()) &amp;&amp; viewer.hasServer())</b>
<b class="nc"><i>4784</i>&nbsp;						count++;</b>
<b class="nc"><i>4785</i>&nbsp;				}</b>
<b class="nc"><i>4786</i>&nbsp;				return count;</b>
<i>4787</i>&nbsp;			}
<i>4788</i>&nbsp;			
<i>4789</i>&nbsp;			
<i>4790</i>&nbsp;			int countOpenViewersForColumn(final int col) {
<b class="nc"><i>4791</i>&nbsp;				int count = 0;</b>
<b class="nc"><i>4792</i>&nbsp;				for (QuPathViewer viewer : getViewers()) {</b>
<b class="nc"><i>4793</i>&nbsp;					if (col == getColumn(viewer.getView()) &amp;&amp; viewer.hasServer())</b>
<b class="nc"><i>4794</i>&nbsp;						count++;</b>
<b class="nc"><i>4795</i>&nbsp;				}</b>
<b class="nc"><i>4796</i>&nbsp;				return count;				</b>
<i>4797</i>&nbsp;			}
<i>4798</i>&nbsp;
<i>4799</i>&nbsp;			
<i>4800</i>&nbsp;			/**
<i>4801</i>&nbsp;			 * Update all divider bindings so they match the first row
<i>4802</i>&nbsp;			 */
<i>4803</i>&nbsp;			void refreshDividerBindings() {
<b class="nc"><i>4804</i>&nbsp;				SplitPane firstRow = splitPaneRows.get(0);</b>
<b class="nc"><i>4805</i>&nbsp;				for (int r = 1; r &lt; splitPaneRows.size(); r++) {</b>
<b class="nc"><i>4806</i>&nbsp;					SplitPane splitRow = splitPaneRows.get(r);</b>
<b class="nc"><i>4807</i>&nbsp;					for (int c = 0; c &lt; splitRow.getDividers().size(); c++) {</b>
<b class="nc"><i>4808</i>&nbsp;						splitRow.getDividers().get(c).positionProperty().bindBidirectional(firstRow.getDividers().get(c).positionProperty());</b>
<i>4809</i>&nbsp;					}
<i>4810</i>&nbsp;				}
<b class="nc"><i>4811</i>&nbsp;			}</b>
<i>4812</i>&nbsp;			
<i>4813</i>&nbsp;			
<i>4814</i>&nbsp;			void addColumn(final int position) {
<b class="nc"><i>4815</i>&nbsp;				SplitPane firstRow = splitPaneRows.get(0);</b>
<b class="nc"><i>4816</i>&nbsp;				double lastDividerPosition = position == 0 ? 0 : firstRow.getDividers().get(position-1).getPosition();</b>
<b class="nc"><i>4817</i>&nbsp;				double nextDividerPosition = position &gt;= firstRow.getItems().size()-1 ? 1 : firstRow.getDividers().get(position).getPosition();</b>
<i>4818</i>&nbsp;				
<b class="nc"><i>4819</i>&nbsp;				firstRow.getItems().add(position+1, createViewer().getView());</b>
<b class="nc"><i>4820</i>&nbsp;				Divider firstDivider = firstRow.getDividers().get(position);</b>
<b class="nc"><i>4821</i>&nbsp;				firstDivider.setPosition((lastDividerPosition + nextDividerPosition)/2);</b>
<b class="nc"><i>4822</i>&nbsp;				for (int i = 1; i &lt; splitPaneRows.size(); i++) {</b>
<b class="nc"><i>4823</i>&nbsp;					SplitPane splitRow = splitPaneRows.get(i);</b>
<b class="nc"><i>4824</i>&nbsp;					splitRow.getItems().add(position+1, createViewer().getView());</b>
<i>4825</i>&nbsp;				}
<i>4826</i>&nbsp;				
<b class="nc"><i>4827</i>&nbsp;				refreshDividerBindings();</b>
<b class="nc"><i>4828</i>&nbsp;			}</b>
<i>4829</i>&nbsp;			
<i>4830</i>&nbsp;			
<i>4831</i>&nbsp;			public int getRow(final Node node) {
<b class="nc"><i>4832</i>&nbsp;				int count = 0;</b>
<b class="nc"><i>4833</i>&nbsp;				for (SplitPane row : splitPaneRows) {</b>
<b class="nc"><i>4834</i>&nbsp;					int ind = row.getItems().indexOf(node);</b>
<b class="nc"><i>4835</i>&nbsp;					if (ind &gt;= 0)</b>
<b class="nc"><i>4836</i>&nbsp;						return count;</b>
<b class="nc"><i>4837</i>&nbsp;					count++;</b>
<b class="nc"><i>4838</i>&nbsp;				}</b>
<b class="nc"><i>4839</i>&nbsp;				return -1;</b>
<i>4840</i>&nbsp;			}
<i>4841</i>&nbsp;
<i>4842</i>&nbsp;			public int getColumn(final Node node) {
<b class="nc"><i>4843</i>&nbsp;				for (SplitPane row : splitPaneRows) {</b>
<b class="nc"><i>4844</i>&nbsp;					int ind = row.getItems().indexOf(node);</b>
<b class="nc"><i>4845</i>&nbsp;					if (ind &gt;= 0)</b>
<b class="nc"><i>4846</i>&nbsp;						return ind;</b>
<b class="nc"><i>4847</i>&nbsp;				}</b>
<b class="nc"><i>4848</i>&nbsp;				return -1;</b>
<i>4849</i>&nbsp;			}
<i>4850</i>&nbsp;
<i>4851</i>&nbsp;			public int nRows() {
<b class="nc"><i>4852</i>&nbsp;				return splitPaneRows.size();</b>
<i>4853</i>&nbsp;			}
<i>4854</i>&nbsp;
<i>4855</i>&nbsp;			public int nCols() {
<b class="nc"><i>4856</i>&nbsp;				return splitPaneRows.get(0).getDividers().size() + 1;</b>
<i>4857</i>&nbsp;			}
<i>4858</i>&nbsp;			
<i>4859</i>&nbsp;		}
<i>4860</i>&nbsp;		
<i>4861</i>&nbsp;		
<i>4862</i>&nbsp;	}
<i>4863</i>&nbsp;
<i>4864</i>&nbsp;	
<i>4865</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2021-01-25 09:46</div>
</div>
</body>
</html>
