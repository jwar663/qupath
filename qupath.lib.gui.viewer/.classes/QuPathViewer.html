


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: QuPathViewer</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">qupath.lib.gui.viewer</a> ]
</div>

<h1>Coverage Summary for Class: QuPathViewer (qupath.lib.gui.viewer)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">QuPathViewer</td>
<td class="coverageStat">
  <span class="percent">
    55.2%
  </span>
  <span class="absValue">
    (85/ 154)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.3%
  </span>
  <span class="absValue">
    (585/ 1021)
  </span>
</td>
</tr>
  <tr>
    <td class="name">QuPathViewer$1</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$4</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$KeyEventFilter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (1/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$KeyEventHandler</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2.4%
  </span>
  <span class="absValue">
    (3/ 124)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$ListenerHandler</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$ListenerManager</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (6/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$ObservableListenerHandler</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$ObservableListListenerHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">QuPathViewer$ObservableValueListenerHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    53%
  </span>
  <span class="absValue">
    (98/ 185)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50.3%
  </span>
  <span class="absValue">
    (609/ 1211)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*-
<i>2</i>&nbsp; * #%L
<i>3</i>&nbsp; * This file is part of QuPath.
<i>4</i>&nbsp; * %%
<i>5</i>&nbsp; * Copyright (C) 2014 - 2016 The Queen&#39;s University of Belfast, Northern Ireland
<i>6</i>&nbsp; * Contact: IP Management (ipmanagement@qub.ac.uk)
<i>7</i>&nbsp; * Copyright (C) 2018 - 2020 QuPath developers, The University of Edinburgh
<i>8</i>&nbsp; * %%
<i>9</i>&nbsp; * QuPath is free software: you can redistribute it and/or modify
<i>10</i>&nbsp; * it under the terms of the GNU General Public License as
<i>11</i>&nbsp; * published by the Free Software Foundation, either version 3 of the
<i>12</i>&nbsp; * License, or (at your option) any later version.
<i>13</i>&nbsp; * 
<i>14</i>&nbsp; * QuPath is distributed in the hope that it will be useful,
<i>15</i>&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
<i>16</i>&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<i>17</i>&nbsp; * GNU General Public License for more details.
<i>18</i>&nbsp; * 
<i>19</i>&nbsp; * You should have received a copy of the GNU General Public License 
<i>20</i>&nbsp; * along with QuPath.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
<i>21</i>&nbsp; * #L%
<i>22</i>&nbsp; */
<i>23</i>&nbsp;
<i>24</i>&nbsp;package qupath.lib.gui.viewer;
<i>25</i>&nbsp;
<i>26</i>&nbsp;import java.awt.AlphaComposite;
<i>27</i>&nbsp;import java.awt.Color;
<i>28</i>&nbsp;import java.awt.Composite;
<i>29</i>&nbsp;import java.awt.Graphics;
<i>30</i>&nbsp;import java.awt.Graphics2D;
<i>31</i>&nbsp;import java.awt.Image;
<i>32</i>&nbsp;import java.awt.Rectangle;
<i>33</i>&nbsp;import java.awt.RenderingHints;
<i>34</i>&nbsp;import java.awt.Shape;
<i>35</i>&nbsp;import java.awt.Stroke;
<i>36</i>&nbsp;import java.awt.color.ColorSpace;
<i>37</i>&nbsp;import java.awt.color.ICC_Profile;
<i>38</i>&nbsp;import java.awt.geom.AffineTransform;
<i>39</i>&nbsp;import java.awt.geom.NoninvertibleTransformException;
<i>40</i>&nbsp;import java.awt.geom.Point2D;
<i>41</i>&nbsp;import java.awt.geom.Rectangle2D;
<i>42</i>&nbsp;import java.awt.image.BufferedImage;
<i>43</i>&nbsp;import java.awt.image.ColorConvertOp;
<i>44</i>&nbsp;import java.awt.image.LookupOp;
<i>45</i>&nbsp;import java.awt.image.ByteLookupTable;
<i>46</i>&nbsp;import java.io.File;
<i>47</i>&nbsp;import java.io.IOException;
<i>48</i>&nbsp;import java.lang.reflect.Method;
<i>49</i>&nbsp;import java.util.ArrayList;
<i>50</i>&nbsp;import java.util.Collection;
<i>51</i>&nbsp;import java.util.Collections;
<i>52</i>&nbsp;import java.util.Iterator;
<i>53</i>&nbsp;import java.util.List;
<i>54</i>&nbsp;import java.util.Objects;
<i>55</i>&nbsp;import java.util.stream.Collectors;
<i>56</i>&nbsp;
<i>57</i>&nbsp;import javax.imageio.ImageIO;
<i>58</i>&nbsp;import javax.imageio.ImageReader;
<i>59</i>&nbsp;import javax.imageio.metadata.IIOMetadata;
<i>60</i>&nbsp;import javax.imageio.stream.ImageInputStream;
<i>61</i>&nbsp;
<i>62</i>&nbsp;import org.slf4j.Logger;
<i>63</i>&nbsp;import org.slf4j.LoggerFactory;
<i>64</i>&nbsp;
<i>65</i>&nbsp;import javafx.application.Platform;
<i>66</i>&nbsp;import javafx.beans.InvalidationListener;
<i>67</i>&nbsp;import javafx.beans.Observable;
<i>68</i>&nbsp;import javafx.beans.property.BooleanProperty;
<i>69</i>&nbsp;import javafx.beans.property.DoubleProperty;
<i>70</i>&nbsp;import javafx.beans.property.IntegerProperty;
<i>71</i>&nbsp;import javafx.beans.property.LongProperty;
<i>72</i>&nbsp;import javafx.beans.property.ObjectProperty;
<i>73</i>&nbsp;import javafx.beans.property.ReadOnlyLongProperty;
<i>74</i>&nbsp;import javafx.beans.property.ReadOnlyObjectProperty;
<i>75</i>&nbsp;import javafx.beans.property.SimpleBooleanProperty;
<i>76</i>&nbsp;import javafx.beans.property.SimpleDoubleProperty;
<i>77</i>&nbsp;import javafx.beans.property.SimpleIntegerProperty;
<i>78</i>&nbsp;import javafx.beans.property.SimpleLongProperty;
<i>79</i>&nbsp;import javafx.beans.property.SimpleObjectProperty;
<i>80</i>&nbsp;import javafx.beans.value.ChangeListener;
<i>81</i>&nbsp;import javafx.beans.value.ObservableValue;
<i>82</i>&nbsp;import javafx.collections.FXCollections;
<i>83</i>&nbsp;import javafx.collections.ListChangeListener;
<i>84</i>&nbsp;import javafx.collections.ListChangeListener.Change;
<i>85</i>&nbsp;import javafx.collections.ObservableList;
<i>86</i>&nbsp;import javafx.embed.swing.SwingFXUtils;
<i>87</i>&nbsp;import javafx.event.EventHandler;
<i>88</i>&nbsp;import javafx.scene.Cursor;
<i>89</i>&nbsp;import javafx.scene.canvas.Canvas;
<i>90</i>&nbsp;import javafx.scene.canvas.GraphicsContext;
<i>91</i>&nbsp;import javafx.scene.control.Tooltip;
<i>92</i>&nbsp;import javafx.scene.image.WritableImage;
<i>93</i>&nbsp;import javafx.scene.input.KeyCode;
<i>94</i>&nbsp;import javafx.scene.input.KeyEvent;
<i>95</i>&nbsp;import javafx.scene.input.MouseEvent;
<i>96</i>&nbsp;import javafx.scene.layout.Pane;
<i>97</i>&nbsp;import javafx.scene.layout.StackPane;
<i>98</i>&nbsp;import javafx.scene.text.TextAlignment;
<i>99</i>&nbsp;import qupath.lib.awt.common.AwtTools;
<i>100</i>&nbsp;import qupath.lib.color.ColorToolsAwt;
<i>101</i>&nbsp;import qupath.lib.common.ColorTools;
<i>102</i>&nbsp;import qupath.lib.common.GeneralTools;
<i>103</i>&nbsp;import qupath.lib.display.ImageDisplay;
<i>104</i>&nbsp;import qupath.lib.gui.QuPathGUI;
<i>105</i>&nbsp;import qupath.lib.gui.images.servers.PathHierarchyImageServer;
<i>106</i>&nbsp;import qupath.lib.gui.images.stores.DefaultImageRegionStore;
<i>107</i>&nbsp;import qupath.lib.gui.images.stores.ImageRegionStoreHelpers;
<i>108</i>&nbsp;import qupath.lib.gui.images.stores.ImageRenderer;
<i>109</i>&nbsp;import qupath.lib.gui.images.stores.TileListener;
<i>110</i>&nbsp;import qupath.lib.gui.prefs.PathPrefs;
<i>111</i>&nbsp;import qupath.lib.gui.tools.ColorToolsFX;
<i>112</i>&nbsp;import qupath.lib.gui.tools.GuiTools;
<i>113</i>&nbsp;import qupath.lib.gui.viewer.overlays.AbstractOverlay;
<i>114</i>&nbsp;import qupath.lib.gui.viewer.overlays.GridOverlay;
<i>115</i>&nbsp;import qupath.lib.gui.viewer.overlays.HierarchyOverlay;
<i>116</i>&nbsp;import qupath.lib.gui.viewer.overlays.PathOverlay;
<i>117</i>&nbsp;import qupath.lib.gui.viewer.overlays.TMAGridOverlay;
<i>118</i>&nbsp;import qupath.lib.gui.viewer.tools.MoveTool;
<i>119</i>&nbsp;import qupath.lib.gui.viewer.tools.PathTool;
<i>120</i>&nbsp;import qupath.lib.gui.viewer.tools.PathTools;
<i>121</i>&nbsp;import qupath.lib.images.ImageData;
<i>122</i>&nbsp;import qupath.lib.images.servers.ImageServer;
<i>123</i>&nbsp;import qupath.lib.images.servers.PixelCalibration;
<i>124</i>&nbsp;import qupath.lib.objects.PathDetectionObject;
<i>125</i>&nbsp;import qupath.lib.objects.PathObject;
<i>126</i>&nbsp;import qupath.lib.objects.PathObjectTools;
<i>127</i>&nbsp;import qupath.lib.objects.TMACoreObject;
<i>128</i>&nbsp;import qupath.lib.objects.hierarchy.PathObjectHierarchy;
<i>129</i>&nbsp;import qupath.lib.objects.hierarchy.TMAGrid;
<i>130</i>&nbsp;import qupath.lib.objects.hierarchy.events.PathObjectHierarchyEvent;
<i>131</i>&nbsp;import qupath.lib.objects.hierarchy.events.PathObjectHierarchyListener;
<i>132</i>&nbsp;import qupath.lib.objects.hierarchy.events.PathObjectSelectionListener;
<i>133</i>&nbsp;import qupath.lib.regions.ImagePlane;
<i>134</i>&nbsp;import qupath.lib.regions.ImageRegion;
<i>135</i>&nbsp;import qupath.lib.regions.RegionRequest;
<i>136</i>&nbsp;import qupath.lib.roi.RectangleROI;
<i>137</i>&nbsp;import qupath.lib.roi.RoiEditor;
<i>138</i>&nbsp;import qupath.lib.roi.interfaces.ROI;
<i>139</i>&nbsp;
<i>140</i>&nbsp;
<i>141</i>&nbsp;/**
<i>142</i>&nbsp; * JavaFX component for viewing a (possibly large) image, along with overlays.
<i>143</i>&nbsp; * 
<i>144</i>&nbsp; * @author Pete Bankhead
<i>145</i>&nbsp; *
<i>146</i>&nbsp; */
<i>147</i>&nbsp;public class QuPathViewer implements TileListener&lt;BufferedImage&gt;, PathObjectHierarchyListener, PathObjectSelectionListener {
<i>148</i>&nbsp;
<b class="fc"><i>149</i>&nbsp;	private final static Logger logger = LoggerFactory.getLogger(QuPathViewer.class);</b>
<i>150</i>&nbsp;
<b class="fc"><i>151</i>&nbsp;	private List&lt;QuPathViewerListener&gt; listeners = new ArrayList&lt;&gt;();</b>
<i>152</i>&nbsp;
<b class="fc"><i>153</i>&nbsp;	private ObjectProperty&lt;ImageData&lt;BufferedImage&gt;&gt; imageDataProperty = new SimpleObjectProperty&lt;&gt;();</b>
<i>154</i>&nbsp;
<i>155</i>&nbsp;	private DefaultImageRegionStore regionStore;
<i>156</i>&nbsp;
<i>157</i>&nbsp;	// Overlay (ROI/object) display variables
<i>158</i>&nbsp;	private OverlayOptions overlayOptions;
<i>159</i>&nbsp;
<i>160</i>&nbsp;	// An overlay used to display an ImageServer wrapping a PathObjectHierarchy, for faster painting when there are a lot of objects
<b class="fc"><i>161</i>&nbsp;	private HierarchyOverlay hierarchyOverlay = null;</b>
<i>162</i>&nbsp;	// An overlay to show a TMA grid
<i>163</i>&nbsp;	private TMAGridOverlay tmaGridOverlay;
<i>164</i>&nbsp;	// An overlay to show a regular grid (e.g. for counting)
<i>165</i>&nbsp;	private GridOverlay gridOverlay;
<i>166</i>&nbsp;//	// A default overlay to show a pixel layer on top of an image
<i>167</i>&nbsp;//	private PixelLayerOverlay pixelLayerOverlay = null;
<i>168</i>&nbsp;	// A custom pixel overlay to use instead of the default
<b class="fc"><i>169</i>&nbsp;	private PathOverlay customPixelLayerOverlay = null;</b>
<i>170</i>&nbsp;	
<i>171</i>&nbsp;	// Overlay layers that can be edited
<b class="fc"><i>172</i>&nbsp;	private ObservableList&lt;PathOverlay&gt; customOverlayLayers = FXCollections.synchronizedObservableList(FXCollections.observableArrayList());</b>
<i>173</i>&nbsp;	
<i>174</i>&nbsp;	// Core overlay layers - these are always retained, and painted on top of any custom layers
<b class="fc"><i>175</i>&nbsp;	private ObservableList&lt;PathOverlay&gt; coreOverlayLayers = FXCollections.synchronizedObservableList(FXCollections.observableArrayList());</b>
<i>176</i>&nbsp;	
<i>177</i>&nbsp;	// List that concatenates the custom &amp; core overlay layers in painting order
<b class="fc"><i>178</i>&nbsp;	private ObservableList&lt;PathOverlay&gt; allOverlayLayers = FXCollections.synchronizedObservableList(FXCollections.observableArrayList());</b>
<i>179</i>&nbsp;
<i>180</i>&nbsp;	// Current we have two images - one transformed &amp; one not - because the untransformed
<i>181</i>&nbsp;	// image is needed to determine pixel values as the mouse moves over the image
<b class="fc"><i>182</i>&nbsp;	private BufferedImage imgBuffer = null;</b>
<i>183</i>&nbsp;	//	private BufferedImage imgTemp = null;
<i>184</i>&nbsp;
<i>185</i>&nbsp;	// Keep a reference to a thumbnail image here, and apply color transforms to it
<i>186</i>&nbsp;	//	private BufferedImage imgThumbnail;
<i>187</i>&nbsp;	private BufferedImage imgThumbnailRGB; // An RGB thumbnail, which may have been transformed (or null if imgThumbnail is already RGB)
<b class="fc"><i>188</i>&nbsp;	private boolean thumbnailIsFullImage = false;</b>
<i>189</i>&nbsp;
<i>190</i>&nbsp;	// Flag used to indicates that the image was updated for a repaint (otherwise it&#39;s assumed only the overlay may have changed)
<b class="fc"><i>191</i>&nbsp;	protected boolean imageUpdated = false;</b>
<b class="fc"><i>192</i>&nbsp;	protected boolean locationUpdated = false;</b>
<i>193</i>&nbsp;	
<i>194</i>&nbsp;	// Flag that is temporarily set to true while the ImageData is being set
<b class="fc"><i>195</i>&nbsp;	private BooleanProperty imageDataChanging = new SimpleBooleanProperty(false);</b>
<i>196</i>&nbsp;	
<i>197</i>&nbsp;	// Create tooltip to use!
<i>198</i>&nbsp;	// Currently disabled because JavaFX tooltips seem to behave quite erratically -
<i>199</i>&nbsp;	// remaining too long in the same place
<b class="fc"><i>200</i>&nbsp;	private Tooltip tooltip = null; //new Tooltip();</b>
<i>201</i>&nbsp;
<i>202</i>&nbsp;	// Location &amp; magnification variables
<i>203</i>&nbsp;	// x &amp; y coordinates - in the image space - of the center of the displayed region
<b class="fc"><i>204</i>&nbsp;	private double xCenter = 0;</b>
<b class="fc"><i>205</i>&nbsp;	private double yCenter = 0;</b>
<b class="fc"><i>206</i>&nbsp;	private DoubleProperty downsampleFactor = new SimpleDoubleProperty(1.0);</b>
<b class="fc"><i>207</i>&nbsp;	private double rotation = 0;</b>
<b class="fc"><i>208</i>&nbsp;	private BooleanProperty zoomToFit = new SimpleBooleanProperty(false);</b>
<i>209</i>&nbsp;	
<i>210</i>&nbsp;	// Affine transform used to apply rotation
<b class="fc"><i>211</i>&nbsp;	private AffineTransform transform = new AffineTransform();</b>
<b class="fc"><i>212</i>&nbsp;	private AffineTransform transformInverse = new AffineTransform();</b>
<i>213</i>&nbsp;
<i>214</i>&nbsp;	// Flag to indicate that repainting should occur faster if possible (less detail required)
<i>215</i>&nbsp;	// This can be useful when rapidly changing view, for example
<b class="fc"><i>216</i>&nbsp;	private boolean doFasterRepaint = false;</b>
<i>217</i>&nbsp;	
<b class="fc"><i>218</i>&nbsp;	private Color background = ColorToolsAwt.getCachedColor(PathPrefs.viewerBackgroundColorProperty().get());</b>
<i>219</i>&nbsp;
<i>220</i>&nbsp;	// Keep a record of when the spacebar is pressed, to help with dragging to pan
<b class="fc"><i>221</i>&nbsp;	private boolean spaceDown = false;</b>
<i>222</i>&nbsp;
<b class="fc"><i>223</i>&nbsp;	protected Color colorOverlaySuggested = null;</b>
<i>224</i>&nbsp;	
<i>225</i>&nbsp;	// Requested cursor - but this may be overridden temporarily
<b class="fc"><i>226</i>&nbsp;	private Cursor requestedCursor = Cursor.DEFAULT;</b>
<i>227</i>&nbsp;
<i>228</i>&nbsp;	// The shape (coordinates in the image domain) last painted
<i>229</i>&nbsp;	// Used to determine whether the visible part of the image has been changed
<b class="fc"><i>230</i>&nbsp;	private Shape lastVisibleShape = null;</b>
<i>231</i>&nbsp;
<b class="fc"><i>232</i>&nbsp;	private RoiEditor roiEditor = RoiEditor.createInstance();</b>
<i>233</i>&nbsp;
<b class="fc"><i>234</i>&nbsp;	private ObjectProperty&lt;PathTool&gt; currentTool = new SimpleObjectProperty&lt;&gt;(PathTools.MOVE);</b>
<i>235</i>&nbsp;	private ImageDisplay imageDisplay;
<b class="fc"><i>236</i>&nbsp;	transient private long lastDisplayChangeTimestamp = 0; // Used to indicate imageDisplay changes</b>
<i>237</i>&nbsp;
<b class="fc"><i>238</i>&nbsp;	private LongProperty lastRepaintTimestamp = new SimpleLongProperty(0L); // Used for debugging repaint times</b>
<i>239</i>&nbsp;	
<b class="fc"><i>240</i>&nbsp;	private boolean repaintRequested = false;</b>
<i>241</i>&nbsp;	
<i>242</i>&nbsp;	private double mouseX, mouseY;
<i>243</i>&nbsp;	
<i>244</i>&nbsp;	private StackPane pane;
<i>245</i>&nbsp;	private Canvas canvas;
<i>246</i>&nbsp;	private BufferedImage imgCache;
<i>247</i>&nbsp;	private WritableImage imgCacheFX;
<i>248</i>&nbsp;	
<b class="fc"><i>249</i>&nbsp;	private double borderLineWidth = 5;</b>
<i>250</i>&nbsp;	private javafx.scene.paint.Color borderColor;
<i>251</i>&nbsp;	
<i>252</i>&nbsp;	/**
<i>253</i>&nbsp;	 * Get the main JavaFX component representing this viewer.
<i>254</i>&nbsp;	 * This is what should be added to a scene.
<i>255</i>&nbsp;	 * @return
<i>256</i>&nbsp;	 */
<i>257</i>&nbsp;	public Pane getView() {
<b class="fc"><i>258</i>&nbsp;		if (canvas == null) {</b>
<b class="fc"><i>259</i>&nbsp;			setupCanvas();</b>
<i>260</i>&nbsp;		}
<b class="fc"><i>261</i>&nbsp;		return pane;</b>
<i>262</i>&nbsp;	}
<i>263</i>&nbsp;	
<i>264</i>&nbsp;	private void setupCanvas() {
<b class="fc"><i>265</i>&nbsp;		canvas = new Canvas();</b>
<b class="fc"><i>266</i>&nbsp;		addViewerListener(new QuPathViewerListener() {</b>
<i>267</i>&nbsp;
<i>268</i>&nbsp;			@Override
<i>269</i>&nbsp;			public void imageDataChanged(QuPathViewer viewer, ImageData&lt;BufferedImage&gt; imageDataOld,
<i>270</i>&nbsp;					ImageData&lt;BufferedImage&gt; imageDataNew) {
<b class="fc"><i>271</i>&nbsp;				paintCanvas();</b>
<b class="fc"><i>272</i>&nbsp;			}</b>
<i>273</i>&nbsp;
<i>274</i>&nbsp;			@Override
<i>275</i>&nbsp;			public void visibleRegionChanged(QuPathViewer viewer, Shape shape) {
<i>276</i>&nbsp;//				paintCanvas();
<b class="fc"><i>277</i>&nbsp;			}</b>
<i>278</i>&nbsp;
<i>279</i>&nbsp;			@Override
<i>280</i>&nbsp;			public void selectedObjectChanged(QuPathViewer viewer, PathObject pathObjectSelected) {
<i>281</i>&nbsp;//				paintCanvas();
<b class="fc"><i>282</i>&nbsp;			}</b>
<i>283</i>&nbsp;
<i>284</i>&nbsp;			@Override
<i>285</i>&nbsp;			public void viewerClosed(QuPathViewer viewer) {
<b class="nc"><i>286</i>&nbsp;				removeViewerListener(this);</b>
<b class="nc"><i>287</i>&nbsp;				canvas = null;</b>
<b class="nc"><i>288</i>&nbsp;			}</b>
<i>289</i>&nbsp;			
<i>290</i>&nbsp;		});
<i>291</i>&nbsp;		
<b class="fc"><i>292</i>&nbsp;		canvas.widthProperty().addListener((e, f, g) -&gt; {</b>
<b class="fc"><i>293</i>&nbsp;			if (getZoomToFit()) {</b>
<b class="nc"><i>294</i>&nbsp;				centerImage();</b>
<i>295</i>&nbsp;				// Make sure the downsample factor is being continually updated
<b class="nc"><i>296</i>&nbsp;				downsampleFactor.set(getZoomToFitDownsampleFactor());</b>
<i>297</i>&nbsp;			} else {
<b class="fc"><i>298</i>&nbsp;				updateAffineTransform();</b>
<b class="fc"><i>299</i>&nbsp;				repaint();</b>
<i>300</i>&nbsp;			}
<b class="fc"><i>301</i>&nbsp;		});</b>
<b class="fc"><i>302</i>&nbsp;		canvas.heightProperty().addListener((e, f, g) -&gt; {</b>
<b class="fc"><i>303</i>&nbsp;			if (getZoomToFit()) {</b>
<b class="nc"><i>304</i>&nbsp;				centerImage();</b>
<i>305</i>&nbsp;				// Make sure the downsample factor is being continually updated
<b class="nc"><i>306</i>&nbsp;				downsampleFactor.set(getZoomToFitDownsampleFactor());</b>
<i>307</i>&nbsp;			} else {
<b class="fc"><i>308</i>&nbsp;				updateAffineTransform();</b>
<b class="fc"><i>309</i>&nbsp;				repaint();</b>
<i>310</i>&nbsp;			}
<b class="fc"><i>311</i>&nbsp;		});</b>
<i>312</i>&nbsp;		
<b class="fc"><i>313</i>&nbsp;		pane = new StackPane();</b>
<i>314</i>&nbsp;//		pane.setStyle(&quot;fx-background-color: black;&quot;);
<b class="fc"><i>315</i>&nbsp;		pane.getChildren().add(canvas);</b>
<b class="fc"><i>316</i>&nbsp;		canvas.widthProperty().bind(pane.widthProperty());</b>
<b class="fc"><i>317</i>&nbsp;		canvas.heightProperty().bind(pane.heightProperty());</b>
<i>318</i>&nbsp;		
<i>319</i>&nbsp;		// Resize to anything
<b class="fc"><i>320</i>&nbsp;		pane.setMinWidth(1);</b>
<b class="fc"><i>321</i>&nbsp;		pane.setMinHeight(1);</b>
<b class="fc"><i>322</i>&nbsp;		pane.setMaxWidth(Double.MAX_VALUE);</b>
<b class="fc"><i>323</i>&nbsp;		pane.setMaxHeight(Double.MAX_VALUE);</b>
<i>324</i>&nbsp;		
<b class="fc"><i>325</i>&nbsp;		pane.addEventFilter(MouseEvent.ANY, e -&gt; {</b>
<b class="fc"><i>326</i>&nbsp;			mouseX = e.getX();</b>
<b class="fc"><i>327</i>&nbsp;			mouseY = e.getY();</b>
<i>328</i>&nbsp;			
<b class="fc"><i>329</i>&nbsp;			if (tooltip != null &amp;&amp; tooltip.isShowing())</b>
<b class="nc"><i>330</i>&nbsp;				updateTooltip(tooltip);</b>
<b class="fc"><i>331</i>&nbsp;		});</b>
<i>332</i>&nbsp;		
<b class="fc"><i>333</i>&nbsp;		pane.addEventFilter(KeyEvent.ANY, new KeyEventFilter());</b>
<b class="fc"><i>334</i>&nbsp;		pane.addEventHandler(KeyEvent.ANY, new KeyEventHandler());</b>
<i>335</i>&nbsp;
<b class="fc"><i>336</i>&nbsp;	}</b>
<i>337</i>&nbsp;	
<i>338</i>&nbsp;	
<i>339</i>&nbsp;	/**
<i>340</i>&nbsp;	 * Update allOverlayLayers to make sure it contains all the required PathOverlays.
<i>341</i>&nbsp;	 */
<i>342</i>&nbsp;	private synchronized void refreshAllOverlayLayers() {
<b class="fc"><i>343</i>&nbsp;		List&lt;PathOverlay&gt; temp = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>344</i>&nbsp;		temp.addAll(customOverlayLayers);</b>
<b class="fc"><i>345</i>&nbsp;		temp.addAll(coreOverlayLayers);</b>
<b class="fc"><i>346</i>&nbsp;		allOverlayLayers.setAll(temp);</b>
<b class="fc"><i>347</i>&nbsp;	}</b>
<i>348</i>&nbsp;	
<i>349</i>&nbsp;	
<b class="fc"><i>350</i>&nbsp;	private long lastPaint = 0;</b>
<b class="fc"><i>351</i>&nbsp;	private long minimumRepaintSpacingMillis = -1; // This can be used (temporarily) to prevent repaints happening too frequently</b>
<i>352</i>&nbsp;	
<i>353</i>&nbsp;	/**
<i>354</i>&nbsp;	 * Prevent frequent repaints (temporarily) by setting a minimum time that must have elapsed
<i>355</i>&nbsp;	 * after the previous repaint for a new one to be triggered.
<i>356</i>&nbsp;	 * (Repaint requests that come in between are simply disregarded for performance.)
<i>357</i>&nbsp;	 * &lt;p&gt;
<i>358</i>&nbsp;	 * When finished, it&#39;s necessary to call resetMinimumRepaintSpacingMillis() to make sure that 
<i>359</i>&nbsp;	 * normal service is resumed.
<i>360</i>&nbsp;	 * 
<i>361</i>&nbsp;	 * @param repaintSpacingMillis
<i>362</i>&nbsp;	 * 
<i>363</i>&nbsp;	 * @see #resetMinimumRepaintSpacingMillis
<i>364</i>&nbsp;	 */
<i>365</i>&nbsp;	public void setMinimumRepaintSpacingMillis(final long repaintSpacingMillis) {
<b class="nc"><i>366</i>&nbsp;		this.minimumRepaintSpacingMillis = repaintSpacingMillis;</b>
<b class="nc"><i>367</i>&nbsp;	}</b>
<i>368</i>&nbsp;
<i>369</i>&nbsp;	/**
<i>370</i>&nbsp;	 * Return to processing all repainting requests.
<i>371</i>&nbsp;	 * &lt;p&gt;
<i>372</i>&nbsp;	 * Note: calling this command triggers a repaint itself.
<i>373</i>&nbsp;	 */
<i>374</i>&nbsp;	public void resetMinimumRepaintSpacingMillis() {
<b class="nc"><i>375</i>&nbsp;		this.minimumRepaintSpacingMillis = -1;</b>
<b class="nc"><i>376</i>&nbsp;		repaintRequested = false;</b>
<b class="nc"><i>377</i>&nbsp;		repaint();</b>
<b class="nc"><i>378</i>&nbsp;	}</b>
<i>379</i>&nbsp;
<i>380</i>&nbsp;	
<i>381</i>&nbsp;	void paintCanvas() {
<i>382</i>&nbsp;		// Ensure there&#39;s always a repaint requested whenever the image is updated
<i>383</i>&nbsp;		// (Should be the case anyway)
<b class="fc"><i>384</i>&nbsp;		if (imageUpdated) {</b>
<b class="fc"><i>385</i>&nbsp;			repaintRequested = true;</b>
<i>386</i>&nbsp;		}
<i>387</i>&nbsp;		
<b class="fc"><i>388</i>&nbsp;		if (!repaintRequested || canvas == null || canvas.getWidth() &lt;= 0 || canvas.getHeight() &lt;= 0) {</b>
<b class="fc"><i>389</i>&nbsp;			repaintRequested = false;</b>
<b class="fc"><i>390</i>&nbsp;			return;</b>
<i>391</i>&nbsp;		}
<i>392</i>&nbsp;//		if (canvas == null || !canvas.isVisible())
<i>393</i>&nbsp;//			return;
<i>394</i>&nbsp;		
<b class="fc"><i>395</i>&nbsp;		if (!Platform.isFxApplicationThread()) {</b>
<b class="nc"><i>396</i>&nbsp;			Platform.runLater(() -&gt; paintCanvas());</b>
<b class="nc"><i>397</i>&nbsp;			return;</b>
<i>398</i>&nbsp;		}
<i>399</i>&nbsp;		
<b class="fc"><i>400</i>&nbsp;		if (imgCache == null || imgCache.getWidth() &lt; canvas.getWidth() || imgCache.getHeight() &lt; canvas.getHeight()) {</b>
<b class="fc"><i>401</i>&nbsp;			int w = (int)(canvas.getWidth() + 1);</b>
<b class="fc"><i>402</i>&nbsp;			int h = (int)(canvas.getHeight() + 1);</b>
<b class="fc"><i>403</i>&nbsp;			imgCache = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB_PRE);</b>
<b class="fc"><i>404</i>&nbsp;			imgCacheFX = new WritableImage(w, h);</b>
<i>405</i>&nbsp;//			imgCacheFX = SwingFXUtils.toFXImage(imgCache, imgCacheFX);
<i>406</i>&nbsp;		}
<i>407</i>&nbsp;		
<i>408</i>&nbsp;		// Reset repaint flag
<b class="fc"><i>409</i>&nbsp;		repaintRequested = false;</b>
<i>410</i>&nbsp;		
<b class="fc"><i>411</i>&nbsp;		GraphicsContext context = canvas.getGraphicsContext2D();</b>
<i>412</i>&nbsp;		
<b class="fc"><i>413</i>&nbsp;		Graphics2D g = imgCache.createGraphics();</b>
<b class="fc"><i>414</i>&nbsp;		paintViewer(g, getWidth(), getHeight());</b>
<b class="fc"><i>415</i>&nbsp;		g.dispose();</b>
<i>416</i>&nbsp;		
<b class="fc"><i>417</i>&nbsp;		imgCacheFX = SwingFXUtils.toFXImage(imgCache, imgCacheFX);</b>
<b class="fc"><i>418</i>&nbsp;		context.drawImage(imgCacheFX, 0, 0);</b>
<i>419</i>&nbsp;		
<b class="fc"><i>420</i>&nbsp;		if (borderColor != null) {</b>
<b class="fc"><i>421</i>&nbsp;			context.setStroke(borderColor);</b>
<b class="fc"><i>422</i>&nbsp;			context.setLineWidth(borderLineWidth);</b>
<b class="fc"><i>423</i>&nbsp;			context.strokeRect(0, 0, canvas.getWidth(), canvas.getHeight());</b>
<i>424</i>&nbsp;		}
<i>425</i>&nbsp;		
<i>426</i>&nbsp;		
<i>427</i>&nbsp;		
<i>428</i>&nbsp;//		// Basic code for including the TMA core name
<i>429</i>&nbsp;//		if (getHierarchy().getTMAGrid() != null) {
<i>430</i>&nbsp;//			Point2D pSource = new Point2D.Double();
<i>431</i>&nbsp;//			Point2D pDest = new Point2D.Double();
<i>432</i>&nbsp;//			context.setTextAlign(TextAlignment.CENTER);
<i>433</i>&nbsp;//			context.setTextBaseline(VPos.CENTER);
<i>434</i>&nbsp;//			for (TMACoreObject core : getHierarchy().getTMAGrid().getTMACoreList()) {
<i>435</i>&nbsp;//				if (core.getName() == null)
<i>436</i>&nbsp;//					continue;
<i>437</i>&nbsp;//				double x = core.getROI().getBoundsX() + core.getROI().getBoundsWidth()/2;
<i>438</i>&nbsp;//				double y = core.getROI().getBoundsY() + core.getROI().getBoundsHeight()/2;
<i>439</i>&nbsp;//				pSource.setLocation(x, y);
<i>440</i>&nbsp;//				transform.transform(pSource, pDest);
<i>441</i>&nbsp;//				context.setFill(getSuggestedOverlayColorFX());
<i>442</i>&nbsp;//				context.setStroke(javafx.scene.paint.Color.WHITE);
<i>443</i>&nbsp;//				double xf = pDest.getX();
<i>444</i>&nbsp;//				double yf = pDest.getY();
<i>445</i>&nbsp;//				context.fillText(core.getName(), xf, yf, core.getROI().getBoundsWidth()/getDownsampleFactor()*0.5);
<i>446</i>&nbsp;//			}
<i>447</i>&nbsp;//		}
<i>448</i>&nbsp;		
<i>449</i>&nbsp;		
<i>450</i>&nbsp;//		if (getServer() == null) {
<i>451</i>&nbsp;//			context.setStroke(javafx.scene.paint.Color.GREENYELLOW);
<i>452</i>&nbsp;//			context.setLineWidth(borderLineWidth);
<i>453</i>&nbsp;//			context.strokeRect(0, 0, canvas.getWidth(), canvas.getHeight());
<i>454</i>&nbsp;//		}
<i>455</i>&nbsp;		
<b class="fc"><i>456</i>&nbsp;		long time = System.currentTimeMillis();</b>
<b class="fc"><i>457</i>&nbsp;		logger.trace(&quot;Time since last repaint: {} ms&quot;, (time - lastPaint));</b>
<b class="fc"><i>458</i>&nbsp;		lastPaint = System.currentTimeMillis();</b>
<i>459</i>&nbsp;		
<b class="fc"><i>460</i>&nbsp;		imageDataChanging.set(false);</b>
<i>461</i>&nbsp;//		repaintRequested = false;
<b class="fc"><i>462</i>&nbsp;	}</b>
<i>463</i>&nbsp;	
<i>464</i>&nbsp;	/**
<i>465</i>&nbsp;	 * Set the border color for this viewer.
<i>466</i>&nbsp;	 * This can be used to indicate (for example) that a particular viewer is active.
<i>467</i>&nbsp;	 * @param color
<i>468</i>&nbsp;	 */
<i>469</i>&nbsp;	public void setBorderColor(final javafx.scene.paint.Color color) {
<b class="fc"><i>470</i>&nbsp;		this.borderColor = color;</b>
<b class="fc"><i>471</i>&nbsp;		if (Platform.isFxApplicationThread()) {</b>
<b class="fc"><i>472</i>&nbsp;			repaintRequested = true;</b>
<b class="fc"><i>473</i>&nbsp;			paintCanvas();</b>
<i>474</i>&nbsp;		} else
<b class="nc"><i>475</i>&nbsp;			repaint();</b>
<b class="fc"><i>476</i>&nbsp;	}</b>
<i>477</i>&nbsp;
<i>478</i>&nbsp;	/**
<i>479</i>&nbsp;	 * Get the border color set for this viewer.
<i>480</i>&nbsp;	 * @return
<i>481</i>&nbsp;	 */
<i>482</i>&nbsp;	public javafx.scene.paint.Color getBorderColor() {
<b class="nc"><i>483</i>&nbsp;		return borderColor;</b>
<i>484</i>&nbsp;	}
<i>485</i>&nbsp;	
<i>486</i>&nbsp;	private int getWidth() {
<b class="fc"><i>487</i>&nbsp;		return (int)Math.ceil(getView().getWidth());</b>
<i>488</i>&nbsp;	}
<i>489</i>&nbsp;	
<i>490</i>&nbsp;	private int getHeight() {
<b class="fc"><i>491</i>&nbsp;		return (int)Math.ceil(getView().getHeight());</b>
<i>492</i>&nbsp;	}
<i>493</i>&nbsp;	
<i>494</i>&nbsp;	/**
<i>495</i>&nbsp;	 * Request that the viewer is repainted.
<i>496</i>&nbsp;	 * The repaint is not triggered immediately, but rather enqueued for future processing.
<i>497</i>&nbsp;	 * &lt;p&gt;
<i>498</i>&nbsp;	 * Note that this can be used for changes in the field of view or overlay, but &lt;i&gt;not&lt;/i&gt; for 
<i>499</i>&nbsp;	 * large changes that require any cached thumbnail to also be updated (e.g. changing the 
<i>500</i>&nbsp;	 * brightness/contrast or lookup table). In such cases {@link #repaintEntireImage()} is required.
<i>501</i>&nbsp;	 * @see #repaintEntireImage()
<i>502</i>&nbsp;	 */
<i>503</i>&nbsp;	public void repaint() {
<b class="fc"><i>504</i>&nbsp;		if (repaintRequested &amp;&amp; minimumRepaintSpacingMillis &lt;= 0)</b>
<b class="fc"><i>505</i>&nbsp;			return;</b>
<i>506</i>&nbsp;		
<i>507</i>&nbsp;		// We need to repaint everything if the display changed
<b class="fc"><i>508</i>&nbsp;		if (imageDisplay != null &amp;&amp; (lastDisplayChangeTimestamp != imageDisplay.getLastChangeTimestamp())) {</b>
<b class="fc"><i>509</i>&nbsp;			repaintEntireImage();</b>
<b class="fc"><i>510</i>&nbsp;			return;</b>
<i>511</i>&nbsp;		}
<i>512</i>&nbsp;		
<b class="fc"><i>513</i>&nbsp;		logger.trace(&quot;Repaint requested!&quot;);</b>
<b class="fc"><i>514</i>&nbsp;		repaintRequested = true;</b>
<i>515</i>&nbsp;		
<i>516</i>&nbsp;		// Skip repaint if the minimum time hasn&#39;t elapsed
<b class="fc"><i>517</i>&nbsp;		if ((System.currentTimeMillis() - lastPaint) &lt; minimumRepaintSpacingMillis)</b>
<b class="nc"><i>518</i>&nbsp;			return;</b>
<b class="fc"><i>519</i>&nbsp;		Platform.runLater(() -&gt; paintCanvas());</b>
<b class="fc"><i>520</i>&nbsp;	}</b>
<i>521</i>&nbsp;
<i>522</i>&nbsp;	/**
<i>523</i>&nbsp;	 * Get the minimum downsample value supported by this viewer.
<i>524</i>&nbsp;	 * This prevents zooming in by an unreasonably large amount.
<i>525</i>&nbsp;	 * @return
<i>526</i>&nbsp;	 */
<i>527</i>&nbsp;	public double getMinDownsample() {
<b class="nc"><i>528</i>&nbsp;		return 1.0/64.0;</b>
<i>529</i>&nbsp;	}
<i>530</i>&nbsp;
<i>531</i>&nbsp;	/**
<i>532</i>&nbsp;	 * Get the maximum downsample value supported by this viewer.
<i>533</i>&nbsp;	 * This prevents zooming out by an unreasonably large amount.
<i>534</i>&nbsp;	 * @return
<i>535</i>&nbsp;	 */
<i>536</i>&nbsp;	public double getMaxDownsample() {
<b class="nc"><i>537</i>&nbsp;		if (!hasServer())</b>
<b class="nc"><i>538</i>&nbsp;			return 1;</b>
<b class="nc"><i>539</i>&nbsp;		return Math.max(getServerWidth(), getServerHeight()) / 100.0;</b>
<i>540</i>&nbsp;	}
<i>541</i>&nbsp;
<i>542</i>&nbsp;	/**
<i>543</i>&nbsp;	 * Zoom out by a specified number of steps, where one &#39;step&#39; indicates a minimal zoom increment.
<i>544</i>&nbsp;	 * @param nSteps
<i>545</i>&nbsp;	 */
<i>546</i>&nbsp;	public void zoomOut(int nSteps) {
<b class="nc"><i>547</i>&nbsp;		zoomIn(-nSteps);</b>
<b class="nc"><i>548</i>&nbsp;	}</b>
<i>549</i>&nbsp;
<i>550</i>&nbsp;	/**
<i>551</i>&nbsp;	 * Zoom in by a specified number of steps, where one &#39;step&#39; indicates a minimal zoom increment.
<i>552</i>&nbsp;	 * @param nSteps
<i>553</i>&nbsp;	 */
<i>554</i>&nbsp;	public void zoomIn(int nSteps) {
<b class="nc"><i>555</i>&nbsp;		if (nSteps == 0)</b>
<b class="nc"><i>556</i>&nbsp;			return;</b>
<b class="nc"><i>557</i>&nbsp;		setDownsampleFactor(getDownsampleFactor() * Math.pow(getDefaultZoomFactor(), -nSteps), -1, -1);</b>
<b class="nc"><i>558</i>&nbsp;	}</b>
<i>559</i>&nbsp;
<i>560</i>&nbsp;	/**
<i>561</i>&nbsp;	 * The amount by which the downsample factor is scaled for one increment of {@link #zoomIn()} or 
<i>562</i>&nbsp;	 * {@link #zoomOut()}.  Controls zoom speed.
<i>563</i>&nbsp;	 * @return
<i>564</i>&nbsp;	 */
<i>565</i>&nbsp;	public double getDefaultZoomFactor() {
<b class="nc"><i>566</i>&nbsp;		return 1.01;</b>
<i>567</i>&nbsp;	}
<i>568</i>&nbsp;
<i>569</i>&nbsp;	/**
<i>570</i>&nbsp;	 * Zoom out by one step.
<i>571</i>&nbsp;	 * 
<i>572</i>&nbsp;	 * @see #zoomOut(int)
<i>573</i>&nbsp;	 * @see #getDefaultZoomFactor()
<i>574</i>&nbsp;	 */
<i>575</i>&nbsp;	public void zoomOut() {
<b class="nc"><i>576</i>&nbsp;		zoomOut(1);</b>
<b class="nc"><i>577</i>&nbsp;	}</b>
<i>578</i>&nbsp;
<i>579</i>&nbsp;	/**
<i>580</i>&nbsp;	 * Zoom in by one step.
<i>581</i>&nbsp;	 * 
<i>582</i>&nbsp;	 * @see #zoomIn(int)
<i>583</i>&nbsp;	 * @see #getDefaultZoomFactor()
<i>584</i>&nbsp;	 */
<i>585</i>&nbsp;	public void zoomIn() {
<b class="nc"><i>586</i>&nbsp;		zoomIn(1);		</b>
<b class="nc"><i>587</i>&nbsp;	}</b>
<i>588</i>&nbsp;
<i>589</i>&nbsp;	
<b class="fc"><i>590</i>&nbsp;	private InvalidationListener repainter = new InvalidationListener() {</b>
<i>591</i>&nbsp;		@Override
<i>592</i>&nbsp;		public void invalidated(Observable observable) {
<b class="nc"><i>593</i>&nbsp;			repaint();</b>
<b class="nc"><i>594</i>&nbsp;		}</b>
<i>595</i>&nbsp;	};
<i>596</i>&nbsp;	
<i>597</i>&nbsp;	// We need a more extensive repaint for changes to the image pixel display
<b class="fc"><i>598</i>&nbsp;	private InvalidationListener repainterEntire = new InvalidationListener() {</b>
<i>599</i>&nbsp;		@Override
<i>600</i>&nbsp;		public void invalidated(Observable observable) {
<b class="nc"><i>601</i>&nbsp;			background = ColorToolsAwt.getCachedColor(PathPrefs.viewerBackgroundColorProperty().get());</b>
<b class="nc"><i>602</i>&nbsp;			repaintEntireImage();</b>
<b class="nc"><i>603</i>&nbsp;		}</b>
<i>604</i>&nbsp;	};
<i>605</i>&nbsp;	
<i>606</i>&nbsp;	// We need a more extensive repaint for changes to the image pixel display
<b class="fc"><i>607</i>&nbsp;	private InvalidationListener repainterOverlay = new InvalidationListener() {</b>
<i>608</i>&nbsp;		@Override
<i>609</i>&nbsp;		public void invalidated(Observable observable) {
<b class="nc"><i>610</i>&nbsp;			forceOverlayUpdate();</b>
<b class="nc"><i>611</i>&nbsp;			background = ColorToolsAwt.getCachedColor(PathPrefs.viewerBackgroundColorProperty().get());</b>
<b class="nc"><i>612</i>&nbsp;			repaint();</b>
<b class="nc"><i>613</i>&nbsp;		}</b>
<i>614</i>&nbsp;	};
<i>615</i>&nbsp;	
<i>616</i>&nbsp;	
<i>617</i>&nbsp;	
<b class="fc"><i>618</i>&nbsp;	static class ListenerManager {</b>
<i>619</i>&nbsp;		
<b class="fc"><i>620</i>&nbsp;		private List&lt;ListenerHandler&gt; handlers = new ArrayList&lt;&gt;();</b>
<i>621</i>&nbsp;		
<i>622</i>&nbsp;		public ListenerHandler attachListener(Observable observable, InvalidationListener listener) {
<b class="fc"><i>623</i>&nbsp;			ListenerHandler handler = new ObservableListenerHandler(observable, listener);</b>
<b class="fc"><i>624</i>&nbsp;			handler.attach();</b>
<b class="fc"><i>625</i>&nbsp;			handlers.add(handler);</b>
<b class="fc"><i>626</i>&nbsp;			return handler;</b>
<i>627</i>&nbsp;		}
<i>628</i>&nbsp;		
<i>629</i>&nbsp;		public &lt;T&gt; ListenerHandler attachListener(ObservableValue&lt;T&gt; observable, ChangeListener&lt;T&gt; listener) {
<b class="nc"><i>630</i>&nbsp;			ListenerHandler handler = new ObservableValueListenerHandler&lt;&gt;(observable, listener);</b>
<b class="nc"><i>631</i>&nbsp;			handlers.add(handler);</b>
<b class="nc"><i>632</i>&nbsp;			handler.attach();</b>
<b class="nc"><i>633</i>&nbsp;			return handler;</b>
<i>634</i>&nbsp;		}
<i>635</i>&nbsp;
<i>636</i>&nbsp;		public &lt;T&gt; ListenerHandler attachListener(ObservableList&lt;T&gt; observable, ListChangeListener&lt;T&gt; listener) {
<b class="nc"><i>637</i>&nbsp;			ListenerHandler handler = new ObservableListListenerHandler&lt;&gt;(observable, listener);</b>
<b class="nc"><i>638</i>&nbsp;			handlers.add(handler);</b>
<b class="nc"><i>639</i>&nbsp;			handler.attach();</b>
<b class="nc"><i>640</i>&nbsp;			return handler;</b>
<i>641</i>&nbsp;		}
<i>642</i>&nbsp;
<i>643</i>&nbsp;		public void detachAll() {
<b class="nc"><i>644</i>&nbsp;			handlers.stream().forEach(h -&gt; h.detach());</b>
<b class="nc"><i>645</i>&nbsp;		}</b>
<i>646</i>&nbsp;		
<i>647</i>&nbsp;		public void clear() {
<b class="nc"><i>648</i>&nbsp;			this.handlers.clear();</b>
<b class="nc"><i>649</i>&nbsp;		}</b>
<i>650</i>&nbsp;		
<i>651</i>&nbsp;	}
<i>652</i>&nbsp;	
<i>653</i>&nbsp;	static interface ListenerHandler {
<i>654</i>&nbsp;		void attach();
<i>655</i>&nbsp;		void detach();
<i>656</i>&nbsp;	}
<i>657</i>&nbsp;	
<i>658</i>&nbsp;	static class ObservableListenerHandler implements ListenerHandler {
<i>659</i>&nbsp;		
<i>660</i>&nbsp;		private Observable observable;
<i>661</i>&nbsp;		private InvalidationListener listener;
<i>662</i>&nbsp;		
<b class="fc"><i>663</i>&nbsp;		private ObservableListenerHandler(Observable observable, InvalidationListener listener) {</b>
<b class="fc"><i>664</i>&nbsp;			this.observable = observable;</b>
<b class="fc"><i>665</i>&nbsp;			this.listener = listener;</b>
<b class="fc"><i>666</i>&nbsp;		}</b>
<i>667</i>&nbsp;		
<i>668</i>&nbsp;		@Override
<i>669</i>&nbsp;		public void attach() {
<b class="fc"><i>670</i>&nbsp;			this.observable.addListener(listener);</b>
<b class="fc"><i>671</i>&nbsp;		}</b>
<i>672</i>&nbsp;		
<i>673</i>&nbsp;		@Override
<i>674</i>&nbsp;		public void detach() {
<b class="nc"><i>675</i>&nbsp;			this.observable.removeListener(listener);</b>
<b class="nc"><i>676</i>&nbsp;		}</b>
<i>677</i>&nbsp;		
<i>678</i>&nbsp;	}
<i>679</i>&nbsp;	
<i>680</i>&nbsp;	static class ObservableListListenerHandler&lt;T&gt; implements ListenerHandler {
<i>681</i>&nbsp;		
<i>682</i>&nbsp;		private ObservableList&lt;T&gt; observable;
<i>683</i>&nbsp;		private ListChangeListener&lt;T&gt; listener;
<i>684</i>&nbsp;		
<b class="nc"><i>685</i>&nbsp;		private ObservableListListenerHandler(ObservableList&lt;T&gt; observable, ListChangeListener&lt;T&gt; listener) {</b>
<b class="nc"><i>686</i>&nbsp;			this.observable = observable;</b>
<b class="nc"><i>687</i>&nbsp;			this.listener = listener;</b>
<i>688</i>&nbsp;		}
<i>689</i>&nbsp;
<i>690</i>&nbsp;		@Override
<i>691</i>&nbsp;		public void attach() {
<b class="nc"><i>692</i>&nbsp;			observable.addListener(listener);</b>
<i>693</i>&nbsp;		}
<i>694</i>&nbsp;
<i>695</i>&nbsp;		@Override
<i>696</i>&nbsp;		public void detach() {
<b class="nc"><i>697</i>&nbsp;			observable.removeListener(listener);</b>
<i>698</i>&nbsp;		}
<i>699</i>&nbsp;		
<i>700</i>&nbsp;	}
<i>701</i>&nbsp;
<i>702</i>&nbsp;	static class ObservableValueListenerHandler&lt;T&gt; implements ListenerHandler {
<i>703</i>&nbsp;		
<i>704</i>&nbsp;		private ObservableValue&lt;T&gt; observable;
<i>705</i>&nbsp;		private ChangeListener&lt;T&gt; listener;
<i>706</i>&nbsp;		
<b class="nc"><i>707</i>&nbsp;		private ObservableValueListenerHandler(ObservableValue&lt;T&gt; observable, ChangeListener&lt;T&gt; listener) {</b>
<b class="nc"><i>708</i>&nbsp;			this.observable = observable;</b>
<b class="nc"><i>709</i>&nbsp;			this.listener = listener;</b>
<i>710</i>&nbsp;		}
<i>711</i>&nbsp;
<i>712</i>&nbsp;		@Override
<i>713</i>&nbsp;		public void attach() {
<b class="nc"><i>714</i>&nbsp;			observable.addListener(listener);</b>
<i>715</i>&nbsp;		}
<i>716</i>&nbsp;
<i>717</i>&nbsp;		@Override
<i>718</i>&nbsp;		public void detach() {
<b class="nc"><i>719</i>&nbsp;			observable.removeListener(listener);</b>
<i>720</i>&nbsp;		}
<i>721</i>&nbsp;		
<i>722</i>&nbsp;	}
<i>723</i>&nbsp;	
<i>724</i>&nbsp;//	protected void finalize() throws Throwable {
<i>725</i>&nbsp;//		System.err.println(&quot;Viewer being removed!&quot;);
<i>726</i>&nbsp;//		super.finalize();
<i>727</i>&nbsp;//	}
<i>728</i>&nbsp;	
<i>729</i>&nbsp;	
<b class="fc"><i>730</i>&nbsp;	private ListenerManager manager = new ListenerManager();</b>
<b class="fc"><i>731</i>&nbsp;	private ListenerManager overlayOptionsManager = new ListenerManager();</b>
<i>732</i>&nbsp;	
<i>733</i>&nbsp;
<i>734</i>&nbsp;	/**
<i>735</i>&nbsp;	 * Create a new viewer.
<i>736</i>&nbsp;	 * @param imageData image data to show within the viewer
<i>737</i>&nbsp;	 * @param regionStore store used to tile caching
<i>738</i>&nbsp;	 * @param overlayOptions overlay options to control the viewer display
<i>739</i>&nbsp;	 */
<i>740</i>&nbsp;	public QuPathViewer(final ImageData&lt;BufferedImage&gt; imageData, DefaultImageRegionStore regionStore, OverlayOptions overlayOptions) {
<b class="fc"><i>741</i>&nbsp;		this(imageData, regionStore, overlayOptions, new ImageDisplay(null));</b>
<b class="fc"><i>742</i>&nbsp;	}</b>
<i>743</i>&nbsp;	
<i>744</i>&nbsp;	/**
<i>745</i>&nbsp;	 * Create a new viewer.
<i>746</i>&nbsp;	 * @param imageData image data to show within the viewer
<i>747</i>&nbsp;	 * @param regionStore store used to tile caching
<i>748</i>&nbsp;	 * @param overlayOptions overlay options to control the viewer display
<i>749</i>&nbsp;	 * @param imageDisplay image display used to control the image display (conversion to RGB)
<i>750</i>&nbsp;	 */
<i>751</i>&nbsp;	public QuPathViewer(final ImageData&lt;BufferedImage&gt; imageData, DefaultImageRegionStore regionStore, OverlayOptions overlayOptions, ImageDisplay imageDisplay) {
<b class="fc"><i>752</i>&nbsp;		super();</b>
<i>753</i>&nbsp;
<b class="fc"><i>754</i>&nbsp;		this.regionStore = regionStore;</b>
<i>755</i>&nbsp;
<b class="fc"><i>756</i>&nbsp;		setOverlayOptions(overlayOptions);</b>
<i>757</i>&nbsp;		
<i>758</i>&nbsp;		// We need a simple repaint for color changes &amp; simple (thick) line changes
<b class="fc"><i>759</i>&nbsp;		manager.attachListener(PathPrefs.annotationStrokeThicknessProperty(), repainter);</b>
<i>760</i>&nbsp;		
<b class="fc"><i>761</i>&nbsp;		manager.attachListener(PathPrefs.viewerGammaProperty(), repainterEntire);</b>
<b class="fc"><i>762</i>&nbsp;		manager.attachListener(PathPrefs.viewerInterpolateBilinearProperty(), repainterEntire);</b>
<b class="fc"><i>763</i>&nbsp;		manager.attachListener(PathPrefs.viewerBackgroundColorProperty(), repainterEntire);</b>
<i>764</i>&nbsp;		
<b class="fc"><i>765</i>&nbsp;		manager.attachListener(PathPrefs.showPointHullsProperty(), repainter);</b>
<b class="fc"><i>766</i>&nbsp;		manager.attachListener(PathPrefs.useSelectedColorProperty(), repainter);</b>
<b class="fc"><i>767</i>&nbsp;		manager.attachListener(PathPrefs.colorDefaultObjectsProperty(), repainterOverlay);</b>
<b class="fc"><i>768</i>&nbsp;		manager.attachListener(PathPrefs.colorSelectedObjectProperty(), repainter);</b>
<b class="fc"><i>769</i>&nbsp;		manager.attachListener(PathPrefs.colorTileProperty(), repainter);</b>
<b class="fc"><i>770</i>&nbsp;		manager.attachListener(PathPrefs.colorTMAProperty(), repainter);</b>
<b class="fc"><i>771</i>&nbsp;		manager.attachListener(PathPrefs.colorTMAMissingProperty(), repainter);</b>
<b class="fc"><i>772</i>&nbsp;		manager.attachListener(PathPrefs.alwaysPaintSelectedObjectsProperty(), repainter);</b>
<b class="fc"><i>773</i>&nbsp;		manager.attachListener(PathPrefs.viewerFontSizeProperty(), repainter);</b>
<i>774</i>&nbsp;
<b class="fc"><i>775</i>&nbsp;		manager.attachListener(PathPrefs.gridSpacingXProperty(), repainter);</b>
<b class="fc"><i>776</i>&nbsp;		manager.attachListener(PathPrefs.gridSpacingYProperty(), repainter);</b>
<b class="fc"><i>777</i>&nbsp;		manager.attachListener(PathPrefs.gridStartXProperty(), repainter);</b>
<b class="fc"><i>778</i>&nbsp;		manager.attachListener(PathPrefs.gridStartYProperty(), repainter);</b>
<b class="fc"><i>779</i>&nbsp;		manager.attachListener(PathPrefs.gridScaleMicronsProperty(), repainter);</b>
<i>780</i>&nbsp;
<i>781</i>&nbsp;		// We need to repaint everything if detection line thickness changes - including any cached regions
<b class="fc"><i>782</i>&nbsp;		manager.attachListener(PathPrefs.detectionStrokeThicknessProperty(), repainterOverlay);		</b>
<i>783</i>&nbsp;
<i>784</i>&nbsp;		// Can be used to debug graphics
<i>785</i>&nbsp;		//		setDoubleBuffered(false);
<i>786</i>&nbsp;		//		RepaintManager.currentManager(this).setDoubleBufferingEnabled(false);
<i>787</i>&nbsp;		//		setDebugGraphicsOptions(DebugGraphics.LOG_OPTION);
<i>788</i>&nbsp;
<b class="fc"><i>789</i>&nbsp;		this.imageDisplay = imageDisplay;</b>
<i>790</i>&nbsp;
<i>791</i>&nbsp;		// Prepare overlay layers
<b class="fc"><i>792</i>&nbsp;		customOverlayLayers.addListener((Change&lt;? extends PathOverlay&gt; e) -&gt; refreshAllOverlayLayers());</b>
<b class="fc"><i>793</i>&nbsp;		coreOverlayLayers.addListener((Change&lt;? extends PathOverlay&gt; e) -&gt; refreshAllOverlayLayers());</b>
<b class="fc"><i>794</i>&nbsp;		allOverlayLayers.addListener((Change&lt;? extends PathOverlay&gt; e) -&gt; repaint());</b>
<i>795</i>&nbsp;		
<b class="fc"><i>796</i>&nbsp;		hierarchyOverlay = new HierarchyOverlay(this.regionStore, overlayOptions, imageData);</b>
<b class="fc"><i>797</i>&nbsp;		tmaGridOverlay = new TMAGridOverlay(overlayOptions);</b>
<b class="fc"><i>798</i>&nbsp;		gridOverlay = new GridOverlay(overlayOptions);</b>
<i>799</i>&nbsp;//		pixelLayerOverlay = new PixelLayerOverlay(this);
<i>800</i>&nbsp;		// Set up the overlay layers
<b class="fc"><i>801</i>&nbsp;		coreOverlayLayers.setAll(</b>
<i>802</i>&nbsp;//				pixelLayerOverlay,
<i>803</i>&nbsp;				tmaGridOverlay,
<i>804</i>&nbsp;				hierarchyOverlay,
<i>805</i>&nbsp;				gridOverlay
<i>806</i>&nbsp;		);
<i>807</i>&nbsp;
<b class="fc"><i>808</i>&nbsp;		setImageData(imageData);</b>
<i>809</i>&nbsp;
<b class="fc"><i>810</i>&nbsp;		this.regionStore.addTileListener(this);</b>
<i>811</i>&nbsp;
<i>812</i>&nbsp;		//		updateCursor();
<b class="fc"><i>813</i>&nbsp;		imageUpdated = true;</b>
<i>814</i>&nbsp;
<b class="fc"><i>815</i>&nbsp;		if (tooltip != null) {</b>
<b class="nc"><i>816</i>&nbsp;			tooltip.setTextAlignment(TextAlignment.CENTER);</b>
<b class="nc"><i>817</i>&nbsp;			tooltip.activatedProperty().addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>818</i>&nbsp;				if (n) </b>
<b class="nc"><i>819</i>&nbsp;					updateTooltip(tooltip);</b>
<b class="nc"><i>820</i>&nbsp;			});</b>
<b class="nc"><i>821</i>&nbsp;			tooltip.setAutoHide(true);</b>
<b class="nc"><i>822</i>&nbsp;			Tooltip.install(getView(), tooltip);</b>
<i>823</i>&nbsp;		}
<i>824</i>&nbsp;		
<i>825</i>&nbsp;		
<b class="fc"><i>826</i>&nbsp;		zPosition.addListener((v, o, n) -&gt; {</b>
<i>827</i>&nbsp;//			if (zPosition.get() == n)
<i>828</i>&nbsp;//				return;
<b class="nc"><i>829</i>&nbsp;			imageUpdated = true;</b>
<b class="nc"><i>830</i>&nbsp;			updateThumbnail(false);</b>
<b class="nc"><i>831</i>&nbsp;			repaint();</b>
<b class="nc"><i>832</i>&nbsp;			fireVisibleRegionChangedEvent(getDisplayedRegionShape());</b>
<b class="nc"><i>833</i>&nbsp;		});</b>
<i>834</i>&nbsp;		
<i>835</i>&nbsp;		
<b class="fc"><i>836</i>&nbsp;		tPosition.addListener((v, o, n) -&gt; {</b>
<i>837</i>&nbsp;//			if (zPosition.get() == n)
<i>838</i>&nbsp;//				return;
<b class="nc"><i>839</i>&nbsp;			imageUpdated = true;</b>
<b class="nc"><i>840</i>&nbsp;			updateThumbnail(false);</b>
<b class="nc"><i>841</i>&nbsp;			repaint();</b>
<b class="nc"><i>842</i>&nbsp;			fireVisibleRegionChangedEvent(getDisplayedRegionShape());</b>
<b class="nc"><i>843</i>&nbsp;		});</b>
<i>844</i>&nbsp;		
<b class="fc"><i>845</i>&nbsp;		zoomToFit.addListener((v, o, n) -&gt; {</b>
<b class="nc"><i>846</i>&nbsp;			if (zoomToFit.get()) {</b>
<b class="nc"><i>847</i>&nbsp;				setDownsampleFactorImpl(getZoomToFitDownsampleFactor(), -1, -1);</b>
<b class="nc"><i>848</i>&nbsp;				centerImage();</b>
<i>849</i>&nbsp;			}
<b class="nc"><i>850</i>&nbsp;			imageUpdated = true;</b>
<b class="nc"><i>851</i>&nbsp;			repaint();</b>
<b class="nc"><i>852</i>&nbsp;		});</b>
<b class="fc"><i>853</i>&nbsp;	}</b>
<i>854</i>&nbsp;
<i>855</i>&nbsp;	/**
<i>856</i>&nbsp;	 * Property for the image data currently being displayed within this viewer.
<i>857</i>&nbsp;	 * @return
<i>858</i>&nbsp;	 */
<i>859</i>&nbsp;	public ReadOnlyObjectProperty&lt;ImageData&lt;BufferedImage&gt;&gt; imageDataProperty() {
<b class="nc"><i>860</i>&nbsp;		return imageDataProperty;</b>
<i>861</i>&nbsp;	}
<i>862</i>&nbsp;	
<i>863</i>&nbsp;	/**
<i>864</i>&nbsp;	 * Get the image data currently being displayed within thie viewer.
<i>865</i>&nbsp;	 * @return
<i>866</i>&nbsp;	 */
<i>867</i>&nbsp;	public ImageData&lt;BufferedImage&gt; getImageData() {
<b class="fc"><i>868</i>&nbsp;		return imageDataProperty.get();</b>
<i>869</i>&nbsp;	}
<i>870</i>&nbsp;
<i>871</i>&nbsp;	/**
<i>872</i>&nbsp;	 * Get the overlay options that control the viewer display.
<i>873</i>&nbsp;	 * @return
<i>874</i>&nbsp;	 */
<i>875</i>&nbsp;	public OverlayOptions getOverlayOptions() {
<b class="fc"><i>876</i>&nbsp;		return overlayOptions;</b>
<i>877</i>&nbsp;	}
<i>878</i>&nbsp;
<i>879</i>&nbsp;	/**
<i>880</i>&nbsp;	 * Get the region store used by this viewer for tile caching and painting.
<i>881</i>&nbsp;	 * @return
<i>882</i>&nbsp;	 */
<i>883</i>&nbsp;	public DefaultImageRegionStore getImageRegionStore() {
<b class="nc"><i>884</i>&nbsp;		return regionStore;</b>
<i>885</i>&nbsp;	}
<i>886</i>&nbsp;
<i>887</i>&nbsp;
<i>888</i>&nbsp;	/**
<i>889</i>&nbsp;	 * Set flag to indicate that repaints should prefer speed over accuracy.  This is useful when scrolling quickly, or rapidly changing
<i>890</i>&nbsp;	 * the image zoom.
<i>891</i>&nbsp;	 * &lt;p&gt;
<i>892</i>&nbsp;	 * Note: Previously, this would drop the downsample level - but this produced visual artifacts too often.  
<i>893</i>&nbsp;	 * Currently it only impacts interpolation used.
<i>894</i>&nbsp;	 * 
<i>895</i>&nbsp;	 * @param fasterRepaint
<i>896</i>&nbsp;	 */
<i>897</i>&nbsp;	public void setDoFasterRepaint(boolean fasterRepaint) {
<b class="nc"><i>898</i>&nbsp;		if (this.doFasterRepaint == fasterRepaint)</b>
<b class="nc"><i>899</i>&nbsp;			return;</b>
<b class="nc"><i>900</i>&nbsp;		this.imageUpdated = true;</b>
<b class="nc"><i>901</i>&nbsp;		this.doFasterRepaint = fasterRepaint;</b>
<b class="nc"><i>902</i>&nbsp;		repaint();</b>
<b class="nc"><i>903</i>&nbsp;	}</b>
<i>904</i>&nbsp;
<i>905</i>&nbsp;	/**
<i>906</i>&nbsp;	 * Get the current cursor position within this viewer, or null if the cursor is outside the viewer.
<i>907</i>&nbsp;	 * This is provided in the component space.
<i>908</i>&nbsp;	 * @return
<i>909</i>&nbsp;	 */
<i>910</i>&nbsp;	public Point2D getMousePosition() {
<b class="nc"><i>911</i>&nbsp;		if (mouseX &gt;= 0 &amp;&amp; mouseX &lt;= canvas.getWidth() &amp;&amp; mouseY &gt;= 0 &amp;&amp; mouseY &lt;= canvas.getWidth())</b>
<b class="nc"><i>912</i>&nbsp;			return new Point2D.Double(mouseX, mouseY);</b>
<b class="nc"><i>913</i>&nbsp;		return null;</b>
<i>914</i>&nbsp;	}
<i>915</i>&nbsp;	
<i>916</i>&nbsp;
<i>917</i>&nbsp;	private void setOverlayOptions(OverlayOptions overlayOptions) {
<b class="fc"><i>918</i>&nbsp;		if (this.overlayOptions == overlayOptions)</b>
<b class="nc"><i>919</i>&nbsp;			return;</b>
<b class="fc"><i>920</i>&nbsp;		if (this.overlayOptions != null) {</b>
<b class="nc"><i>921</i>&nbsp;			overlayOptionsManager.detachAll();</b>
<i>922</i>&nbsp;//			this.overlayOptions.removePropertyChangeListener(this);
<i>923</i>&nbsp;		}
<b class="fc"><i>924</i>&nbsp;		this.overlayOptions = overlayOptions;</b>
<b class="fc"><i>925</i>&nbsp;		if (overlayOptions != null) {</b>
<i>926</i>&nbsp;			
<b class="fc"><i>927</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.fillDetectionsProperty(), repainterOverlay);</b>
<b class="fc"><i>928</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.hiddenClassesProperty(), repainterOverlay);</b>
<b class="fc"><i>929</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.measurementMapperProperty(), repainterOverlay);</b>
<b class="fc"><i>930</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.detectionDisplayModeProperty(), repainterOverlay);</b>
<b class="fc"><i>931</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.showConnectionsProperty(), repainterOverlay);</b>
<i>932</i>&nbsp;
<b class="fc"><i>933</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.showAnnotationsProperty(), repainter);</b>
<b class="fc"><i>934</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.showNamesProperty(), repainter);</b>
<b class="fc"><i>935</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.fillAnnotationsProperty(), repainter);</b>
<b class="fc"><i>936</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.showDetectionsProperty(), repainter);</b>
<b class="fc"><i>937</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.showPixelClassificationProperty(), repainter);</b>
<b class="fc"><i>938</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.pixelClassificationFilterRegionProperty(), repainter);</b>
<b class="fc"><i>939</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.gridLinesProperty(), repainter);</b>
<b class="fc"><i>940</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.showTMACoreLabelsProperty(), repainter);</b>
<b class="fc"><i>941</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.showGridProperty(), repainter);</b>
<b class="fc"><i>942</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.showTMAGridProperty(), repainter);</b>
<b class="fc"><i>943</i>&nbsp;			overlayOptionsManager.attachListener(overlayOptions.opacityProperty(), repainter);</b>
<i>944</i>&nbsp;
<i>945</i>&nbsp;		}
<b class="fc"><i>946</i>&nbsp;		if (isShowing())</b>
<b class="nc"><i>947</i>&nbsp;			repaint();</b>
<b class="fc"><i>948</i>&nbsp;	}</b>
<i>949</i>&nbsp;
<i>950</i>&nbsp;	/**
<i>951</i>&nbsp;	 * Returns true if the viewer is visible, and attached to a scene.
<i>952</i>&nbsp;	 * @return
<i>953</i>&nbsp;	 */
<i>954</i>&nbsp;	public boolean isShowing() {
<b class="fc"><i>955</i>&nbsp;		return canvas != null &amp;&amp; canvas.isVisible() &amp;&amp; canvas.getScene() != null;</b>
<i>956</i>&nbsp;	}
<i>957</i>&nbsp;	
<i>958</i>&nbsp;
<i>959</i>&nbsp;
<i>960</i>&nbsp;	protected void initializeForServer(ImageServer&lt;BufferedImage&gt; server) {
<i>961</i>&nbsp;		// Note that the image has updated
<b class="fc"><i>962</i>&nbsp;		imageUpdated = true;</b>
<i>963</i>&nbsp;
<b class="fc"><i>964</i>&nbsp;		if (server == null) {</b>
<b class="fc"><i>965</i>&nbsp;			zPosition.set(0);</b>
<b class="fc"><i>966</i>&nbsp;			tPosition.set(0);</b>
<b class="fc"><i>967</i>&nbsp;			return;</b>
<i>968</i>&nbsp;		}
<i>969</i>&nbsp;
<b class="fc"><i>970</i>&nbsp;		zPosition.set(server.nZSlices() / 2);</b>
<b class="fc"><i>971</i>&nbsp;		tPosition.set(0);</b>
<b class="fc"><i>972</i>&nbsp;		updateThumbnail();</b>
<i>973</i>&nbsp;
<i>974</i>&nbsp;//		if (thumbnailIsFullImage)
<i>975</i>&nbsp;//			overlayOptions.setThinStrokeThickness(1f);
<i>976</i>&nbsp;//		else
<i>977</i>&nbsp;//			overlayOptions.setThinStrokeThickness(2f);
<i>978</i>&nbsp;
<i>979</i>&nbsp;		// Reset the suggested color for the scalebar &amp; grid
<b class="fc"><i>980</i>&nbsp;		colorOverlaySuggested = null;</b>
<b class="fc"><i>981</i>&nbsp;	}</b>
<i>982</i>&nbsp;
<i>983</i>&nbsp;
<i>984</i>&nbsp;	/**
<i>985</i>&nbsp;	 * Returns true if the spacebar was pressed when this component was focussed, and is still being held down.
<i>986</i>&nbsp;	 * @return
<i>987</i>&nbsp;	 */
<i>988</i>&nbsp;	public boolean isSpaceDown() {
<b class="nc"><i>989</i>&nbsp;		return spaceDown;</b>
<i>990</i>&nbsp;	}
<i>991</i>&nbsp;	
<i>992</i>&nbsp;	
<i>993</i>&nbsp;	/**
<i>994</i>&nbsp;	 * Notify this viewer that the isSpaceDown status should be changed.
<i>995</i>&nbsp;	 * &lt;p&gt;
<i>996</i>&nbsp;	 * This is useful whenever another component might have received the event,
<i>997</i>&nbsp;	 * but the viewer needs to &#39;know&#39; when it receives the focus.
<i>998</i>&nbsp;	 * 
<i>999</i>&nbsp;	 * @param spaceDown
<i>1000</i>&nbsp;	 */
<i>1001</i>&nbsp;	public void setSpaceDown(boolean spaceDown) {
<b class="nc"><i>1002</i>&nbsp;		if (this.spaceDown == spaceDown)</b>
<b class="nc"><i>1003</i>&nbsp;			return;</b>
<b class="nc"><i>1004</i>&nbsp; 		this.spaceDown = spaceDown;</b>
<b class="nc"><i>1005</i>&nbsp;		var activeTool = currentTool.get();</b>
<b class="nc"><i>1006</i>&nbsp;		if (activeTool != PathTools.MOVE &amp;&amp; activeTool != null) {</b>
<b class="nc"><i>1007</i>&nbsp;			if (spaceDown) {</b>
<i>1008</i>&nbsp;				// Temporarily switch to &#39;move&#39; tool
<b class="nc"><i>1009</i>&nbsp;				if (activeTool != null)</b>
<b class="nc"><i>1010</i>&nbsp;					activeTool.deregisterTool(this);</b>
<b class="nc"><i>1011</i>&nbsp;				activeTool = PathTools.MOVE;</b>
<b class="nc"><i>1012</i>&nbsp;				if (activeTool != null)</b>
<b class="nc"><i>1013</i>&nbsp;					activeTool.registerTool(this);</b>
<i>1014</i>&nbsp;			} else {
<i>1015</i>&nbsp;				// Reset tool, as required
<b class="nc"><i>1016</i>&nbsp;				PathTools.MOVE.deregisterTool(this);</b>
<b class="nc"><i>1017</i>&nbsp;				activeTool.registerTool(this);</b>
<i>1018</i>&nbsp;			}
<i>1019</i>&nbsp;		}
<b class="nc"><i>1020</i>&nbsp;		logger.trace(&quot;Setting space down to {} - active tool {}&quot;, spaceDown, activeTool);</b>
<b class="nc"><i>1021</i>&nbsp;		updateCursor();</b>
<b class="nc"><i>1022</i>&nbsp;	}</b>
<i>1023</i>&nbsp;
<i>1024</i>&nbsp;
<i>1025</i>&nbsp;	private static int getMeanBrightnessRGB(final BufferedImage img, int x, int y, int w, int h) {
<b class="fc"><i>1026</i>&nbsp;		if (img == null)</b>
<b class="nc"><i>1027</i>&nbsp;			return 0;</b>
<b class="fc"><i>1028</i>&nbsp;		double sum = 0;</b>
<b class="fc"><i>1029</i>&nbsp;		if (w &lt; 0)</b>
<b class="nc"><i>1030</i>&nbsp;			w = img.getWidth();</b>
<b class="fc"><i>1031</i>&nbsp;		if (h &lt; 0)</b>
<b class="nc"><i>1032</i>&nbsp;			h = img.getHeight();</b>
<b class="fc"><i>1033</i>&nbsp;		int[] pixels = new int[w * h];</b>
<b class="fc"><i>1034</i>&nbsp;		img.getRGB(x, y, w, h, pixels, 0, w);</b>
<b class="fc"><i>1035</i>&nbsp;		double scale = 1. / (3. * w * h); // To convert to mean</b>
<b class="fc"><i>1036</i>&nbsp;		for (int c : pixels) {</b>
<b class="fc"><i>1037</i>&nbsp;			int r = (c &amp; ColorTools.MASK_RED) &gt;&gt; 16;</b>
<b class="fc"><i>1038</i>&nbsp;		int g = (c &amp; ColorTools.MASK_GREEN) &gt;&gt; 8;</b>
<b class="fc"><i>1039</i>&nbsp;		int b = c &amp; ColorTools.MASK_BLUE;</b>
<b class="fc"><i>1040</i>&nbsp;		sum += (r + g + b) * scale;</b>
<i>1041</i>&nbsp;		}
<i>1042</i>&nbsp;		// Convert to mean brightness
<b class="fc"><i>1043</i>&nbsp;		return (int)(sum + .5);</b>
<i>1044</i>&nbsp;	}
<i>1045</i>&nbsp;
<i>1046</i>&nbsp;	/**
<i>1047</i>&nbsp;	 * Update colorOverlaySuggested from the entire (RGB, i.e. color-transformed) image thumbnail
<i>1048</i>&nbsp;	 */
<i>1049</i>&nbsp;	void updateSuggestedOverlayColorFromThumbnail() {
<b class="fc"><i>1050</i>&nbsp;		if (getMeanBrightnessRGB(imgThumbnailRGB, 0, 0, imgThumbnailRGB.getWidth(), imgThumbnailRGB.getHeight()) &gt; 127)</b>
<b class="fc"><i>1051</i>&nbsp;			colorOverlaySuggested = ColorToolsAwt.TRANSLUCENT_BLACK;</b>
<i>1052</i>&nbsp;		else
<b class="nc"><i>1053</i>&nbsp;			colorOverlaySuggested = ColorToolsAwt.TRANSLUCENT_WHITE;</b>
<b class="fc"><i>1054</i>&nbsp;	}</b>
<i>1055</i>&nbsp;
<i>1056</i>&nbsp;
<i>1057</i>&nbsp;	Color getSuggestedOverlayColor() {
<b class="fc"><i>1058</i>&nbsp;		if (colorOverlaySuggested == null)</b>
<b class="fc"><i>1059</i>&nbsp;			updateSuggestedOverlayColorFromThumbnail();</b>
<b class="fc"><i>1060</i>&nbsp;		return colorOverlaySuggested;</b>
<i>1061</i>&nbsp;	}
<i>1062</i>&nbsp;	
<i>1063</i>&nbsp;	javafx.scene.paint.Color getSuggestedOverlayColorFX() {
<b class="fc"><i>1064</i>&nbsp;		Color c = getSuggestedOverlayColor();</b>
<b class="fc"><i>1065</i>&nbsp;		if (c == ColorToolsAwt.TRANSLUCENT_BLACK)</b>
<b class="fc"><i>1066</i>&nbsp;			return ColorToolsFX.TRANSLUCENT_BLACK_FX;</b>
<i>1067</i>&nbsp;//		else if (c == DisplayHelpers.TRANSLUCENT_WHITE):
<b class="nc"><i>1068</i>&nbsp;			return ColorToolsFX.TRANSLUCENT_WHITE_FX;</b>
<i>1069</i>&nbsp;	}
<i>1070</i>&nbsp;
<i>1071</i>&nbsp;
<i>1072</i>&nbsp;	/**
<i>1073</i>&nbsp;	 * Get the x-coordinate of the pixel currently centered in the viewer, in the full size image space.
<i>1074</i>&nbsp;	 * @return
<i>1075</i>&nbsp;	 */
<i>1076</i>&nbsp;	public double getCenterPixelX() {
<b class="nc"><i>1077</i>&nbsp;		return xCenter;</b>
<i>1078</i>&nbsp;	}
<i>1079</i>&nbsp;
<i>1080</i>&nbsp;	/**
<i>1081</i>&nbsp;	 * Get the y-coordinate of the pixel currently centered in the viewer, in the full size image space.
<i>1082</i>&nbsp;	 * @return
<i>1083</i>&nbsp;	 */
<i>1084</i>&nbsp;	public double getCenterPixelY() {
<b class="nc"><i>1085</i>&nbsp;		return yCenter;</b>
<i>1086</i>&nbsp;	}
<i>1087</i>&nbsp;
<i>1088</i>&nbsp;	/**
<i>1089</i>&nbsp;	 * Set the active {@link PathTool} for input to this viewer.
<i>1090</i>&nbsp;	 * @param tool
<i>1091</i>&nbsp;	 */
<i>1092</i>&nbsp;	public void setActiveTool(PathTool tool) {
<b class="fc"><i>1093</i>&nbsp;		logger.trace(&quot;Setting tool {} for {}&quot;, tool, this);</b>
<b class="fc"><i>1094</i>&nbsp;		var activeTool = currentTool.get();</b>
<b class="fc"><i>1095</i>&nbsp;		if (activeTool != null)</b>
<b class="fc"><i>1096</i>&nbsp;			activeTool.deregisterTool(this);</b>
<b class="fc"><i>1097</i>&nbsp;		this.currentTool.set(tool);</b>
<b class="fc"><i>1098</i>&nbsp;		if (tool != null)</b>
<b class="fc"><i>1099</i>&nbsp;			tool.registerTool(this);</b>
<b class="fc"><i>1100</i>&nbsp;		updateCursor();</b>
<b class="fc"><i>1101</i>&nbsp;		updateRoiEditor();</b>
<b class="fc"><i>1102</i>&nbsp;	}</b>
<i>1103</i>&nbsp;	
<i>1104</i>&nbsp;	/**
<i>1105</i>&nbsp;	 * Get the active {@link PathTool} for this viewer.
<i>1106</i>&nbsp;	 * Note that this is not necessarily identical to the result of the last call to {@link #setActiveTool(PathTool)},
<i>1107</i>&nbsp;	 * because it may be modified by other behavior (e.g. pressing the spacebar to temporarily activate the Move tool).
<i>1108</i>&nbsp;	 * @return
<i>1109</i>&nbsp;	 */
<i>1110</i>&nbsp;	public PathTool getActiveTool() {
<i>1111</i>&nbsp;		// Always navigate when the spacebar is down
<b class="fc"><i>1112</i>&nbsp;		if (spaceDown)</b>
<b class="nc"><i>1113</i>&nbsp;			return PathTools.MOVE;</b>
<b class="fc"><i>1114</i>&nbsp;		return currentTool.get();</b>
<i>1115</i>&nbsp;	}
<i>1116</i>&nbsp;
<i>1117</i>&nbsp;	
<i>1118</i>&nbsp;	protected void updateCursor() {
<i>1119</i>&nbsp;//		logger.debug(&quot;Requested cursor {} for {}&quot;, requestedCursor, getMode());
<b class="fc"><i>1120</i>&nbsp;		PathTool mode = getActiveTool();</b>
<b class="fc"><i>1121</i>&nbsp;		if (mode == PathTools.MOVE)</b>
<b class="fc"><i>1122</i>&nbsp;			getView().setCursor(Cursor.HAND);</b>
<i>1123</i>&nbsp;		else
<b class="nc"><i>1124</i>&nbsp;			getView().setCursor(requestedCursor);</b>
<b class="fc"><i>1125</i>&nbsp;	}</b>
<i>1126</i>&nbsp;	
<i>1127</i>&nbsp;	/**
<i>1128</i>&nbsp;	 * Get the current cursor for this viewer
<i>1129</i>&nbsp;	 * @return
<i>1130</i>&nbsp;	 */
<i>1131</i>&nbsp;	public Cursor getCursor() {
<b class="fc"><i>1132</i>&nbsp;		return getView().getCursor();</b>
<i>1133</i>&nbsp;	}
<i>1134</i>&nbsp;	
<i>1135</i>&nbsp;	/**
<i>1136</i>&nbsp;	 * Set the requested cursor to display in this viewer
<i>1137</i>&nbsp;	 * @param cursor
<i>1138</i>&nbsp;	 */
<i>1139</i>&nbsp;	public void setCursor(Cursor cursor) {
<b class="fc"><i>1140</i>&nbsp;		this.requestedCursor = cursor;</b>
<b class="fc"><i>1141</i>&nbsp;		updateCursor();</b>
<b class="fc"><i>1142</i>&nbsp;	}</b>
<i>1143</i>&nbsp;	
<i>1144</i>&nbsp;	/**
<i>1145</i>&nbsp;	 * Get the currently-selected object from the hierarchy.
<i>1146</i>&nbsp;	 * @return
<i>1147</i>&nbsp;	 */
<i>1148</i>&nbsp;	public PathObject getSelectedObject() {
<b class="fc"><i>1149</i>&nbsp;		PathObjectHierarchy hierarchy = getHierarchy();</b>
<b class="fc"><i>1150</i>&nbsp;		if (hierarchy == null)</b>
<b class="fc"><i>1151</i>&nbsp;			return null;</b>
<i>1152</i>&nbsp;		else
<b class="fc"><i>1153</i>&nbsp;			return hierarchy.getSelectionModel().getSelectedObject();</b>
<i>1154</i>&nbsp;	}
<i>1155</i>&nbsp;	
<i>1156</i>&nbsp;	/**
<i>1157</i>&nbsp;	 * Get all currently-selected objects from the hierarchy.
<i>1158</i>&nbsp;	 * @return
<i>1159</i>&nbsp;	 */
<i>1160</i>&nbsp;	public Collection&lt;PathObject&gt; getAllSelectedObjects() {
<b class="nc"><i>1161</i>&nbsp;		PathObjectHierarchy hierarchy = getHierarchy();</b>
<b class="nc"><i>1162</i>&nbsp;		if (hierarchy == null)</b>
<b class="nc"><i>1163</i>&nbsp;			return Collections.emptyList();</b>
<i>1164</i>&nbsp;		else
<b class="nc"><i>1165</i>&nbsp;			return hierarchy.getSelectionModel().getSelectedObjects();</b>
<i>1166</i>&nbsp;	}
<i>1167</i>&nbsp;		
<i>1168</i>&nbsp;	/**
<i>1169</i>&nbsp;	 * Optionally set a custom overlay to use for the pixel layer.
<i>1170</i>&nbsp;	 * &lt;p&gt;
<i>1171</i>&nbsp;	 * This is useful to support live prediction based on a specific field of view, for example.
<i>1172</i>&nbsp;	 * 
<i>1173</i>&nbsp;	 * @param pathOverlay
<i>1174</i>&nbsp;	 */
<i>1175</i>&nbsp;	public void setCustomPixelLayerOverlay(PathOverlay pathOverlay) {
<b class="nc"><i>1176</i>&nbsp;		if (this.customPixelLayerOverlay == pathOverlay)</b>
<b class="nc"><i>1177</i>&nbsp;			return;</b>
<i>1178</i>&nbsp;		// Get existing custom overlay
<b class="nc"><i>1179</i>&nbsp;		var previousOverlay = getCurrentPixelLayerOverlay();</b>
<b class="nc"><i>1180</i>&nbsp;		int ind = coreOverlayLayers.indexOf(previousOverlay);</b>
<b class="nc"><i>1181</i>&nbsp;		this.customPixelLayerOverlay = pathOverlay;</b>
<b class="nc"><i>1182</i>&nbsp;		if (this.customPixelLayerOverlay == null) {</b>
<b class="nc"><i>1183</i>&nbsp;			if (ind &gt;= 0)</b>
<b class="nc"><i>1184</i>&nbsp;				coreOverlayLayers.remove(ind);</b>
<b class="nc"><i>1185</i>&nbsp;		} else if (ind &lt; 0) {</b>
<b class="nc"><i>1186</i>&nbsp;			coreOverlayLayers.add(0, this.customPixelLayerOverlay);</b>
<i>1187</i>&nbsp;		} else {
<b class="nc"><i>1188</i>&nbsp;			coreOverlayLayers.set(ind, this.customPixelLayerOverlay);</b>
<i>1189</i>&nbsp;		}
<i>1190</i>&nbsp;				
<i>1191</i>&nbsp;//		// Get existing custom overlay
<i>1192</i>&nbsp;//		var previousOverlay = getCurrentPixelLayerOverlay();
<i>1193</i>&nbsp;//		int ind = coreOverlayLayers.indexOf(previousOverlay);
<i>1194</i>&nbsp;//		this.customPixelLayerOverlay = pathOverlay;
<i>1195</i>&nbsp;//		if (ind &lt; 0) {
<i>1196</i>&nbsp;//			logger.warn(&quot;Pixel layer overlay not found! Will try to recover...&quot;);
<i>1197</i>&nbsp;//			coreOverlayLayers.removeAll(pixelLayerOverlay, customPixelLayerOverlay);
<i>1198</i>&nbsp;//			coreOverlayLayers.add(0, getCurrentPixelLayerOverlay());
<i>1199</i>&nbsp;//		} else {
<i>1200</i>&nbsp;//			coreOverlayLayers.set(ind, getCurrentPixelLayerOverlay());
<i>1201</i>&nbsp;//		}
<b class="nc"><i>1202</i>&nbsp;	}</b>
<i>1203</i>&nbsp;	
<i>1204</i>&nbsp;	/**
<i>1205</i>&nbsp;	 * Reset the custom pixel layer overlay to null.
<i>1206</i>&nbsp;	 */
<i>1207</i>&nbsp;	public void resetCustomPixelLayerOverlay() {
<b class="nc"><i>1208</i>&nbsp;		setCustomPixelLayerOverlay(null);</b>
<b class="nc"><i>1209</i>&nbsp;	}</b>
<i>1210</i>&nbsp;
<i>1211</i>&nbsp;	
<i>1212</i>&nbsp;	private PathOverlay getCurrentPixelLayerOverlay() {
<b class="nc"><i>1213</i>&nbsp;		return customPixelLayerOverlay;</b>
<i>1214</i>&nbsp;//		return customPixelLayerOverlay == null ? pixelLayerOverlay : customPixelLayerOverlay;
<i>1215</i>&nbsp;	}
<i>1216</i>&nbsp;	
<i>1217</i>&nbsp;
<i>1218</i>&nbsp;	/**
<i>1219</i>&nbsp;	 * Get the custom pixel layer overlay, or null if it has not be set.
<i>1220</i>&nbsp;	 * 
<i>1221</i>&nbsp;	 * @return
<i>1222</i>&nbsp;	 */
<i>1223</i>&nbsp;	public PathOverlay getCustomPixelLayerOverlay() {
<b class="nc"><i>1224</i>&nbsp;		return customPixelLayerOverlay;</b>
<i>1225</i>&nbsp;	}
<i>1226</i>&nbsp;
<i>1227</i>&nbsp;	/**
<i>1228</i>&nbsp;	 * Get the current ROI, i.e. the ROI belonging to the currently-selected object - or null, if there is no object or if the selected object has no ROI.
<i>1229</i>&nbsp;	 * @return
<i>1230</i>&nbsp;	 */
<i>1231</i>&nbsp;	public ROI getCurrentROI() {
<b class="fc"><i>1232</i>&nbsp;		PathObject selectedObject = getSelectedObject();</b>
<b class="fc"><i>1233</i>&nbsp;		return selectedObject == null ? null : selectedObject.getROI();</b>
<i>1234</i>&nbsp;	}
<i>1235</i>&nbsp;
<i>1236</i>&nbsp;	
<i>1237</i>&nbsp;	/**
<i>1238</i>&nbsp;	 * Set selected object in the current hierarchy, without centering the viewer.
<i>1239</i>&nbsp;	 * 
<i>1240</i>&nbsp;	 * @param pathObject
<i>1241</i>&nbsp;	 */
<i>1242</i>&nbsp;	public void setSelectedObject(PathObject pathObject) {
<b class="fc"><i>1243</i>&nbsp;		setSelectedObject(pathObject, false);</b>
<b class="fc"><i>1244</i>&nbsp;	}</b>
<i>1245</i>&nbsp;	
<i>1246</i>&nbsp;	/**
<i>1247</i>&nbsp;	 * Set selected object in the current hierarchy, without centering the viewer.
<i>1248</i>&nbsp;	 * 
<i>1249</i>&nbsp;	 * @param pathObject
<i>1250</i>&nbsp;	 * @param addToSelected
<i>1251</i>&nbsp;	 */
<i>1252</i>&nbsp;	public void setSelectedObject(final PathObject pathObject, final boolean addToSelected) {
<b class="fc"><i>1253</i>&nbsp;		PathObjectHierarchy hierarchy = getHierarchy();</b>
<b class="fc"><i>1254</i>&nbsp;		if (hierarchy == null)</b>
<b class="fc"><i>1255</i>&nbsp;			return;</b>
<b class="fc"><i>1256</i>&nbsp;		hierarchy.getSelectionModel().setSelectedObject(pathObject, addToSelected);</b>
<b class="fc"><i>1257</i>&nbsp;	}</b>
<i>1258</i>&nbsp;
<i>1259</i>&nbsp;
<i>1260</i>&nbsp;	// TODO: Consider making thumbnail update private
<i>1261</i>&nbsp;	void updateThumbnail() {
<b class="fc"><i>1262</i>&nbsp;		updateThumbnail(true);</b>
<b class="fc"><i>1263</i>&nbsp;	}</b>
<i>1264</i>&nbsp;
<i>1265</i>&nbsp;
<i>1266</i>&nbsp;
<i>1267</i>&nbsp;	// TODO: Consider making thumbnail update private
<i>1268</i>&nbsp;	void updateThumbnail(final boolean updateOverlayColor) {
<b class="fc"><i>1269</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="fc"><i>1270</i>&nbsp;		if (server == null)</b>
<b class="fc"><i>1271</i>&nbsp;			return;</b>
<i>1272</i>&nbsp;
<i>1273</i>&nbsp;		// Read a thumbnail image
<i>1274</i>&nbsp;		try {
<b class="fc"><i>1275</i>&nbsp;			int z = GeneralTools.clipValue(getZPosition(), 0, server.nZSlices()-1);</b>
<b class="fc"><i>1276</i>&nbsp;			int t = GeneralTools.clipValue(getTPosition(), 0, server.nTimepoints()-1);</b>
<b class="fc"><i>1277</i>&nbsp;			BufferedImage imgThumbnail = regionStore.getThumbnail(server, z, t, true);</b>
<i>1278</i>&nbsp;//			BufferedImage imgThumbnail = regionStore.getThumbnail(server, getZPosition(), getTPosition(), true);
<b class="fc"><i>1279</i>&nbsp;			imgThumbnailRGB = createThumbnailRGB(imgThumbnail);</b>
<b class="fc"><i>1280</i>&nbsp;			thumbnailIsFullImage = imgThumbnailRGB.getWidth() == server.getWidth() &amp;&amp; imgThumbnailRGB.getHeight() == server.getHeight();</b>
<b class="fc"><i>1281</i>&nbsp;			if (updateOverlayColor)</b>
<b class="fc"><i>1282</i>&nbsp;				colorOverlaySuggested = null;</b>
<b class="nc"><i>1283</i>&nbsp;		} catch (IOException e) {</b>
<b class="nc"><i>1284</i>&nbsp;			imgThumbnailRGB = null;</b>
<b class="nc"><i>1285</i>&nbsp;			colorOverlaySuggested = null;</b>
<b class="nc"><i>1286</i>&nbsp;			logger.warn(&quot;Error requesting thumbnail {}&quot;, e.getLocalizedMessage());</b>
<b class="fc"><i>1287</i>&nbsp;		}</b>
<b class="fc"><i>1288</i>&nbsp;	}</b>
<i>1289</i>&nbsp;	
<i>1290</i>&nbsp;	/**
<i>1291</i>&nbsp;	 * Create an RGB thumbnail image using the current rendering settings.
<i>1292</i>&nbsp;	 * &lt;p&gt;
<i>1293</i>&nbsp;	 * Subclasses may choose to override this if a suitable image has been cached already.
<i>1294</i>&nbsp;	 * 
<i>1295</i>&nbsp;	 * @return
<i>1296</i>&nbsp;	 */
<i>1297</i>&nbsp;	BufferedImage createThumbnailRGB(BufferedImage imgThumbnail) throws IOException {
<b class="fc"><i>1298</i>&nbsp;		ImageRenderer renderer = getRenderer();</b>
<b class="fc"><i>1299</i>&nbsp;		if (renderer != null) // &amp;&amp; !server.isRGB()) // Transforms will be applied quickly to RGB images, so no need to cache transformed part now</b>
<b class="fc"><i>1300</i>&nbsp;			return renderer.applyTransforms(imgThumbnail, null);</b>
<i>1301</i>&nbsp;		else
<b class="nc"><i>1302</i>&nbsp;			return imgThumbnail;</b>
<i>1303</i>&nbsp;	}
<i>1304</i>&nbsp;	
<i>1305</i>&nbsp;	
<i>1306</i>&nbsp;	
<i>1307</i>&nbsp;	/**
<i>1308</i>&nbsp;	 * Request a renderer that converts image tiles into RGB images.
<i>1309</i>&nbsp;	 * &lt;p&gt;
<i>1310</i>&nbsp;	 * By default, this returns {@code getImageDisplay}.
<i>1311</i>&nbsp;	 * &lt;p&gt;
<i>1312</i>&nbsp;	 * Subclasses might override this, e.g. to use custom image viewers that select transforms some 
<i>1313</i>&nbsp;	 * other way.
<i>1314</i>&nbsp;	 * 
<i>1315</i>&nbsp;	 * @return
<i>1316</i>&nbsp;	 */
<i>1317</i>&nbsp;	protected ImageRenderer getRenderer() {
<b class="fc"><i>1318</i>&nbsp;		return getImageDisplay();</b>
<i>1319</i>&nbsp;	}
<i>1320</i>&nbsp;	
<i>1321</i>&nbsp;
<i>1322</i>&nbsp;
<i>1323</i>&nbsp;	/**
<i>1324</i>&nbsp;	 * Get a shape corresponding to the region of the image currently visible in this viewer.
<i>1325</i>&nbsp;	 * Coordinates are in the image space.
<i>1326</i>&nbsp;	 * 
<i>1327</i>&nbsp;	 * If no rotation is applied, the result will be an instance of java.awt.Rectangle.
<i>1328</i>&nbsp;	 * Otherwise it will be a Path2D with the rotated rectangle vertices.
<i>1329</i>&nbsp;	 * 
<i>1330</i>&nbsp;	 * @return
<i>1331</i>&nbsp;	 */
<i>1332</i>&nbsp;	public Shape getDisplayedRegionShape() {
<b class="fc"><i>1333</i>&nbsp;		return getDisplayedClipShape(null);</b>
<i>1334</i>&nbsp;	}
<i>1335</i>&nbsp;
<i>1336</i>&nbsp;
<i>1337</i>&nbsp;	/**
<i>1338</i>&nbsp;	 * Transform a clip shape into image coordinates for this viewer.
<i>1339</i>&nbsp;	 * The resulting shape coordinates are in the image space.
<i>1340</i>&nbsp;	 * 
<i>1341</i>&nbsp;	 * @param clip The clip shape, or null if the entire width &amp;amp; height of the component should be used.
<i>1342</i>&nbsp;	 * @return
<i>1343</i>&nbsp;	 */
<i>1344</i>&nbsp;	protected Shape getDisplayedClipShape(Shape clip) {
<i>1345</i>&nbsp;		Shape clip2;
<b class="fc"><i>1346</i>&nbsp;		if (clip == null)</b>
<b class="fc"><i>1347</i>&nbsp;			clip2 = new Rectangle2D.Double(0, 0, getWidth(), getHeight());</b>
<i>1348</i>&nbsp;		else
<b class="fc"><i>1349</i>&nbsp;			clip2 = clip;</b>
<i>1350</i>&nbsp;
<i>1351</i>&nbsp;		// Ideally we&#39;d return a rectangle if no rotations are applied, rather than some more complex shape
<b class="fc"><i>1352</i>&nbsp;		if (clip2 instanceof Rectangle2D &amp;&amp; getRotation() == 0) {</b>
<b class="fc"><i>1353</i>&nbsp;			Rectangle2D rect = (Rectangle2D)clip2;</b>
<b class="fc"><i>1354</i>&nbsp;			double[] coords = new double[]{rect.getMinX(), rect.getMinY(), rect.getMaxX(), rect.getMaxY()};</b>
<b class="fc"><i>1355</i>&nbsp;			transformInverse.transform(coords, 0, coords, 0, 2);</b>
<i>1356</i>&nbsp;			// Create a new rectangle if we need to - otherwise reuse one we just created (because clip == null)
<b class="fc"><i>1357</i>&nbsp;			if (rect == clip)</b>
<b class="fc"><i>1358</i>&nbsp;				rect = new Rectangle2D.Double();</b>
<b class="fc"><i>1359</i>&nbsp;			rect.setFrameFromDiagonal(coords[0], coords[1], coords[2], coords[3]);</b>
<b class="fc"><i>1360</i>&nbsp;			return rect;</b>
<i>1361</i>&nbsp;		}
<b class="nc"><i>1362</i>&nbsp;		return transformInverse.createTransformedShape(clip2);</b>
<i>1363</i>&nbsp;	}
<i>1364</i>&nbsp;
<i>1365</i>&nbsp;	/**
<i>1366</i>&nbsp;	 * Returns the value of {@link #zoomToFitProperty()}.
<i>1367</i>&nbsp;	 * @return
<i>1368</i>&nbsp;	 */
<i>1369</i>&nbsp;	public boolean getZoomToFit() {
<b class="fc"><i>1370</i>&nbsp;		return zoomToFit.get();</b>
<i>1371</i>&nbsp;	}
<i>1372</i>&nbsp;	
<i>1373</i>&nbsp;	/**
<i>1374</i>&nbsp;	 * Property to request that the downsample and location properties are adjusted automatically to fit the 
<i>1375</i>&nbsp;	 * current image within the available viewer component.
<i>1376</i>&nbsp;	 * @return
<i>1377</i>&nbsp;	 */
<i>1378</i>&nbsp;	public BooleanProperty zoomToFitProperty() {
<b class="fc"><i>1379</i>&nbsp;		return zoomToFit;</b>
<i>1380</i>&nbsp;	}
<i>1381</i>&nbsp;
<i>1382</i>&nbsp;	/**
<i>1383</i>&nbsp;	 * Get the {@link ImageServer} for the current image displayed within the viewer, or null if 
<i>1384</i>&nbsp;	 * no image is displayed.
<i>1385</i>&nbsp;	 * @return
<i>1386</i>&nbsp;	 */
<i>1387</i>&nbsp;	public ImageServer&lt;BufferedImage&gt; getServer() {
<b class="fc"><i>1388</i>&nbsp;		ImageData&lt;BufferedImage&gt; temp = imageDataProperty.get();</b>
<b class="fc"><i>1389</i>&nbsp;		return temp == null ? null : temp.getServer();</b>
<i>1390</i>&nbsp;	}
<i>1391</i>&nbsp;
<i>1392</i>&nbsp;	/**
<i>1393</i>&nbsp;	 * Returns true if there is currently an ImageServer being displayed in this viewer.
<i>1394</i>&nbsp;	 * @return
<i>1395</i>&nbsp;	 */
<i>1396</i>&nbsp;	public boolean hasServer() {
<b class="fc"><i>1397</i>&nbsp;		return getServer() != null;</b>
<i>1398</i>&nbsp;	}
<i>1399</i>&nbsp;
<i>1400</i>&nbsp;
<b class="fc"><i>1401</i>&nbsp;	private IntegerProperty tPosition = new SimpleIntegerProperty(0);</b>
<b class="fc"><i>1402</i>&nbsp;	private IntegerProperty zPosition = new SimpleIntegerProperty(0);</b>
<i>1403</i>&nbsp;
<i>1404</i>&nbsp;	/**
<i>1405</i>&nbsp;	 * Set the requested z-slice to be visible.
<i>1406</i>&nbsp;	 * @param zPos
<i>1407</i>&nbsp;	 */
<i>1408</i>&nbsp;	public void setZPosition(int zPos) {
<b class="nc"><i>1409</i>&nbsp;		zPosition.set(zPos);</b>
<b class="nc"><i>1410</i>&nbsp;	}</b>
<i>1411</i>&nbsp;
<i>1412</i>&nbsp;	/**
<i>1413</i>&nbsp;	 * Get the currently-visible time point.
<i>1414</i>&nbsp;	 * @return
<i>1415</i>&nbsp;	 */
<i>1416</i>&nbsp;	public int getTPosition() {
<b class="fc"><i>1417</i>&nbsp;		return tPosition.get();</b>
<i>1418</i>&nbsp;	}
<i>1419</i>&nbsp;
<i>1420</i>&nbsp;	/**
<i>1421</i>&nbsp;	 * Set the requested time point to be visible.
<i>1422</i>&nbsp;	 * @param tPosition
<i>1423</i>&nbsp;	 */
<i>1424</i>&nbsp;	public void setTPosition(int tPosition) {
<b class="nc"><i>1425</i>&nbsp;		this.tPosition.set(tPosition);</b>
<b class="nc"><i>1426</i>&nbsp;	}</b>
<i>1427</i>&nbsp;
<i>1428</i>&nbsp;	/**
<i>1429</i>&nbsp;	 * Get the currently-visible z-slice.
<i>1430</i>&nbsp;	 * @return
<i>1431</i>&nbsp;	 */
<i>1432</i>&nbsp;	public int getZPosition() {
<b class="fc"><i>1433</i>&nbsp;		return zPosition.get();</b>
<i>1434</i>&nbsp;	}
<i>1435</i>&nbsp;	
<i>1436</i>&nbsp;	/**
<i>1437</i>&nbsp;	 * Get the {@link ImagePlane} currently being displayed, including z and t positions. Channels are ignored.
<i>1438</i>&nbsp;	 * 
<i>1439</i>&nbsp;	 * @return
<i>1440</i>&nbsp;	 */
<i>1441</i>&nbsp;	public ImagePlane getImagePlane() {
<b class="nc"><i>1442</i>&nbsp;		return ImagePlane.getPlane(getZPosition(), getTPosition());</b>
<i>1443</i>&nbsp;	}
<i>1444</i>&nbsp;	
<i>1445</i>&nbsp;	/**
<i>1446</i>&nbsp;	 * Returns true between the time setImageData has been called, and before the first repaint has been completed.
<i>1447</i>&nbsp;	 * &lt;p&gt;
<i>1448</i>&nbsp;	 * This is useful to distinguish between view changes triggered by setting the ImageData, and those triggered 
<i>1449</i>&nbsp;	 * by panning/zooming.
<i>1450</i>&nbsp;	 * 
<i>1451</i>&nbsp;	 * @return
<i>1452</i>&nbsp;	 */
<i>1453</i>&nbsp;	public boolean isImageDataChanging() {
<b class="fc"><i>1454</i>&nbsp;		return imageDataChanging.get();</b>
<i>1455</i>&nbsp;	}
<i>1456</i>&nbsp;
<i>1457</i>&nbsp;	/**
<i>1458</i>&nbsp;	 * Set the current image for this viewer.
<i>1459</i>&nbsp;	 * @param imageDataNew
<i>1460</i>&nbsp;	 */
<i>1461</i>&nbsp;	public void setImageData(ImageData&lt;BufferedImage&gt; imageDataNew) {
<b class="fc"><i>1462</i>&nbsp;		System.out.println(&quot;in set image data&quot;);</b>
<b class="fc"><i>1463</i>&nbsp;		if (this.imageDataProperty.get() == imageDataNew)</b>
<b class="fc"><i>1464</i>&nbsp;			return;</b>
<i>1465</i>&nbsp;		
<b class="fc"><i>1466</i>&nbsp;		imageDataChanging.set(true);</b>
<i>1467</i>&nbsp;		
<i>1468</i>&nbsp;		// Remove listeners for previous hierarchy
<b class="fc"><i>1469</i>&nbsp;		ImageData&lt;BufferedImage&gt; imageDataOld = this.imageDataProperty.get();</b>
<b class="fc"><i>1470</i>&nbsp;		if (imageDataOld != null) {</b>
<b class="fc"><i>1471</i>&nbsp;			imageDataOld.getHierarchy().removePathObjectListener(this);</b>
<b class="fc"><i>1472</i>&nbsp;			imageDataOld.getHierarchy().getSelectionModel().removePathObjectSelectionListener(this);</b>
<i>1473</i>&nbsp;		}
<i>1474</i>&nbsp;		
<i>1475</i>&nbsp;		// Determine if the server has remained the same, so we can avoid shifting the viewer
<b class="fc"><i>1476</i>&nbsp;		boolean sameServer = false;</b>
<b class="fc"><i>1477</i>&nbsp;		if (imageDataOld != null &amp;&amp; imageDataNew != null &amp;&amp; imageDataOld.getServerPath().equals(imageDataNew.getServerPath()))</b>
<b class="nc"><i>1478</i>&nbsp;			sameServer = true;</b>
<i>1479</i>&nbsp;
<b class="fc"><i>1480</i>&nbsp;		this.imageDataProperty.set(imageDataNew);</b>
<b class="fc"><i>1481</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = imageDataNew == null ? null : imageDataNew.getServer();</b>
<b class="fc"><i>1482</i>&nbsp;		PathObjectHierarchy hierarchy = imageDataNew == null ? null : imageDataNew.getHierarchy();</b>
<i>1483</i>&nbsp;
<b class="fc"><i>1484</i>&nbsp;		long startTime = System.currentTimeMillis();</b>
<b class="fc"><i>1485</i>&nbsp;		if (imageDisplay != null) {</b>
<b class="fc"><i>1486</i>&nbsp;			boolean keepDisplay = PathPrefs.keepDisplaySettingsProperty().get();</b>
<i>1487</i>&nbsp;			// This is a bit of a hack to avoid calling internal methods for ImageDisplay
<i>1488</i>&nbsp;			// See https://github.com/qupath/qupath/issues/601
<b class="fc"><i>1489</i>&nbsp;			boolean displaySet = false;</b>
<b class="fc"><i>1490</i>&nbsp;			if (imageDataNew != null &amp;&amp; keepDisplay) {</b>
<b class="fc"><i>1491</i>&nbsp;				if (imageDisplay.getImageData() != null &amp;&amp; serversCompatible(imageDataNew.getServer(), imageDisplay.getImageData().getServer())) {</b>
<b class="nc"><i>1492</i>&nbsp;					imageDisplay.setImageData(imageDataNew, keepDisplay);</b>
<b class="nc"><i>1493</i>&nbsp;					displaySet = true;</b>
<i>1494</i>&nbsp;				} else {
<b class="fc"><i>1495</i>&nbsp;					for (var viewer : QuPathGUI.getInstance().getViewers()) {</b>
<b class="fc"><i>1496</i>&nbsp;						if (this == viewer || viewer.getImageData() == null)</b>
<b class="nc"><i>1497</i>&nbsp;							continue;</b>
<b class="nc"><i>1498</i>&nbsp;						var tempServer = viewer.getServer();</b>
<b class="nc"><i>1499</i>&nbsp;						var currentServer = imageDataNew.getServer();</b>
<b class="nc"><i>1500</i>&nbsp;						if (serversCompatible(tempServer, currentServer)) {</b>
<b class="nc"><i>1501</i>&nbsp;							var json = viewer.getImageDisplay().toJSON(false);</b>
<b class="nc"><i>1502</i>&nbsp;							imageDataNew.setProperty(ImageDisplay.class.getName(), json);</b>
<b class="nc"><i>1503</i>&nbsp;							imageDisplay.setImageData(imageDataNew, false);</b>
<b class="nc"><i>1504</i>&nbsp;							displaySet = true;</b>
<b class="nc"><i>1505</i>&nbsp;							break;</b>
<i>1506</i>&nbsp;						}
<b class="nc"><i>1507</i>&nbsp;					}</b>
<i>1508</i>&nbsp;				}
<i>1509</i>&nbsp;			}
<b class="fc"><i>1510</i>&nbsp;			if (!displaySet)</b>
<b class="fc"><i>1511</i>&nbsp;				imageDisplay.setImageData(imageDataNew, keepDisplay);</b>
<i>1512</i>&nbsp;		}
<b class="fc"><i>1513</i>&nbsp;		long endTime = System.currentTimeMillis();</b>
<b class="fc"><i>1514</i>&nbsp;		logger.debug(&quot;Setting ImageData time: {} ms&quot;, endTime - startTime);</b>
<i>1515</i>&nbsp;
<b class="fc"><i>1516</i>&nbsp;		initializeForServer(server);</b>
<i>1517</i>&nbsp;		
<b class="fc"><i>1518</i>&nbsp;		if (!sameServer) {</b>
<b class="fc"><i>1519</i>&nbsp;			setDownsampleFactorImpl(getZoomToFitDownsampleFactor(), -1, -1);</b>
<b class="fc"><i>1520</i>&nbsp;			centerImage();</b>
<i>1521</i>&nbsp;		}
<i>1522</i>&nbsp;
<b class="fc"><i>1523</i>&nbsp;		fireImageDataChanged(imageDataOld, imageDataNew);</b>
<i>1524</i>&nbsp;
<i>1525</i>&nbsp;		//		featureMapWrapper = new TiledFeatureMapImageWrapper(server.getWidth(), server.getHeight());
<i>1526</i>&nbsp;
<i>1527</i>&nbsp;//		// Notify overlays of change to ImageData
<i>1528</i>&nbsp;//		Iterator&lt;PathOverlay&gt; iter = allOverlayLayers.iterator();
<i>1529</i>&nbsp;//		while (iter.hasNext()) {
<i>1530</i>&nbsp;//			PathOverlay overlay = iter.next();
<i>1531</i>&nbsp;//			if (overlay instanceof ImageDataOverlay) {
<i>1532</i>&nbsp;//				ImageDataOverlay overlay2 = (ImageDataOverlay)overlay;
<i>1533</i>&nbsp;//				if (!overlay2.supportsImageDataChange()) {
<i>1534</i>&nbsp;//					// Remove any non-core overlay layers that don&#39;t support an ImageData change
<i>1535</i>&nbsp;//					if (!coreOverlayLayers.contains(overlay2))
<i>1536</i>&nbsp;//						iter.remove();
<i>1537</i>&nbsp;//					continue;
<i>1538</i>&nbsp;//				} else
<i>1539</i>&nbsp;//					overlay2.setImageData(imageDataNew);
<i>1540</i>&nbsp;//			}
<i>1541</i>&nbsp;//		}
<i>1542</i>&nbsp;		//		overlay.setImageData(imageData);
<i>1543</i>&nbsp;
<b class="fc"><i>1544</i>&nbsp;		if (imageDataNew != null) {</b>
<i>1545</i>&nbsp;			//			hierarchyPainter = new PathHierarchyPainter(hierarchy);
<b class="fc"><i>1546</i>&nbsp;			hierarchy.addPathObjectListener(this);</b>
<b class="fc"><i>1547</i>&nbsp;			hierarchy.getSelectionModel().addPathObjectSelectionListener(this);</b>
<i>1548</i>&nbsp;		}
<i>1549</i>&nbsp;
<b class="fc"><i>1550</i>&nbsp;		setSelectedObject(null);</b>
<i>1551</i>&nbsp;		
<i>1552</i>&nbsp;		// TODO: Consider shifting, fixing magnification, repainting etc.
<b class="fc"><i>1553</i>&nbsp;		if (isShowing())</b>
<b class="fc"><i>1554</i>&nbsp;			repaint();</b>
<i>1555</i>&nbsp;		
<b class="fc"><i>1556</i>&nbsp;		logger.info(&quot;Image data set to {}&quot;, imageDataNew);</b>
<b class="fc"><i>1557</i>&nbsp;	}</b>
<i>1558</i>&nbsp;	
<i>1559</i>&nbsp;	
<i>1560</i>&nbsp;	/**
<i>1561</i>&nbsp;	 * Check if two ImageServers are compatible in terms of display settings, i.e. having the same number, type and names for channels.
<i>1562</i>&nbsp;	 * @param currentServer
<i>1563</i>&nbsp;	 * @param tempServer
<i>1564</i>&nbsp;	 * @return true if the servers are compatible, false otherwise
<i>1565</i>&nbsp;	 */
<i>1566</i>&nbsp;	private static boolean serversCompatible(ImageServer&lt;BufferedImage&gt; currentServer, ImageServer&lt;BufferedImage&gt; tempServer) {
<b class="nc"><i>1567</i>&nbsp;		if (Objects.equals(currentServer, tempServer))</b>
<b class="nc"><i>1568</i>&nbsp;			return true;</b>
<b class="nc"><i>1569</i>&nbsp;		if (currentServer == null || tempServer == null)</b>
<b class="nc"><i>1570</i>&nbsp;			return false;</b>
<b class="nc"><i>1571</i>&nbsp;		if (tempServer.nChannels() == currentServer.nChannels() &amp;&amp; tempServer.getPixelType() == currentServer.getPixelType()) {</b>
<b class="nc"><i>1572</i>&nbsp;			var tempNames = tempServer.getMetadata().getChannels().stream().map(c -&gt; c.getName()).collect(Collectors.toList());</b>
<b class="nc"><i>1573</i>&nbsp;			var currentNames = currentServer.getMetadata().getChannels().stream().map(c -&gt; c.getName()).collect(Collectors.toList());</b>
<b class="nc"><i>1574</i>&nbsp;			return tempNames.equals(currentNames);</b>
<i>1575</i>&nbsp;		}
<b class="nc"><i>1576</i>&nbsp;		return false;</b>
<i>1577</i>&nbsp;	}
<i>1578</i>&nbsp;
<i>1579</i>&nbsp;	
<i>1580</i>&nbsp;	protected void fireImageDataChanged(ImageData&lt;BufferedImage&gt; imageDataPrevious, ImageData&lt;BufferedImage&gt; imageDataNew) {
<b class="fc"><i>1581</i>&nbsp;		for (QuPathViewerListener listener : listeners.toArray(new QuPathViewerListener[0]))</b>
<b class="fc"><i>1582</i>&nbsp;			listener.imageDataChanged(this, imageDataPrevious, imageDataNew);		</b>
<b class="fc"><i>1583</i>&nbsp;	}</b>
<i>1584</i>&nbsp;
<i>1585</i>&nbsp;	protected void fireVisibleRegionChangedEvent(Shape shape) {
<b class="fc"><i>1586</i>&nbsp;		for (QuPathViewerListener listener : listeners.toArray(new QuPathViewerListener[0]))</b>
<b class="fc"><i>1587</i>&nbsp;			listener.visibleRegionChanged(this, shape);		</b>
<b class="fc"><i>1588</i>&nbsp;	}</b>
<i>1589</i>&nbsp;
<i>1590</i>&nbsp;
<i>1591</i>&nbsp;	/**
<i>1592</i>&nbsp;	 * Request a region to repaint using image coordinates (rather than component coordinates).
<i>1593</i>&nbsp;	 * 
<i>1594</i>&nbsp;	 * @param region
<i>1595</i>&nbsp;	 * @param updateImage 
<i>1596</i>&nbsp;	 */
<i>1597</i>&nbsp;	private void repaintImageRegion(Rectangle2D region, boolean updateImage) {
<b class="fc"><i>1598</i>&nbsp;		Rectangle clipBounds = transform.createTransformedShape(region).getBounds();</b>
<i>1599</i>&nbsp;
<i>1600</i>&nbsp;		//		// Clip bounds are overestimated a bit to avoid trouble due to antialiasing
<i>1601</i>&nbsp;		//		Rectangle clipBounds = new Rectangle((int)((region.getX()-x)/downsampleFactor)-10,
<i>1602</i>&nbsp;		//        		(int)((region.getY()-y)/downsampleFactor)-10,
<i>1603</i>&nbsp;		//        		(int)(region.getWidth() / downsampleFactor + 20),
<i>1604</i>&nbsp;		//        		(int)(region.getHeight() / downsampleFactor + 20));
<b class="fc"><i>1605</i>&nbsp;		if (clipBounds.intersects(0, 0, getWidth(), getHeight())) {</b>
<b class="fc"><i>1606</i>&nbsp;			if (updateImage)</b>
<b class="fc"><i>1607</i>&nbsp;				imageUpdated = true;</b>
<i>1608</i>&nbsp;//			repaint(clipBounds);
<b class="fc"><i>1609</i>&nbsp;			repaint();</b>
<i>1610</i>&nbsp;		}
<b class="fc"><i>1611</i>&nbsp;	}</b>
<i>1612</i>&nbsp;	
<i>1613</i>&nbsp;	
<i>1614</i>&nbsp;	/**
<i>1615</i>&nbsp;	 * Request that the entire image is repainted, including the thumbnail.
<i>1616</i>&nbsp;	 * This should be called whenever a major change in display is triggered, such as 
<i>1617</i>&nbsp;	 * changing the brightness/contrast or lookup table.
<i>1618</i>&nbsp;	 * Otherwise, {@link #repaint()} is preferable.
<i>1619</i>&nbsp;	 * @see #repaint()
<i>1620</i>&nbsp;	 */
<i>1621</i>&nbsp;	public void repaintEntireImage() {
<b class="fc"><i>1622</i>&nbsp;		imageUpdated = true;</b>
<b class="fc"><i>1623</i>&nbsp;		if (imageDisplay != null)</b>
<b class="fc"><i>1624</i>&nbsp;			lastDisplayChangeTimestamp = imageDisplay.getLastChangeTimestamp();</b>
<b class="fc"><i>1625</i>&nbsp;		ensureGammaUpdated();</b>
<b class="fc"><i>1626</i>&nbsp;		updateThumbnail();</b>
<b class="fc"><i>1627</i>&nbsp;		repaint();		</b>
<b class="fc"><i>1628</i>&nbsp;	}</b>
<i>1629</i>&nbsp;
<i>1630</i>&nbsp;	/**
<i>1631</i>&nbsp;	 * Get the magnification for the image within this viewer, or Double.NaN if no image is present.
<i>1632</i>&nbsp;	 * This is mostly for display; {@link #getDownsampleFactor()} is more meaningful.
<i>1633</i>&nbsp;	 * The actual value of the magnification depends upon whether any magnification value is available 
<i>1634</i>&nbsp;	 * within the image metadata.
<i>1635</i>&nbsp;	 * @return
<i>1636</i>&nbsp;	 */
<i>1637</i>&nbsp;	public double getMagnification() {
<b class="nc"><i>1638</i>&nbsp;		if (!hasServer())</b>
<b class="nc"><i>1639</i>&nbsp;			return Double.NaN;</b>
<b class="nc"><i>1640</i>&nbsp;		return getFullMagnification() / getDownsampleFactor();</b>
<i>1641</i>&nbsp;	}
<i>1642</i>&nbsp;
<i>1643</i>&nbsp;	/**
<i>1644</i>&nbsp;	 * Get the full magnification for the image.
<i>1645</i>&nbsp;	 * This is either the magnification value stored within the current image metadata, 
<i>1646</i>&nbsp;	 * or 1.0 if no suitable image or metadata is available.
<i>1647</i>&nbsp;	 * @return
<i>1648</i>&nbsp;	 */
<i>1649</i>&nbsp;	public double getFullMagnification() {
<b class="nc"><i>1650</i>&nbsp;		if (!hasServer())</b>
<b class="nc"><i>1651</i>&nbsp;			return 1.0;</b>
<b class="nc"><i>1652</i>&nbsp;		double magnification = getServer().getMetadata().getMagnification();</b>
<b class="nc"><i>1653</i>&nbsp;		if (Double.isNaN(magnification))</b>
<b class="nc"><i>1654</i>&nbsp;			return 1.0;</b>
<i>1655</i>&nbsp;		else
<b class="nc"><i>1656</i>&nbsp;			return magnification;</b>
<i>1657</i>&nbsp;	}
<i>1658</i>&nbsp;
<i>1659</i>&nbsp;	/**
<i>1660</i>&nbsp;	 * Set the downsample factor based upon magnification values.
<i>1661</i>&nbsp;	 * In general, {@link #setDownsampleFactor(double)} should be used directly in preference to this method.
<i>1662</i>&nbsp;	 * @param magnification
<i>1663</i>&nbsp;	 */
<i>1664</i>&nbsp;	public void setMagnification(final double magnification) {
<b class="nc"><i>1665</i>&nbsp;		if (hasServer())</b>
<b class="nc"><i>1666</i>&nbsp;			setDownsampleFactor(getFullMagnification() / magnification);</b>
<b class="nc"><i>1667</i>&nbsp;	}</b>
<i>1668</i>&nbsp;
<i>1669</i>&nbsp;	/**
<i>1670</i>&nbsp;	 * Request that this viewer is closed.
<i>1671</i>&nbsp;	 * This unbinds the viewer from any properties it may be observing,
<i>1672</i>&nbsp;	 * and also triggers {@link QuPathViewerListener#viewerClosed(QuPathViewer)} calls for 
<i>1673</i>&nbsp;	 * any viewer listeners.
<i>1674</i>&nbsp;	 */
<i>1675</i>&nbsp;	public void closeViewer() {
<i>1676</i>&nbsp;		//		painter.close();
<b class="nc"><i>1677</i>&nbsp;		overlayOptionsManager.detachAll();</b>
<b class="nc"><i>1678</i>&nbsp;		overlayOptionsManager.clear();</b>
<b class="nc"><i>1679</i>&nbsp;		manager.detachAll();</b>
<b class="nc"><i>1680</i>&nbsp;		manager.clear();</b>
<b class="nc"><i>1681</i>&nbsp;		regionStore.removeTileListener(this);</b>
<i>1682</i>&nbsp;//		// Set the server to null
<i>1683</i>&nbsp;//		setImageData(null);
<i>1684</i>&nbsp;		// Notify listeners
<b class="nc"><i>1685</i>&nbsp;		for (QuPathViewerListener listener : listeners.toArray(new QuPathViewerListener[0]))</b>
<b class="nc"><i>1686</i>&nbsp;			listener.viewerClosed(this);</b>
<b class="nc"><i>1687</i>&nbsp;	}</b>
<i>1688</i>&nbsp;
<i>1689</i>&nbsp;
<i>1690</i>&nbsp;	/*
<i>1691</i>&nbsp;	 * Lessons from trying VolatileImages:
<i>1692</i>&nbsp;	 * 	- Repainting using BufferedImages is (at least on OSX) frustratingly slow; depending on window size, ~25-30 ms *just* for copying
<i>1693</i>&nbsp;	 * 		imgBuffer to screen (ignoring time taken to draw to imgBuffer in the first place, and to draw everything else)
<i>1694</i>&nbsp;	 *  - The trouble is that imgBuffer loses isAccelerated() when it is drawn to; when it remains static, drawing is extremely fast as it is accelerated in the background
<i>1695</i>&nbsp;	 *  - Avoiding imgBuffer and using a VolatileImage leads to improved performance, about ~9ms to draw to the image, and then copying to display seems instantaneous. But...
<i>1696</i>&nbsp;	 *  - Can&#39;t access pixels of VolatileImage directly, therefore any image display transforms can kill performance horribly
<i>1697</i>&nbsp;	 *  
<i>1698</i>&nbsp;	 *  In short, current performance is worse than it needs to be due to the cost of blitting the BufferedImage when panning/zooming.
<i>1699</i>&nbsp;	 *  It can easily be improved by switching to using a VolatileImage, but then color transforms become unacceptably terrible.
<i>1700</i>&nbsp;	 *  It may be worthwhile to use a compromise solution of a VolatileImage so long as no color transforms are required.
<i>1701</i>&nbsp;	 *  
<i>1702</i>&nbsp;	 *  But for now this has not been implemented as the code is not stable enough to warrant introducing yet more complexity.
<i>1703</i>&nbsp;	 * 
<i>1704</i>&nbsp;	 */
<i>1705</i>&nbsp;	//	VolatileImage imgVolatile;
<i>1706</i>&nbsp;
<i>1707</i>&nbsp;	
<i>1708</i>&nbsp;	protected void paintComponent(Graphics g) {
<b class="nc"><i>1709</i>&nbsp;		paintViewer(g, getWidth(), getHeight());</b>
<b class="nc"><i>1710</i>&nbsp;	}</b>
<i>1711</i>&nbsp;
<i>1712</i>&nbsp;	
<i>1713</i>&nbsp;	void updateRepaintTimestamp() {
<b class="fc"><i>1714</i>&nbsp;		long timestamp = System.currentTimeMillis();</b>
<b class="fc"><i>1715</i>&nbsp;		lastRepaintTimestamp.set(timestamp);</b>
<b class="fc"><i>1716</i>&nbsp;	}</b>
<i>1717</i>&nbsp;	
<i>1718</i>&nbsp;
<i>1719</i>&nbsp;	protected void paintViewer(Graphics g, int w, int h) {
<i>1720</i>&nbsp;		
<b class="fc"><i>1721</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="fc"><i>1722</i>&nbsp;		if (server == null) {</b>
<b class="fc"><i>1723</i>&nbsp;			g.setColor(background);</b>
<b class="fc"><i>1724</i>&nbsp;			g.fillRect(0, 0, w, h);</b>
<b class="fc"><i>1725</i>&nbsp;			updateRepaintTimestamp();</b>
<b class="fc"><i>1726</i>&nbsp;			return;</b>
<i>1727</i>&nbsp;		}
<i>1728</i>&nbsp;
<i>1729</i>&nbsp;//		// Get dimensions
<i>1730</i>&nbsp;//		int w = getWidth();
<i>1731</i>&nbsp;//		int h = getHeight();
<i>1732</i>&nbsp;
<b class="fc"><i>1733</i>&nbsp;		Rectangle clip = g.getClipBounds();</b>
<i>1734</i>&nbsp;		boolean clipFull;
<b class="fc"><i>1735</i>&nbsp;		if (clip == null) {</b>
<b class="fc"><i>1736</i>&nbsp;			clip = new Rectangle(0, 0, w, h);</b>
<b class="fc"><i>1737</i>&nbsp;			g.setClip(0, 0, w, h);</b>
<b class="fc"><i>1738</i>&nbsp;			clipFull = true;</b>
<i>1739</i>&nbsp;		} else
<b class="nc"><i>1740</i>&nbsp;			clipFull = clip.x == 0 &amp;&amp; clip.y == 0 &amp;&amp; clip.width == w &amp;&amp; clip.height == h;</b>
<i>1741</i>&nbsp;
<i>1742</i>&nbsp;		// Ensure we have a sufficiently-large buffer
<b class="fc"><i>1743</i>&nbsp;		if (imgBuffer == null || imgBuffer.getWidth() != w || imgBuffer.getHeight() != h) {</b>
<i>1744</i>&nbsp;			// Create buffered images &amp; buffers for RGB pixel values
<b class="fc"><i>1745</i>&nbsp;			imgBuffer = createBufferedImage(w, h);</b>
<b class="fc"><i>1746</i>&nbsp;			imgBuffer.setAccelerationPriority(1f);</b>
<b class="fc"><i>1747</i>&nbsp;			logger.trace(&quot;New buffered image created: {}&quot;, imgBuffer);</b>
<i>1748</i>&nbsp;			//			imgVolatile = createVolatileImage(w, h);
<b class="fc"><i>1749</i>&nbsp;			imageUpdated = true;</b>
<i>1750</i>&nbsp;			// If the size changed, ensure the AffineTransform is up-to-date
<b class="fc"><i>1751</i>&nbsp;			updateAffineTransform();</b>
<i>1752</i>&nbsp;		}
<i>1753</i>&nbsp;
<i>1754</i>&nbsp;		// Get the displayed region
<b class="fc"><i>1755</i>&nbsp;		Shape shapeRegion = getDisplayedRegionShape();</b>
<i>1756</i>&nbsp;
<i>1757</i>&nbsp;		// The visible shape must have changed if there wasn&#39;t one previously...
<i>1758</i>&nbsp;		// Otherwise check if it has changed &amp; update accordingly
<i>1759</i>&nbsp;		// This will be used to notify listeners soon
<b class="fc"><i>1760</i>&nbsp;		boolean shapeChanged = lastVisibleShape == null || !lastVisibleShape.equals(shapeRegion);</b>
<i>1761</i>&nbsp;
<b class="fc"><i>1762</i>&nbsp;		long t1 = System.currentTimeMillis();</b>
<i>1763</i>&nbsp;
<i>1764</i>&nbsp;		// Only repaint the image if this is requested, otherwise only overlays need to be repainted
<b class="fc"><i>1765</i>&nbsp;		if (imageUpdated || locationUpdated) {// || imgVolatile.contentsLost()) {</b>
<i>1766</i>&nbsp;			// Set flags that image no longer requiring an update
<i>1767</i>&nbsp;			// By setting them early, they might still be reset during this run... in which case we don&#39;t want to thwart the re-run
<b class="fc"><i>1768</i>&nbsp;			imageUpdated = false;</b>
<b class="fc"><i>1769</i>&nbsp;			locationUpdated = false;</b>
<i>1770</i>&nbsp;
<i>1771</i>&nbsp;			//			updateBufferedImage(imgVolatile, shapeRegion, w, h);
<b class="fc"><i>1772</i>&nbsp;			updateBufferedImage(imgBuffer, shapeRegion, w, h);</b>
<i>1773</i>&nbsp;		}
<i>1774</i>&nbsp;
<i>1775</i>&nbsp;		//		if (imageUpdated || locationUpdated) {
<i>1776</i>&nbsp;		//			updateBufferedImage(imgVolatile, shapeRegion, w, h);
<i>1777</i>&nbsp;		////			updateBufferedImage(imgBuffer, shapeRegion, w, h);
<i>1778</i>&nbsp;		////			logger.info(&quot;INITIAL Image drawing time: &quot; + (System.currentTimeMillis() - t1));			
<i>1779</i>&nbsp;		//			imgVolatile.createGraphics().drawImage(imgBuffer, 0, 0, this);
<i>1780</i>&nbsp;		//		}
<i>1781</i>&nbsp;
<i>1782</i>&nbsp;
<i>1783</i>&nbsp;		//		while (imgVolatile.contentsLost()) {
<i>1784</i>&nbsp;		//			imgVolatile.createGraphics().drawImage(imgBuffer, 0, 0, this);
<i>1785</i>&nbsp;		//		}
<i>1786</i>&nbsp;
<i>1787</i>&nbsp;		// Store the last shape visible
<b class="fc"><i>1788</i>&nbsp;		lastVisibleShape = shapeRegion;</b>
<i>1789</i>&nbsp;
<i>1790</i>&nbsp;		// Draw the image from the buffer
<i>1791</i>&nbsp;		// The call to super.paintComponent is delayed until here to try to stop occasional flickering on Apple&#39;s Java 6
<b class="fc"><i>1792</i>&nbsp;		g.setColor(background);</b>
<i>1793</i>&nbsp;		// Somehow, painting the thumbnail helps for Java 8 on a MacBook Pro/iMac... I have no idea why... but it kills performance for Java 6
<i>1794</i>&nbsp;		//		if (imgThumbnailRGB != null)
<i>1795</i>&nbsp;		//			g2d.drawImage(imgThumbnailRGB, 0, 0, getWidth(), getHeight(), this);
<i>1796</i>&nbsp;
<b class="fc"><i>1797</i>&nbsp;		if (clipFull)</b>
<b class="fc"><i>1798</i>&nbsp;			paintFinalImage(g, imgBuffer, this);</b>
<i>1799</i>&nbsp;		//			g2d.drawImage(imgBuffer, 0, 0, getWidth(), getHeight(), this);
<i>1800</i>&nbsp;		else
<b class="nc"><i>1801</i>&nbsp;			g.drawImage(imgBuffer, clip.x, clip.y, clip.x+clip.width, clip.y+clip.height, clip.x, clip.y, clip.x+clip.width, clip.y+clip.height, null);</b>
<i>1802</i>&nbsp;
<b class="fc"><i>1803</i>&nbsp;		if (logger.isTraceEnabled()) {</b>
<b class="nc"><i>1804</i>&nbsp;			long t2 = System.currentTimeMillis();</b>
<b class="nc"><i>1805</i>&nbsp;			logger.trace(&quot;Final image drawing time: {}&quot;, (t2 - t1));</b>
<i>1806</i>&nbsp;		}
<i>1807</i>&nbsp;
<i>1808</i>&nbsp;		// Really useful only for debugging graphics
<b class="fc"><i>1809</i>&nbsp;		if (!(g instanceof Graphics2D)) {</b>
<b class="nc"><i>1810</i>&nbsp;			imageUpdated = false;</b>
<i>1811</i>&nbsp;			// Notify any listeners of shape changes
<b class="nc"><i>1812</i>&nbsp;			if (shapeChanged)</b>
<b class="nc"><i>1813</i>&nbsp;				fireVisibleRegionChangedEvent(lastVisibleShape);</b>
<b class="nc"><i>1814</i>&nbsp;			return;</b>
<i>1815</i>&nbsp;		}
<i>1816</i>&nbsp;		
<b class="fc"><i>1817</i>&nbsp;		double downsample = getDownsampleFactor();</b>
<i>1818</i>&nbsp;
<b class="fc"><i>1819</i>&nbsp;		float opacity = overlayOptions.getOpacity();</b>
<b class="fc"><i>1820</i>&nbsp;		Graphics2D g2d = (Graphics2D)g.create();</b>
<i>1821</i>&nbsp;		// Apply required transform to the graphics object (rotation, scaling, shifting...)
<b class="fc"><i>1822</i>&nbsp;		g2d.transform(transform);</b>
<b class="fc"><i>1823</i>&nbsp;		Composite previousComposite = g2d.getComposite();</b>
<b class="fc"><i>1824</i>&nbsp;		boolean paintCompletely = thumbnailIsFullImage || !doFasterRepaint;</b>
<i>1825</i>&nbsp;//		var regionBounds = AwtTools.getImageRegion(clip, getZPosition(), getTPosition());
<b class="fc"><i>1826</i>&nbsp;		if (opacity &gt; 0 || PathPrefs.alwaysPaintSelectedObjectsProperty().get()) {</b>
<b class="fc"><i>1827</i>&nbsp;			if (opacity &lt; 1) {</b>
<b class="nc"><i>1828</i>&nbsp;				AlphaComposite composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, opacity);</b>
<b class="nc"><i>1829</i>&nbsp;				g2d.setComposite(composite);			</b>
<i>1830</i>&nbsp;			}
<i>1831</i>&nbsp;
<b class="fc"><i>1832</i>&nbsp;			Color color = getSuggestedOverlayColor();</b>
<i>1833</i>&nbsp;			// Paint the overlay layers
<b class="fc"><i>1834</i>&nbsp;			var imageData = this.imageDataProperty.get();</b>
<b class="fc"><i>1835</i>&nbsp;			for (PathOverlay overlay : allOverlayLayers.toArray(PathOverlay[]::new)) {</b>
<b class="fc"><i>1836</i>&nbsp;				logger.trace(&quot;Painting overlay: {}&quot;, overlay);</b>
<b class="fc"><i>1837</i>&nbsp;				if (overlay instanceof AbstractOverlay)</b>
<b class="fc"><i>1838</i>&nbsp;					((AbstractOverlay)overlay).setPreferredOverlayColor(color);</b>
<i>1839</i>&nbsp;//				overlay.paintOverlay(g2d, regionBounds, downsample, null, paintCompletely);
<b class="fc"><i>1840</i>&nbsp;				overlay.paintOverlay(g2d, getServerBounds(), downsample, imageData, paintCompletely);</b>
<i>1841</i>&nbsp;			}
<i>1842</i>&nbsp;//			if (hierarchyOverlay != null) {
<i>1843</i>&nbsp;//				hierarchyOverlay.setPreferredOverlayColor(color);
<i>1844</i>&nbsp;//				hierarchyOverlay.paintOverlay(g2d, getServerBounds(), downsampleFactor, null, paintCompletely);
<i>1845</i>&nbsp;//			}
<i>1846</i>&nbsp;		}
<i>1847</i>&nbsp;		
<i>1848</i>&nbsp;		// Paint the selected object
<b class="fc"><i>1849</i>&nbsp;		PathObjectHierarchy hierarchy = getHierarchy();</b>
<b class="fc"><i>1850</i>&nbsp;		PathObject mainSelectedObject = getSelectedObject();</b>
<b class="fc"><i>1851</i>&nbsp;		Rectangle2D boundsRect = null;</b>
<b class="fc"><i>1852</i>&nbsp;		boolean useSelectedColor = PathPrefs.useSelectedColorProperty().get();</b>
<b class="fc"><i>1853</i>&nbsp;		boolean paintSelectedBounds = PathPrefs.paintSelectedBoundsProperty().get();</b>
<b class="fc"><i>1854</i>&nbsp;		for (PathObject selectedObject : hierarchy.getSelectionModel().getSelectedObjects().toArray(new PathObject[0])) {</b>
<i>1855</i>&nbsp;			// TODO: Simplify this...
<b class="nc"><i>1856</i>&nbsp;			if (selectedObject != null &amp;&amp; selectedObject.hasROI() &amp;&amp; selectedObject.getROI().getZ() == getZPosition() &amp;&amp; selectedObject.getROI().getT() == getTPosition()) {</b>
<i>1857</i>&nbsp;				
<b class="nc"><i>1858</i>&nbsp;				if (!selectedObject.isDetection()) {</b>
<i>1859</i>&nbsp;					// Ensure a selected ROI can be seen clearly
<b class="nc"><i>1860</i>&nbsp;					if (previousComposite != null)</b>
<b class="nc"><i>1861</i>&nbsp;						g2d.setComposite(previousComposite);</b>
<b class="nc"><i>1862</i>&nbsp;					g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</b>
<i>1863</i>&nbsp;				}
<i>1864</i>&nbsp;				
<b class="nc"><i>1865</i>&nbsp;				Rectangle boundsDisplayed = shapeRegion.getBounds();</b>
<i>1866</i>&nbsp;				
<b class="nc"><i>1867</i>&nbsp;				ROI pathROI = selectedObject.getROI();</b>
<i>1868</i>&nbsp;//				if ((PathPrefs.getPaintSelectedBounds() || (selectedObject.isDetection() &amp;&amp; !PathPrefs.getUseSelectedColor())) &amp;&amp; !(pathROI instanceof RectangleROI)) {
<b class="nc"><i>1869</i>&nbsp;				if (pathROI != null &amp;&amp; (paintSelectedBounds || (!useSelectedColor)) &amp;&amp; !(pathROI instanceof RectangleROI) &amp;&amp; !pathROI.isEmpty()) {</b>
<b class="nc"><i>1870</i>&nbsp;					Shape boundsShape = null;</b>
<b class="nc"><i>1871</i>&nbsp;					if (pathROI.isPoint()) {</b>
<b class="nc"><i>1872</i>&nbsp;						var hull = pathROI.getConvexHull();</b>
<b class="nc"><i>1873</i>&nbsp;						if (hull != null)</b>
<b class="nc"><i>1874</i>&nbsp;							boundsShape = hull.getShape();</b>
<i>1875</i>&nbsp;					}
<b class="nc"><i>1876</i>&nbsp;					if (boundsShape == null) {</b>
<b class="nc"><i>1877</i>&nbsp;						boundsRect = AwtTools.getBounds2D(pathROI, boundsRect);</b>
<b class="nc"><i>1878</i>&nbsp;						boundsShape = boundsRect;</b>
<i>1879</i>&nbsp;					}
<i>1880</i>&nbsp;					// Tried to match to pixel boundaries... but resulted in too much jiggling
<i>1881</i>&nbsp;//					boundsShape.setFrame(
<i>1882</i>&nbsp;//							Math.round(boundsShape.getX()/downsampleFactor)*downsampleFactor-downsampleFactor,
<i>1883</i>&nbsp;//							Math.round(boundsShape.getY()/downsampleFactor)*downsampleFactor-downsampleFactor,
<i>1884</i>&nbsp;//							Math.round(boundsShape.getWidth()/downsampleFactor)*downsampleFactor+2*downsampleFactor,
<i>1885</i>&nbsp;//							Math.round(boundsShape.getHeight()/downsampleFactor)*downsampleFactor+2*downsampleFactor);
<i>1886</i>&nbsp;					
<i>1887</i>&nbsp;//					boundsShape.setFrame(boundsShape.getX()-downsampleFactor, boundsShape.getY()-downsampleFactor, boundsShape.getWidth()+2*downsampleFactor, boundsShape.getHeight()+2*downsampleFactor);
<b class="nc"><i>1888</i>&nbsp;					PathHierarchyPaintingHelper.paintShape(boundsShape, g2d, getSuggestedOverlayColor(), PathHierarchyPaintingHelper.getCachedStroke(Math.max(downsample, 1)*2), null);</b>
<i>1889</i>&nbsp;//					boundsShape.setFrame(boundsShape.getX()+downsampleFactor, boundsShape.getY()-downsampleFactor, boundsShape.getWidth(), boundsShape.getHeight());
<i>1890</i>&nbsp;//					PathHierarchyPaintingHelper.paintShape(boundsShape, g2d, new Color(1f, 1f, 1f, 0.75f), PathHierarchyPaintingHelper.getCachedStroke(Math.max(downsampleFactor, 1)*2), null, downsampleFactor);
<i>1891</i>&nbsp;				}
<i>1892</i>&nbsp;				
<i>1893</i>&nbsp;				// Avoid double-painting of annotations (which looks odd if they are filled in)
<i>1894</i>&nbsp;				// However do always paint detections, since they are otherwise painted (unselected) 
<i>1895</i>&nbsp;				// in a cached way
<b class="nc"><i>1896</i>&nbsp;				if ((selectedObject.isDetection() &amp;&amp; PathPrefs.useSelectedColorProperty().get()) || !PathObjectTools.hierarchyContainsObject(hierarchy, selectedObject))</b>
<b class="nc"><i>1897</i>&nbsp;					PathHierarchyPaintingHelper.paintObject(selectedObject, false, g2d, boundsDisplayed, overlayOptions, getHierarchy().getSelectionModel(), downsample);</b>
<i>1898</i>&nbsp;				// Paint ROI handles, if required
<b class="nc"><i>1899</i>&nbsp;				if (selectedObject == mainSelectedObject &amp;&amp; roiEditor.hasROI()) {</b>
<b class="nc"><i>1900</i>&nbsp;					Stroke strokeThick = PathHierarchyPaintingHelper.getCachedStroke(PathPrefs.annotationStrokeThicknessProperty().get() * downsample);</b>
<b class="nc"><i>1901</i>&nbsp;					Color color = useSelectedColor ? ColorToolsAwt.getCachedColor(PathPrefs.colorSelectedObjectProperty().get()) : null;</b>
<b class="nc"><i>1902</i>&nbsp;					if (color == null)</b>
<b class="nc"><i>1903</i>&nbsp;						color = ColorToolsAwt.getCachedColor(ColorToolsFX.getDisplayedColorARGB(selectedObject));</b>
<b class="nc"><i>1904</i>&nbsp;					g2d.setStroke(strokeThick);</b>
<i>1905</i>&nbsp;					// Draw ROI handles using adaptive size
<b class="nc"><i>1906</i>&nbsp;					double maxHandleSize = getMaxROIHandleSize();</b>
<b class="nc"><i>1907</i>&nbsp;					double minHandleSize = downsample;</b>
<b class="nc"><i>1908</i>&nbsp;					PathHierarchyPaintingHelper.paintHandles(roiEditor, g2d, minHandleSize, maxHandleSize, color, ColorToolsAwt.getTranslucentColor(color));</b>
<i>1909</i>&nbsp;				}
<i>1910</i>&nbsp;			}
<i>1911</i>&nbsp;		}
<i>1912</i>&nbsp;
<i>1913</i>&nbsp;		// Notify any listeners of shape changes
<b class="fc"><i>1914</i>&nbsp;		if (shapeChanged)</b>
<b class="fc"><i>1915</i>&nbsp;			fireVisibleRegionChangedEvent(lastVisibleShape);</b>
<i>1916</i>&nbsp;		
<i>1917</i>&nbsp;		
<b class="fc"><i>1918</i>&nbsp;		updateRepaintTimestamp();</b>
<b class="fc"><i>1919</i>&nbsp;	}</b>
<i>1920</i>&nbsp;	
<i>1921</i>&nbsp;	/**
<i>1922</i>&nbsp;	 * Get the maximum size for which ROI handles may be drawn.
<i>1923</i>&nbsp;	 * @return
<i>1924</i>&nbsp;	 */
<i>1925</i>&nbsp;	public double getMaxROIHandleSize() {
<b class="nc"><i>1926</i>&nbsp;		return PathPrefs.annotationStrokeThicknessProperty().get() * getDownsampleFactor() * 4.0;</b>
<i>1927</i>&nbsp;	}
<i>1928</i>&nbsp;
<i>1929</i>&nbsp;	/**
<i>1930</i>&nbsp;	 * Get the timestamp referring to the last time this viewer was repainted.
<i>1931</i>&nbsp;	 * @return
<i>1932</i>&nbsp;	 */
<i>1933</i>&nbsp;	public ReadOnlyLongProperty repaintTimestamp() {
<b class="nc"><i>1934</i>&nbsp;		return lastRepaintTimestamp;</b>
<i>1935</i>&nbsp;	}
<i>1936</i>&nbsp;	
<i>1937</i>&nbsp;	
<i>1938</i>&nbsp;	/**
<i>1939</i>&nbsp;	 * Create an RGB BufferedImage suitable for caching the image used for painting.
<i>1940</i>&nbsp;	 * @param w
<i>1941</i>&nbsp;	 * @param h
<i>1942</i>&nbsp;	 * @return
<i>1943</i>&nbsp;	 */
<i>1944</i>&nbsp;	static BufferedImage createBufferedImage(final int w, final int h) {
<b class="fc"><i>1945</i>&nbsp;		return new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB_PRE);</b>
<i>1946</i>&nbsp;	}
<i>1947</i>&nbsp;
<i>1948</i>&nbsp;
<i>1949</i>&nbsp;	//	private void updateBufferedImage(final VolatileImage imgBuffer, final Shape shapeRegion, final int w, final int h) {
<i>1950</i>&nbsp;	//		Graphics2D gBuffered = imgBuffer.createGraphics();
<i>1951</i>&nbsp;	//		updateBufferedImage(gBuffered, shapeRegion, w, h);
<i>1952</i>&nbsp;	//		gBuffered.dispose();
<i>1953</i>&nbsp;	//	}
<i>1954</i>&nbsp;
<i>1955</i>&nbsp;	private void updateBufferedImage(final BufferedImage imgBuffer, final Shape shapeRegion, final int w, final int h) {
<b class="fc"><i>1956</i>&nbsp;		Graphics2D gBuffered = imgBuffer.createGraphics();</b>
<b class="fc"><i>1957</i>&nbsp;		updateBufferedImage(gBuffered, shapeRegion, w, h);</b>
<b class="fc"><i>1958</i>&nbsp;		gBuffered.dispose();</b>
<i>1959</i>&nbsp;		// Apply color transforms, if required
<b class="fc"><i>1960</i>&nbsp;		if (iccTransformOp != null) {</b>
<b class="nc"><i>1961</i>&nbsp;			iccTransformOp.filter(this.imgBuffer.getRaster(), this.imgBuffer.getRaster());</b>
<i>1962</i>&nbsp;		}
<b class="fc"><i>1963</i>&nbsp;		ensureGammaUpdated();</b>
<b class="fc"><i>1964</i>&nbsp;		if (gammaOp != null) {</b>
<b class="nc"><i>1965</i>&nbsp;			gammaOp.filter(this.imgBuffer.getRaster(), this.imgBuffer.getRaster());</b>
<i>1966</i>&nbsp;		}
<b class="fc"><i>1967</i>&nbsp;	}</b>
<i>1968</i>&nbsp;
<i>1969</i>&nbsp;	//	private void updateBufferedImage(final BufferedImage imgBuffer, final Shape shapeRegion) {
<i>1970</i>&nbsp;	private void updateBufferedImage(final Graphics2D gBuffered, final Shape shapeRegion, final int w, final int h) {
<i>1971</i>&nbsp;		// Check if we are doing a simple shift (scroll) - if so, we can reuse some previous painting
<i>1972</i>&nbsp;		// TODO: Verify that the &#39;scroll only&#39; test is sufficiently reliable
<b class="fc"><i>1973</i>&nbsp;		Shape shapeToUpdate = shapeRegion;</b>
<i>1974</i>&nbsp;		// Set all image pixels to be the background color
<b class="fc"><i>1975</i>&nbsp;		gBuffered.setColor(background);</b>
<b class="fc"><i>1976</i>&nbsp;		gBuffered.fillRect(0, 0, w, h);</b>
<i>1977</i>&nbsp;
<i>1978</i>&nbsp;		// Apply the transform so we don&#39;t need to worry about converting coordinates so much
<b class="fc"><i>1979</i>&nbsp;		gBuffered.transform(transform);</b>
<b class="fc"><i>1980</i>&nbsp;		gBuffered.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);</b>
<i>1981</i>&nbsp;
<i>1982</i>&nbsp;		// Get the server width &amp; height
<b class="fc"><i>1983</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="fc"><i>1984</i>&nbsp;		int serverWidth = server.getWidth();</b>
<b class="fc"><i>1985</i>&nbsp;		int serverHeight = server.getHeight();</b>
<i>1986</i>&nbsp;
<i>1987</i>&nbsp;		// Check if we require tiling the image, or if the low-resolution version does all we need
<b class="fc"><i>1988</i>&nbsp;		BufferedImage imgThumbnail = regionStore.getThumbnail(server, getZPosition(), getTPosition(), true);</b>
<b class="fc"><i>1989</i>&nbsp;		double lowResolutionDownsample = 0.5 * ((double)serverWidth / imgThumbnail.getWidth() + (double)serverHeight / imgThumbnail.getHeight());</b>
<b class="fc"><i>1990</i>&nbsp;		boolean requiresTiling = !thumbnailIsFullImage &amp;&amp; lowResolutionDownsample &gt; Math.max(downsampleFactor.get(), 1);</b>
<i>1991</i>&nbsp;
<i>1992</i>&nbsp;		// Check if we will be painting some background beyond the image edge
<b class="fc"><i>1993</i>&nbsp;		Rectangle shapeBounds = shapeToUpdate.getBounds();</b>
<b class="fc"><i>1994</i>&nbsp;		boolean overBoundary = shapeBounds.x &lt; 0 || shapeBounds.y &lt; 0 || shapeBounds.x + shapeBounds.width &gt;= serverWidth || shapeBounds.y + shapeBounds.height &gt;= serverHeight;</b>
<i>1995</i>&nbsp;
<i>1996</i>&nbsp;		// Reset interpolation - this roughly halves repaint times
<b class="fc"><i>1997</i>&nbsp;		if (!doFasterRepaint &amp;&amp; PathPrefs.viewerInterpolateBilinearProperty().get())</b>
<b class="nc"><i>1998</i>&nbsp;			gBuffered.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);</b>
<i>1999</i>&nbsp;		else
<b class="fc"><i>2000</i>&nbsp;			gBuffered.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);</b>
<i>2001</i>&nbsp;
<b class="fc"><i>2002</i>&nbsp;		if (requiresTiling) {</b>
<i>2003</i>&nbsp;
<i>2004</i>&nbsp;			// TODO: Consider removing faster repaint?
<b class="nc"><i>2005</i>&nbsp;			double downsample = getDownsampleFactor();</b>
<i>2006</i>&nbsp;//			if (doFasterRepaint)
<i>2007</i>&nbsp;//				downsample = downsampleFactor * 1.5;
<i>2008</i>&nbsp;
<i>2009</i>&nbsp;
<i>2010</i>&nbsp;			// Try to repaint higher resolution tiles for only the requested region
<i>2011</i>&nbsp;			// A small optimization (that can make a difference in repaint speed...) is that for an RGB image we don&#39;t need to transform
<i>2012</i>&nbsp;			// the image as we go along (tile by tile), but we can apply a single transform afterwards.
<i>2013</i>&nbsp;			// *However* this shouldn&#39;t be applied if the region we are viewing extends beyond the image boundary, as it means we would be color-transforming the background color.
<i>2014</i>&nbsp;			// For a non-RGB image, or if the viewed region is over the image boundary, the transform should be applied in advance to the thumbnail, and then tile-by-tile during painting.
<b class="nc"><i>2015</i>&nbsp;			if (server.isRGB() &amp;&amp; !overBoundary) {</b>
<b class="nc"><i>2016</i>&nbsp;				regionStore.paintRegion(server, gBuffered, shapeToUpdate, getZPosition(), getTPosition(), downsample, imgThumbnail, null, null);</b>
<b class="nc"><i>2017</i>&nbsp;				gBuffered.dispose();</b>
<b class="nc"><i>2018</i>&nbsp;				if (imageDisplay != null)</b>
<i>2019</i>&nbsp;//					imgBuffer = imageDisplay.applyTransforms(imgBuffer, imgBuffer);
<i>2020</i>&nbsp;//					 More benchmarking required... but reusing imgBuffer was killing performance for RGB transform on Java 8 (JavaFX)... possibly
<b class="nc"><i>2021</i>&nbsp;					imgBuffer = getRenderer().applyTransforms(imgBuffer, null);</b>
<i>2022</i>&nbsp;			} else {
<b class="nc"><i>2023</i>&nbsp;				regionStore.paintRegion(server, gBuffered, shapeToUpdate, getZPosition(), getTPosition(), downsample, imgThumbnail, null, getRenderer());</b>
<i>2024</i>&nbsp;			}
<b class="nc"><i>2025</i>&nbsp;		} else {</b>
<i>2026</i>&nbsp;			// Just paint the &#39;thumbnail&#39; version, which has already (potentially) been color-transformed
<b class="fc"><i>2027</i>&nbsp;			paintThumbnail(gBuffered, imgThumbnailRGB, serverWidth, serverHeight, this);</b>
<i>2028</i>&nbsp;		}
<b class="fc"><i>2029</i>&nbsp;	}</b>
<i>2030</i>&nbsp;
<i>2031</i>&nbsp;
<i>2032</i>&nbsp;	/**
<i>2033</i>&nbsp;	 * Get an unmodifiable list containing the overlay layers, in order.
<i>2034</i>&nbsp;	 * @return
<i>2035</i>&nbsp;	 */
<i>2036</i>&nbsp;	public List&lt;PathOverlay&gt; getOverlayLayers() {
<b class="nc"><i>2037</i>&nbsp;		return FXCollections.unmodifiableObservableList(allOverlayLayers);</b>
<i>2038</i>&nbsp;	}
<i>2039</i>&nbsp;	
<i>2040</i>&nbsp;	/**
<i>2041</i>&nbsp;	 * Get direct access to the custom overlay list.
<i>2042</i>&nbsp;	 * @return
<i>2043</i>&nbsp;	 */
<i>2044</i>&nbsp;	public ObservableList&lt;PathOverlay&gt; getCustomOverlayLayers() {
<b class="nc"><i>2045</i>&nbsp;		return customOverlayLayers;</b>
<i>2046</i>&nbsp;	}
<i>2047</i>&nbsp;
<i>2048</i>&nbsp;
<i>2049</i>&nbsp;
<i>2050</i>&nbsp;	static void paintThumbnail(Graphics g, Image img, int width, int height, QuPathViewer viewer) {
<b class="fc"><i>2051</i>&nbsp;		g.drawImage(img, 0, 0, width, height, null);</b>
<b class="fc"><i>2052</i>&nbsp;	}</b>
<i>2053</i>&nbsp;
<i>2054</i>&nbsp;	
<i>2055</i>&nbsp;	/**
<i>2056</i>&nbsp;	 * Create a &lt;code&gt;LookupOp&lt;/code&gt; that applies a gamma transform to an 8-bit image.
<i>2057</i>&nbsp;	 * 
<i>2058</i>&nbsp;	 * @param gamma
<i>2059</i>&nbsp;	 * @return
<i>2060</i>&nbsp;	 */
<i>2061</i>&nbsp;	static LookupOp createGammaOp(double gamma) {
<b class="nc"><i>2062</i>&nbsp;		byte[] lut = new byte[256];</b>
<b class="nc"><i>2063</i>&nbsp;		for (int i = 0; i &lt; 256; i++) {</b>
<b class="nc"><i>2064</i>&nbsp;			double val = Math.pow(i/255.0, gamma) * 255;</b>
<b class="nc"><i>2065</i>&nbsp;			lut[i] = (byte)ColorTools.do8BitRangeCheck(val);</b>
<i>2066</i>&nbsp;		}
<b class="nc"><i>2067</i>&nbsp;		return new LookupOp(new ByteLookupTable(0, lut), null);</b>
<i>2068</i>&nbsp;	}
<i>2069</i>&nbsp;
<i>2070</i>&nbsp;	/**
<i>2071</i>&nbsp;	 * Attempt to read an ICC profile from a TIFF image or stream.
<i>2072</i>&nbsp;	 * This depends on ImageIO; in general, it should work with Java 9 
<i>2073</i>&nbsp;	 * (if an ICC profile is included in the TIFF) but not earlier versions.
<i>2074</i>&nbsp;	 * 
<i>2075</i>&nbsp;	 * @param input an input of the kind that &lt;code&gt;ImageIO.createImageInputStream&lt;/code&gt; can handle (e.g. a &lt;code&gt;File&lt;/code&gt;)
<i>2076</i>&nbsp;	 * @return an ICC profile if one is found, otherwise null.
<i>2077</i>&nbsp;	 */
<i>2078</i>&nbsp;	static ICC_Profile readICC(Object input) {
<b class="nc"><i>2079</i>&nbsp;		try (ImageInputStream stream = ImageIO.createImageInputStream(input)) {</b>
<b class="nc"><i>2080</i>&nbsp;			Iterator&lt;ImageReader&gt; readers = ImageIO.getImageReaders(stream);</b>
<b class="nc"><i>2081</i>&nbsp;			if (readers == null) {</b>
<b class="nc"><i>2082</i>&nbsp;				logger.debug(&quot;No readers found to extract ICC profile from {}&quot;, input);</b>
<b class="nc"><i>2083</i>&nbsp;				return null;</b>
<i>2084</i>&nbsp;			}
<b class="nc"><i>2085</i>&nbsp;			Class&lt;?&gt; clsTiffDir = Class.forName(&quot;javax.imageio.plugins.tiff.TIFFDirectory&quot;);</b>
<b class="nc"><i>2086</i>&nbsp;			Class&lt;?&gt; clsTiffField = Class.forName(&quot;javax.imageio.plugins.tiff.TIFFField&quot;);</b>
<b class="nc"><i>2087</i>&nbsp;			Method mCreateFromMetadata = clsTiffDir.getMethod(&quot;createFromMetadata&quot;, IIOMetadata.class);</b>
<b class="nc"><i>2088</i>&nbsp;			Method mGetTiffField = clsTiffDir.getMethod(&quot;getTIFFField&quot;, int.class);</b>
<b class="nc"><i>2089</i>&nbsp;			Method mGetAsBytes = clsTiffField.getMethod(&quot;getAsBytes&quot;);</b>
<b class="nc"><i>2090</i>&nbsp;			while (readers.hasNext()) {</b>
<b class="nc"><i>2091</i>&nbsp;				ImageReader reader = readers.next();</b>
<b class="nc"><i>2092</i>&nbsp;				stream.reset();</b>
<b class="nc"><i>2093</i>&nbsp;				reader.setInput(stream);</b>
<b class="nc"><i>2094</i>&nbsp;				Object tiffDir = mCreateFromMetadata.invoke(null, reader.getImageMetadata(0));</b>
<b class="nc"><i>2095</i>&nbsp;				Object tiffField = mGetTiffField.invoke(tiffDir, 34675);</b>
<b class="nc"><i>2096</i>&nbsp;				byte[] bytes = (byte[])mGetAsBytes.invoke(tiffField);</b>
<b class="nc"><i>2097</i>&nbsp;				return ICC_Profile.getInstance(bytes);</b>
<i>2098</i>&nbsp;			}
<b class="nc"><i>2099</i>&nbsp;		} catch (Exception e) {</b>
<b class="nc"><i>2100</i>&nbsp;			logger.warn(&quot;Unable to read ICC profile: {}&quot;, e.getLocalizedMessage());</b>
<b class="nc"><i>2101</i>&nbsp;		}</b>
<b class="nc"><i>2102</i>&nbsp;		return null;</b>
<i>2103</i>&nbsp;	}
<i>2104</i>&nbsp;
<i>2105</i>&nbsp;	/**
<i>2106</i>&nbsp;	 * Try to create a &lt;code&gt;ColorConvertOp&lt;/code&gt; that can be applied to transform using the color space of 
<i>2107</i>&nbsp;	 * the source image (read from TIFF tags, if possible) to sRGB.
<i>2108</i>&nbsp;	 * 
<i>2109</i>&nbsp;	 * @return the &lt;code&gt;ColorConvertOp&lt;/code&gt; if an appropriate conversion could be found, or &lt;code&gt;null&lt;/code&gt; otherwise.
<i>2110</i>&nbsp;	 */
<i>2111</i>&nbsp;	ColorConvertOp createICCConvertOp() {
<b class="nc"><i>2112</i>&nbsp;		ICC_Profile iccSource = readICC(new File(getServerPath()));</b>
<b class="nc"><i>2113</i>&nbsp;		if (iccSource == null)</b>
<b class="nc"><i>2114</i>&nbsp;			return null;</b>
<b class="nc"><i>2115</i>&nbsp;		return new ColorConvertOp(new ICC_Profile[]{</b>
<i>2116</i>&nbsp;				iccSource,
<b class="nc"><i>2117</i>&nbsp;				ICC_Profile.getInstance(ColorSpace.CS_sRGB)}, null);</b>
<i>2118</i>&nbsp;	}
<i>2119</i>&nbsp;	
<i>2120</i>&nbsp;	
<b class="fc"><i>2121</i>&nbsp;	private double gamma = 1.0;</b>
<b class="fc"><i>2122</i>&nbsp;	private LookupOp gammaOp = null;</b>
<i>2123</i>&nbsp;	
<b class="fc"><i>2124</i>&nbsp;	private ColorConvertOp iccTransformOp = null;</b>
<b class="fc"><i>2125</i>&nbsp;	private boolean doICCTransform = false;</b>
<i>2126</i>&nbsp;	
<i>2127</i>&nbsp;	void setGamma(final double gamma) {
<b class="nc"><i>2128</i>&nbsp;		if (this.gamma == gamma)</b>
<b class="nc"><i>2129</i>&nbsp;			return;</b>
<b class="nc"><i>2130</i>&nbsp;		if (gamma == 1 || gamma &lt;= 0 || !Double.isFinite(gamma))</b>
<b class="nc"><i>2131</i>&nbsp;			gammaOp = null;</b>
<i>2132</i>&nbsp;		else
<b class="nc"><i>2133</i>&nbsp;			gammaOp = createGammaOp(gamma);</b>
<b class="nc"><i>2134</i>&nbsp;		this.gamma = gamma;</b>
<b class="nc"><i>2135</i>&nbsp;	}</b>
<i>2136</i>&nbsp;	
<i>2137</i>&nbsp;	void ensureGammaUpdated() {
<b class="fc"><i>2138</i>&nbsp;		var gammaProperty = PathPrefs.viewerGammaProperty().get();</b>
<b class="fc"><i>2139</i>&nbsp;		if (gamma != gammaProperty) {</b>
<b class="nc"><i>2140</i>&nbsp;			setGamma(gammaProperty);</b>
<b class="nc"><i>2141</i>&nbsp;			imageUpdated = true;</b>
<i>2142</i>&nbsp;		}
<b class="fc"><i>2143</i>&nbsp;	}</b>
<i>2144</i>&nbsp;	
<i>2145</i>&nbsp;	void updateICCTransform() {
<b class="nc"><i>2146</i>&nbsp;		if (getServerPath() != null &amp;&amp; getDoICCTransform())</b>
<b class="nc"><i>2147</i>&nbsp;			iccTransformOp = createICCConvertOp();</b>
<i>2148</i>&nbsp;		else
<b class="nc"><i>2149</i>&nbsp;			iccTransformOp = null;</b>
<b class="nc"><i>2150</i>&nbsp;	}</b>
<i>2151</i>&nbsp;	
<i>2152</i>&nbsp;	void setDoICCTransform(final boolean doTransform) {
<b class="nc"><i>2153</i>&nbsp;		this.doICCTransform = doTransform;</b>
<b class="nc"><i>2154</i>&nbsp;		updateICCTransform();</b>
<b class="nc"><i>2155</i>&nbsp;	}</b>
<i>2156</i>&nbsp;
<i>2157</i>&nbsp;	boolean getDoICCTransform() {
<b class="nc"><i>2158</i>&nbsp;		return doICCTransform;</b>
<i>2159</i>&nbsp;	}
<i>2160</i>&nbsp;	
<i>2161</i>&nbsp;	static void paintFinalImage(Graphics g, Image img, QuPathViewer viewer) {
<b class="fc"><i>2162</i>&nbsp;		g.drawImage(img, 0, 0, null);</b>
<b class="fc"><i>2163</i>&nbsp;	}</b>
<i>2164</i>&nbsp;	
<i>2165</i>&nbsp;	/**
<i>2166</i>&nbsp;	 * Get the {@link RoiEditor} used by this viewer.
<i>2167</i>&nbsp;	 * @return
<i>2168</i>&nbsp;	 */
<i>2169</i>&nbsp;	public RoiEditor getROIEditor() {
<b class="fc"><i>2170</i>&nbsp;		return roiEditor;</b>
<i>2171</i>&nbsp;	}
<i>2172</i>&nbsp;
<i>2173</i>&nbsp;
<i>2174</i>&nbsp;	private void updateTooltip(final Tooltip tooltip) {
<b class="nc"><i>2175</i>&nbsp;		String text = getTooltipText(mouseX, mouseY);</b>
<b class="nc"><i>2176</i>&nbsp;		tooltip.setText(text);</b>
<b class="nc"><i>2177</i>&nbsp;		if (text == null)</b>
<b class="nc"><i>2178</i>&nbsp;			tooltip.setOpacity(0);</b>
<i>2179</i>&nbsp;		else
<b class="nc"><i>2180</i>&nbsp;			tooltip.setOpacity(1);</b>
<b class="nc"><i>2181</i>&nbsp;	}</b>
<i>2182</i>&nbsp;
<i>2183</i>&nbsp;	private String getTooltipText(final double x, final double y) {
<i>2184</i>&nbsp;		// Try to show which TMA core is selected - if we have a TMA image
<b class="nc"><i>2185</i>&nbsp;		PathObjectHierarchy hierarchy = getHierarchy();</b>
<b class="nc"><i>2186</i>&nbsp;		TMAGrid tmaGrid = hierarchy == null ? null : hierarchy.getTMAGrid();</b>
<b class="nc"><i>2187</i>&nbsp;		if (tmaGrid != null) {</b>
<b class="nc"><i>2188</i>&nbsp;			Point2D p = componentPointToImagePoint(x, y, null, false);</b>
<b class="nc"><i>2189</i>&nbsp;			TMACoreObject core = PathObjectTools.getTMACoreForPixel(tmaGrid, p.getX(), p.getY());</b>
<b class="nc"><i>2190</i>&nbsp;			if (core != null) {</b>
<b class="nc"><i>2191</i>&nbsp;				if (core.isMissing())</b>
<b class="nc"><i>2192</i>&nbsp;					return String.format(&quot;TMA Core %s\n(missing)&quot;, core.getName());</b>
<i>2193</i>&nbsp;				else
<b class="nc"><i>2194</i>&nbsp;					return String.format(&quot;TMA Core %s&quot;, core.getName());</b>
<i>2195</i>&nbsp;			}
<i>2196</i>&nbsp;		}
<b class="nc"><i>2197</i>&nbsp;		return null;</b>
<i>2198</i>&nbsp;	}
<i>2199</i>&nbsp;
<i>2200</i>&nbsp;	/**
<i>2201</i>&nbsp;	 * Get the {@link ImageDisplay} object used to determine how the image is converted to RGB for display.
<i>2202</i>&nbsp;	 * @return
<i>2203</i>&nbsp;	 */
<i>2204</i>&nbsp;	public ImageDisplay getImageDisplay() {
<b class="fc"><i>2205</i>&nbsp;		return imageDisplay;</b>
<i>2206</i>&nbsp;	}
<i>2207</i>&nbsp;	
<i>2208</i>&nbsp;	protected boolean componentContains(double x, double y) {
<b class="fc"><i>2209</i>&nbsp;		return x &gt;= 0 &amp;&amp; x &lt; getView().getWidth() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= getView().getHeight();</b>
<i>2210</i>&nbsp;	}
<i>2211</i>&nbsp;	
<i>2212</i>&nbsp;	/**
<i>2213</i>&nbsp;	 * Set the downsample factor for this viewer.
<i>2214</i>&nbsp;	 * @param downsampleFactor
<i>2215</i>&nbsp;	 */
<i>2216</i>&nbsp;	public void setDownsampleFactor(double downsampleFactor) {
<b class="nc"><i>2217</i>&nbsp;		if (componentContains(mouseX, mouseY))</b>
<b class="nc"><i>2218</i>&nbsp;			setDownsampleFactor(downsampleFactor, mouseX, mouseY);</b>
<i>2219</i>&nbsp;		else {
<b class="nc"><i>2220</i>&nbsp;			setDownsampleFactor(downsampleFactor, -1, -1);</b>
<i>2221</i>&nbsp;		}
<b class="nc"><i>2222</i>&nbsp;	}</b>
<i>2223</i>&nbsp;
<i>2224</i>&nbsp;
<i>2225</i>&nbsp;	/**
<i>2226</i>&nbsp;	 * Get a thumbnail representing the image as displayed by this viewer.
<i>2227</i>&nbsp;	 * 
<i>2228</i>&nbsp;	 * @return
<i>2229</i>&nbsp;	 */
<i>2230</i>&nbsp;	public BufferedImage getThumbnail() {
<b class="nc"><i>2231</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="nc"><i>2232</i>&nbsp;		return server == null ? null : regionStore.getThumbnail(server, getZPosition(), getTPosition(), true);</b>
<i>2233</i>&nbsp;	}
<i>2234</i>&nbsp;
<i>2235</i>&nbsp;	/**
<i>2236</i>&nbsp;	 * Get thumbnails for all z-slices &amp;amp; time points
<i>2237</i>&nbsp;	 * @return
<i>2238</i>&nbsp;	 */
<i>2239</i>&nbsp;	public List&lt;BufferedImage&gt; getAllThumbnails() {
<b class="nc"><i>2240</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="nc"><i>2241</i>&nbsp;		if (server == null)</b>
<b class="nc"><i>2242</i>&nbsp;			return Collections.emptyList();</b>
<b class="nc"><i>2243</i>&nbsp;		int nImages = server.nTimepoints() * server.nZSlices();</b>
<b class="nc"><i>2244</i>&nbsp;		if (nImages == 1)</b>
<b class="nc"><i>2245</i>&nbsp;			return Collections.singletonList(regionStore.getThumbnail(server, 0, 0, true));</b>
<b class="nc"><i>2246</i>&nbsp;		List&lt;BufferedImage&gt; thumbnails = new ArrayList&lt;BufferedImage&gt;(nImages);</b>
<b class="nc"><i>2247</i>&nbsp;		for (int t = 0; t &lt; server.nTimepoints(); t++) {</b>
<b class="nc"><i>2248</i>&nbsp;			for (int z = 0; z &lt; server.nZSlices(); z++) {</b>
<b class="nc"><i>2249</i>&nbsp;				thumbnails.add(regionStore.getThumbnail(server, getZPosition(), getTPosition(), true));</b>
<i>2250</i>&nbsp;			}
<i>2251</i>&nbsp;		}
<b class="nc"><i>2252</i>&nbsp;		return thumbnails;</b>
<i>2253</i>&nbsp;	}
<i>2254</i>&nbsp;
<i>2255</i>&nbsp;
<i>2256</i>&nbsp;
<i>2257</i>&nbsp;	/**
<i>2258</i>&nbsp;	 * Get a thumbnail representing the image as displayed by this viewer.
<i>2259</i>&nbsp;	 * 
<i>2260</i>&nbsp;	 * Note: This will be a color (aRGB) image, with any color transforms applied -
<i>2261</i>&nbsp;	 * therefore should not be used to extract &#39;original&#39; pixel values
<i>2262</i>&nbsp;	 * @return
<i>2263</i>&nbsp;	 */
<i>2264</i>&nbsp;	public BufferedImage getRGBThumbnail() {
<b class="fc"><i>2265</i>&nbsp;		return imgThumbnailRGB;</b>
<i>2266</i>&nbsp;	}
<i>2267</i>&nbsp;
<i>2268</i>&nbsp;	/**
<i>2269</i>&nbsp;	 * Set downsample factor, so that the specified coordinate in the image space is not shifted in the viewer afterwards.
<i>2270</i>&nbsp;	 * The purpose is to make it possible to zoom in/out while keeping the cursor focussed on a particular location.
<i>2271</i>&nbsp;	 * 
<i>2272</i>&nbsp;	 * The specified downsample factor will automatically be clipped to the range &lt;code&gt;getMinDownsample&lt;/code&gt; to &lt;code&gt;getMaxDownsample&lt;/code&gt;.
<i>2273</i>&nbsp;	 *  
<i>2274</i>&nbsp;	 * @param downsampleFactor
<i>2275</i>&nbsp;	 * @param cx
<i>2276</i>&nbsp;	 * @param cy
<i>2277</i>&nbsp;	 */
<i>2278</i>&nbsp;	public void setDownsampleFactor(double downsampleFactor, double cx, double cy) {
<b class="nc"><i>2279</i>&nbsp;		setDownsampleFactor(downsampleFactor, cx, cy, false);</b>
<b class="nc"><i>2280</i>&nbsp;	}</b>
<i>2281</i>&nbsp;	
<i>2282</i>&nbsp;	/**
<i>2283</i>&nbsp;	 * Set downsample factor, so that the specified coordinate in the image space is not shifted in the viewer afterwards.
<i>2284</i>&nbsp;	 * The purpose is to make it possible to zoom in/out while keeping the cursor focused on a particular location.
<i>2285</i>&nbsp;	 * 
<i>2286</i>&nbsp;	 * @param downsampleFactor
<i>2287</i>&nbsp;	 * @param cx
<i>2288</i>&nbsp;	 * @param cy
<i>2289</i>&nbsp;	 * @param clipToMinMax If &lt;code&gt;true&lt;/code&gt;, the specified downsample factor will be clipped 
<i>2290</i>&nbsp;	 * to the range &lt;code&gt;getMinDownsample&lt;/code&gt; to &lt;code&gt;getMaxDownsample&lt;/code&gt;.
<i>2291</i>&nbsp;	 */
<i>2292</i>&nbsp;	public void setDownsampleFactor(double downsampleFactor, double cx, double cy, boolean clipToMinMax) {
<i>2293</i>&nbsp;		
<i>2294</i>&nbsp;		// Don&#39;t allow setting if we have &#39;zoom to fit&#39;
<b class="nc"><i>2295</i>&nbsp;		if (getZoomToFit())</b>
<b class="nc"><i>2296</i>&nbsp;			return;</b>
<i>2297</i>&nbsp;		
<i>2298</i>&nbsp;		// Ensure within range, if necessary
<b class="nc"><i>2299</i>&nbsp;		if (clipToMinMax)</b>
<b class="nc"><i>2300</i>&nbsp;			downsampleFactor = GeneralTools.clipValue(downsampleFactor, getMinDownsample(), getMaxDownsample());</b>
<i>2301</i>&nbsp;		
<b class="nc"><i>2302</i>&nbsp;		setDownsampleFactorImpl(downsampleFactor, cx, cy);</b>
<b class="nc"><i>2303</i>&nbsp;	}</b>
<i>2304</i>&nbsp;
<i>2305</i>&nbsp;	/**
<i>2306</i>&nbsp;	 * Set downsample factor, so that the specified coordinate in the image space is not shifted in the viewer afterwards.
<i>2307</i>&nbsp;	 * The purpose is to make it possible to zoom in/out while keeping the cursor focussed on a particular location.
<i>2308</i>&nbsp;	 * This avoids doing any additional checking (e.g. of zoom-to-fit).
<i>2309</i>&nbsp;	 * 
<i>2310</i>&nbsp;	 * @param downsampleFactor
<i>2311</i>&nbsp;	 * @param cx
<i>2312</i>&nbsp;	 * @param cy
<i>2313</i>&nbsp;	 */
<i>2314</i>&nbsp;	private void setDownsampleFactorImpl(double downsampleFactor, double cx, double cy) {
<i>2315</i>&nbsp;		
<b class="fc"><i>2316</i>&nbsp;		double currentDownsample = getDownsampleFactor();</b>
<b class="fc"><i>2317</i>&nbsp;		if (currentDownsample == downsampleFactor)</b>
<b class="nc"><i>2318</i>&nbsp;			return;</b>
<i>2319</i>&nbsp;		
<i>2320</i>&nbsp;		// Take care of centering according to the specified coordinates
<b class="fc"><i>2321</i>&nbsp;		if (cx &lt; 0)</b>
<b class="fc"><i>2322</i>&nbsp;			cx = getWidth() / 2.0;</b>
<b class="fc"><i>2323</i>&nbsp;		if (cy &lt; 0)</b>
<b class="fc"><i>2324</i>&nbsp;			cy = getHeight() / 2.0;</b>
<i>2325</i>&nbsp;
<i>2326</i>&nbsp;		// Compute what the x, y coordinates should be to preserve the same image centering
<b class="fc"><i>2327</i>&nbsp;		if (!isRotated()) {</b>
<b class="fc"><i>2328</i>&nbsp;			xCenter += (cx - getWidth()/2.0) * (currentDownsample - downsampleFactor);</b>
<b class="fc"><i>2329</i>&nbsp;			yCenter += (cy - getHeight()/2.0) * (currentDownsample - downsampleFactor);</b>
<i>2330</i>&nbsp;		} else {
<i>2331</i>&nbsp;			// Get the image coordinate
<b class="nc"><i>2332</i>&nbsp;			Point2D p2 = componentPointToImagePoint(cx, cy, null, false);</b>
<b class="nc"><i>2333</i>&nbsp;			double dx = (p2.getX() - xCenter) / currentDownsample * downsampleFactor;</b>
<b class="nc"><i>2334</i>&nbsp;			double dy = (p2.getY() - yCenter) / currentDownsample * downsampleFactor;</b>
<b class="nc"><i>2335</i>&nbsp;			xCenter = p2.getX() - dx;</b>
<b class="nc"><i>2336</i>&nbsp;			yCenter = p2.getY() - dy;</b>
<i>2337</i>&nbsp;		}
<i>2338</i>&nbsp;
<b class="fc"><i>2339</i>&nbsp;		this.downsampleFactor.set(downsampleFactor);</b>
<b class="fc"><i>2340</i>&nbsp;		updateAffineTransform();</b>
<i>2341</i>&nbsp;
<b class="fc"><i>2342</i>&nbsp;		imageUpdated = true;</b>
<b class="fc"><i>2343</i>&nbsp;		repaint();</b>
<b class="fc"><i>2344</i>&nbsp;	}</b>
<i>2345</i>&nbsp;
<i>2346</i>&nbsp;	protected double getZoomToFitDownsampleFactor() {
<b class="fc"><i>2347</i>&nbsp;		if (!hasServer())</b>
<b class="fc"><i>2348</i>&nbsp;			return Double.NaN;</b>
<b class="fc"><i>2349</i>&nbsp;		double maxDownsample = (double)getServerWidth() / getWidth();</b>
<b class="fc"><i>2350</i>&nbsp;		maxDownsample = Math.max(maxDownsample, (double)getServerHeight() / getHeight());</b>
<b class="fc"><i>2351</i>&nbsp;		return maxDownsample;		</b>
<i>2352</i>&nbsp;	}
<i>2353</i>&nbsp;
<i>2354</i>&nbsp;
<i>2355</i>&nbsp;	/**
<i>2356</i>&nbsp;	 * Get the width in pixels of the full resolution of the current image, or 0 if no image is currently open.
<i>2357</i>&nbsp;	 * @return
<i>2358</i>&nbsp;	 */
<i>2359</i>&nbsp;	public int getServerWidth() {
<b class="fc"><i>2360</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="fc"><i>2361</i>&nbsp;		return server == null ? 0 : server.getWidth();</b>
<i>2362</i>&nbsp;	}
<i>2363</i>&nbsp;
<i>2364</i>&nbsp;	/**
<i>2365</i>&nbsp;	 * Get the height in pixels of the full resolution of the current image, or 0 if no image is currently open.
<i>2366</i>&nbsp;	 * @return
<i>2367</i>&nbsp;	 */
<i>2368</i>&nbsp;	public int getServerHeight() {
<b class="fc"><i>2369</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="fc"><i>2370</i>&nbsp;		return server == null ? 0 : server.getHeight();</b>
<i>2371</i>&nbsp;	}
<i>2372</i>&nbsp;
<i>2373</i>&nbsp;
<i>2374</i>&nbsp;//	public Rectangle getServerBounds() {
<i>2375</i>&nbsp;//		ImageServer server = getServer();
<i>2376</i>&nbsp;//		return server == null ? null : new Rectangle(0, 0, server.getWidth(), server.getHeight());
<i>2377</i>&nbsp;//	}
<i>2378</i>&nbsp;	
<i>2379</i>&nbsp;	/**
<i>2380</i>&nbsp;	 * Get an {@link ImageRegion} representing the full width and height of the current image.
<i>2381</i>&nbsp;	 * The {@link ImagePlane} is set according to the z and t position of the viewer.
<i>2382</i>&nbsp;	 * @return
<i>2383</i>&nbsp;	 */
<i>2384</i>&nbsp;	public ImageRegion getServerBounds() {
<b class="fc"><i>2385</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="fc"><i>2386</i>&nbsp;		return server == null ? null : ImageRegion.createInstance(0, 0, server.getWidth(), server.getHeight(), getZPosition(), getTPosition());</b>
<i>2387</i>&nbsp;	}
<i>2388</i>&nbsp;
<i>2389</i>&nbsp;	/**
<i>2390</i>&nbsp;	 * Get the current downsample factor.
<i>2391</i>&nbsp;	 * @return
<i>2392</i>&nbsp;	 */
<i>2393</i>&nbsp;	public double getDownsampleFactor() {
<b class="fc"><i>2394</i>&nbsp;		return downsampleFactor.get();</b>
<i>2395</i>&nbsp;	}
<i>2396</i>&nbsp;
<i>2397</i>&nbsp;	/**
<i>2398</i>&nbsp;	 * Convert a coordinate from the viewer into the corresponding pixel coordinate in the full-resolution image - optionally constraining it to any server bounds.
<i>2399</i>&nbsp;	 * A point object can optionally be provided into which the location is written (may be the same as the component point object).
<i>2400</i>&nbsp;	 * 
<i>2401</i>&nbsp;	 * @param point
<i>2402</i>&nbsp;	 * @param pointDest
<i>2403</i>&nbsp;	 * @param constrainToBounds 
<i>2404</i>&nbsp;	 * @return
<i>2405</i>&nbsp;	 */
<i>2406</i>&nbsp;	public Point2D componentPointToImagePoint(Point2D point, Point2D pointDest, boolean constrainToBounds) {
<b class="nc"><i>2407</i>&nbsp;		return componentPointToImagePoint(point.getX(), point.getY(), pointDest, constrainToBounds);</b>
<i>2408</i>&nbsp;	}
<i>2409</i>&nbsp;
<i>2410</i>&nbsp;	/**
<i>2411</i>&nbsp;	 * Convert x and y coordinates from the component space to the image space.
<i>2412</i>&nbsp;	 * @param x x coordinate, related to {@link #getView()}
<i>2413</i>&nbsp;	 * @param y y coordinate, related to {@link #getView()}
<i>2414</i>&nbsp;	 * @param pointDest object in which to store the corresponding image point (will be set and returned if non-null)
<i>2415</i>&nbsp;	 * @param constrainToBounds if true, clip the image coordinate computed from x and y to fit within the image bounds
<i>2416</i>&nbsp;	 * @return a {@link Point2D} referring to the pixel coordinate corresponding to the component coordinate defined by x and y; 
<i>2417</i>&nbsp;	 */
<i>2418</i>&nbsp;	public Point2D componentPointToImagePoint(double x, double y, Point2D pointDest, boolean constrainToBounds) {
<b class="fc"><i>2419</i>&nbsp;		if (pointDest == null)</b>
<b class="fc"><i>2420</i>&nbsp;			pointDest = new Point2D.Double(x, y);</b>
<i>2421</i>&nbsp;		else
<b class="nc"><i>2422</i>&nbsp;			pointDest.setLocation(x, y);</b>
<i>2423</i>&nbsp;		// Transform the point (in-place)
<b class="fc"><i>2424</i>&nbsp;		transformInverse.transform(pointDest, pointDest);</b>
<i>2425</i>&nbsp;//		pointDest.setLocation(Math.floor(pointDest.getX()), Math.floor(pointDest.getY()));
<i>2426</i>&nbsp;//		pointDest.setLocation(Math.round(pointDest.getX()), Math.round(pointDest.getY()));
<i>2427</i>&nbsp;		// Constrain, if necessary
<b class="fc"><i>2428</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="fc"><i>2429</i>&nbsp;		if (constrainToBounds &amp;&amp; server != null) {</b>
<b class="nc"><i>2430</i>&nbsp;			pointDest.setLocation(</b>
<b class="nc"><i>2431</i>&nbsp;					Math.min(Math.max(pointDest.getX(), 0), server.getWidth()),</b>
<b class="nc"><i>2432</i>&nbsp;					Math.min(Math.max(pointDest.getY(), 0), server.getHeight())</b>
<i>2433</i>&nbsp;					);
<i>2434</i>&nbsp;		}
<b class="fc"><i>2435</i>&nbsp;		return pointDest;</b>
<i>2436</i>&nbsp;	}
<i>2437</i>&nbsp;
<i>2438</i>&nbsp;
<i>2439</i>&nbsp;	/**
<i>2440</i>&nbsp;	 * Convert a coordinate from the the full-resolution image into the corresponding pixel coordinate in the viewer - optionally constraining it to any viewer component bounds.
<i>2441</i>&nbsp;	 * A point object can optionally be provided into which the location is written (may be the same as the image point object).
<i>2442</i>&nbsp;	 * 
<i>2443</i>&nbsp;	 * @param point
<i>2444</i>&nbsp;	 * @param pointDest
<i>2445</i>&nbsp;	 * @param constrainToBounds 
<i>2446</i>&nbsp;	 * @return
<i>2447</i>&nbsp;	 */
<i>2448</i>&nbsp;	public Point2D imagePointToComponentPoint(Point2D point, Point2D pointDest, boolean constrainToBounds) {
<b class="nc"><i>2449</i>&nbsp;		return imagePointToComponentPoint(point.getX(), point.getY(), pointDest, constrainToBounds);</b>
<i>2450</i>&nbsp;	}
<i>2451</i>&nbsp;
<i>2452</i>&nbsp;	private Point2D imagePointToComponentPoint(double x, double y, Point2D pointDest, boolean constrainToBounds) {
<b class="nc"><i>2453</i>&nbsp;		if (pointDest == null)</b>
<b class="nc"><i>2454</i>&nbsp;			pointDest = new Point2D.Double(x, y);</b>
<i>2455</i>&nbsp;		else
<b class="nc"><i>2456</i>&nbsp;			pointDest.setLocation(x, y);</b>
<i>2457</i>&nbsp;		// Transform the point (in-place)
<b class="nc"><i>2458</i>&nbsp;		transform.transform(pointDest, pointDest);</b>
<i>2459</i>&nbsp;		// Constrain, if necessary
<b class="nc"><i>2460</i>&nbsp;		if (constrainToBounds) {</b>
<b class="nc"><i>2461</i>&nbsp;			pointDest.setLocation(</b>
<b class="nc"><i>2462</i>&nbsp;					Math.min(Math.max(pointDest.getX(), 0), getWidth()),</b>
<b class="nc"><i>2463</i>&nbsp;					Math.min(Math.max(pointDest.getY(), 0), getHeight())</b>
<i>2464</i>&nbsp;					);
<i>2465</i>&nbsp;		}
<b class="nc"><i>2466</i>&nbsp;		return pointDest;</b>
<i>2467</i>&nbsp;	}
<i>2468</i>&nbsp;
<i>2469</i>&nbsp;	/**
<i>2470</i>&nbsp;	 * Center the current image in the viewer, while keeping the same downsample factor.
<i>2471</i>&nbsp;	 * This does nothing if no image is currently open.
<i>2472</i>&nbsp;	 */
<i>2473</i>&nbsp;	public void centerImage() {
<b class="fc"><i>2474</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="fc"><i>2475</i>&nbsp;		if (server == null)</b>
<b class="fc"><i>2476</i>&nbsp;			return;</b>
<b class="fc"><i>2477</i>&nbsp;		setCenterPixelLocation(0.5 * server.getWidth(), 0.5 * server.getHeight());</b>
<b class="fc"><i>2478</i>&nbsp;	}</b>
<i>2479</i>&nbsp;
<i>2480</i>&nbsp;	/**
<i>2481</i>&nbsp;	 * Get a string representing the object classification x &amp;amp; y location in the viewer component,
<i>2482</i>&nbsp;	 * or an empty String if no object is found.
<i>2483</i>&nbsp;	 * 
<i>2484</i>&nbsp;	 * @param x x-coordinate in the component space (not image space)
<i>2485</i>&nbsp;	 * @param y y-coordinate in the component space (not image space)
<i>2486</i>&nbsp;	 * @return a String to display representing the object classification
<i>2487</i>&nbsp;	 */
<i>2488</i>&nbsp;	public String getObjectClassificationString(double x, double y) {
<b class="fc"><i>2489</i>&nbsp;		var hierarchy = getHierarchy();</b>
<b class="fc"><i>2490</i>&nbsp;		if (hierarchy == null)</b>
<b class="nc"><i>2491</i>&nbsp;			return &quot;&quot;;</b>
<b class="fc"><i>2492</i>&nbsp;		var p2 = componentPointToImagePoint(x, y, null, false);</b>
<b class="fc"><i>2493</i>&nbsp;		var pathObjects = PathObjectTools.getObjectsForLocation(hierarchy,</b>
<b class="fc"><i>2494</i>&nbsp;				p2.getX(), p2.getY(),</b>
<b class="fc"><i>2495</i>&nbsp;				getZPosition(),</b>
<b class="fc"><i>2496</i>&nbsp;				getTPosition(),</b>
<i>2497</i>&nbsp;				0);
<b class="fc"><i>2498</i>&nbsp;		if (!pathObjects.isEmpty()) {</b>
<b class="nc"><i>2499</i>&nbsp;			return pathObjects.stream()</b>
<b class="nc"><i>2500</i>&nbsp;					.filter(pathObject -&gt; pathObject.isDetection())</b>
<b class="nc"><i>2501</i>&nbsp;					.map(pathObject -&gt; {</b>
<b class="nc"><i>2502</i>&nbsp;				var pathClass = pathObject.getPathClass();</b>
<b class="nc"><i>2503</i>&nbsp;				return pathClass == null ? &quot;Unclassified&quot; : pathClass.toString();</b>
<b class="nc"><i>2504</i>&nbsp;			}).collect(Collectors.joining(&quot;, &quot;));</b>
<i>2505</i>&nbsp;		}
<b class="fc"><i>2506</i>&nbsp;		return &quot;&quot;;</b>
<i>2507</i>&nbsp;	}
<i>2508</i>&nbsp;	
<i>2509</i>&nbsp;	/**
<i>2510</i>&nbsp;	 * Get a string representing the image coordinates for a particular x &amp;amp; y location in the viewer component.
<i>2511</i>&nbsp;	 * 
<i>2512</i>&nbsp;	 * @param x x-coordinate in the component space (not image space)
<i>2513</i>&nbsp;	 * @param y y-coordinate in the component space (not image space)
<i>2514</i>&nbsp;	 * @param useCalibratedUnits 
<i>2515</i>&nbsp;	 * @return a String to display representing the cursor location
<i>2516</i>&nbsp;	 */
<i>2517</i>&nbsp;	public String getLocationString(double x, double y, boolean useCalibratedUnits) {
<b class="fc"><i>2518</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="fc"><i>2519</i>&nbsp;		if (server == null)</b>
<b class="nc"><i>2520</i>&nbsp;			return &quot;&quot;;</b>
<i>2521</i>&nbsp;		String units;
<b class="fc"><i>2522</i>&nbsp;		Point2D p = componentPointToImagePoint(x, y, null, false);</b>
<i>2523</i>&nbsp;		//		double xx = (int)(p.getX() + .5);
<i>2524</i>&nbsp;		//		double yy = (int)(p.getY() + .5);
<b class="fc"><i>2525</i>&nbsp;		double xx = p.getX();</b>
<b class="fc"><i>2526</i>&nbsp;		double yy = p.getY();</b>
<i>2527</i>&nbsp;
<b class="fc"><i>2528</i>&nbsp;		if (xx &lt; 0 || yy &lt; 0 || xx &gt; server.getWidth()-1 || yy &gt; server.getHeight()-1)</b>
<b class="fc"><i>2529</i>&nbsp;			return &quot;&quot;;</b>
<i>2530</i>&nbsp;
<b class="fc"><i>2531</i>&nbsp;		double xDisplay = xx;</b>
<b class="fc"><i>2532</i>&nbsp;		double yDisplay = yy;</b>
<b class="fc"><i>2533</i>&nbsp;		PixelCalibration cal = server.getPixelCalibration();</b>
<b class="fc"><i>2534</i>&nbsp;		if (useCalibratedUnits &amp;&amp; cal.hasPixelSizeMicrons()) {</b>
<b class="nc"><i>2535</i>&nbsp;			units = GeneralTools.micrometerSymbol();</b>
<b class="nc"><i>2536</i>&nbsp;			xDisplay *= cal.getPixelWidthMicrons();</b>
<b class="nc"><i>2537</i>&nbsp;			yDisplay *= cal.getPixelHeightMicrons();</b>
<i>2538</i>&nbsp;		} else {
<b class="fc"><i>2539</i>&nbsp;			units = &quot;px&quot;;</b>
<i>2540</i>&nbsp;		}
<i>2541</i>&nbsp;		
<i>2542</i>&nbsp;		// See if we&#39;re on top of a TMA core
<b class="fc"><i>2543</i>&nbsp;		String prefix = &quot;&quot;;</b>
<b class="fc"><i>2544</i>&nbsp;		TMAGrid tmaGrid = getHierarchy().getTMAGrid();</b>
<b class="fc"><i>2545</i>&nbsp;		if (tmaGrid != null) {</b>
<b class="nc"><i>2546</i>&nbsp;			TMACoreObject core = PathObjectTools.getTMACoreForPixel(tmaGrid, xx, yy);</b>
<b class="nc"><i>2547</i>&nbsp;			if (core != null &amp;&amp; core.getName() != null)</b>
<b class="nc"><i>2548</i>&nbsp;				prefix = &quot;Core: &quot; + core.getName() + &quot;\n&quot;;</b>
<i>2549</i>&nbsp;		}
<i>2550</i>&nbsp;
<b class="fc"><i>2551</i>&nbsp;		String s = null;</b>
<b class="fc"><i>2552</i>&nbsp;		RegionRequest request = ImageRegionStoreHelpers.getTileRequest(server, xx, yy, downsampleFactor.get(), getZPosition(), getTPosition());</b>
<b class="fc"><i>2553</i>&nbsp;		if (request != null) {</b>
<b class="fc"><i>2554</i>&nbsp;			BufferedImage img = regionStore.getCachedTile(server, request);</b>
<b class="fc"><i>2555</i>&nbsp;			int xi = 0, yi = 0;</b>
<b class="fc"><i>2556</i>&nbsp;			if (img == null) {</b>
<i>2557</i>&nbsp;				// Try getting a value from the thumbnail for the whole image
<b class="nc"><i>2558</i>&nbsp;				BufferedImage imgThumbnail = regionStore.getCachedThumbnail(server, getZPosition(), getTPosition());</b>
<b class="nc"><i>2559</i>&nbsp;				if (imgThumbnail != null) {</b>
<b class="nc"><i>2560</i>&nbsp;					img = imgThumbnail;</b>
<b class="nc"><i>2561</i>&nbsp;					double downsample = (double)server.getWidth() / imgThumbnail.getWidth();</b>
<b class="nc"><i>2562</i>&nbsp;					xi = (int)(xx / downsample + .5);</b>
<b class="nc"><i>2563</i>&nbsp;					yi = (int)(yy / downsample + .5);</b>
<i>2564</i>&nbsp;				}
<b class="nc"><i>2565</i>&nbsp;			} else {</b>
<b class="fc"><i>2566</i>&nbsp;				xi = (int)((xx - request.getX())/request.getDownsample());</b>
<b class="fc"><i>2567</i>&nbsp;				yi = (int)((yy - request.getY())/request.getDownsample());</b>
<i>2568</i>&nbsp;			}
<b class="fc"><i>2569</i>&nbsp;			if (img != null) {</b>
<i>2570</i>&nbsp;				// Make sure we are within range
<b class="fc"><i>2571</i>&nbsp;				xi = Math.min(xi, img.getWidth()-1);</b>
<b class="fc"><i>2572</i>&nbsp;				yi = Math.min(yi, img.getHeight()-1);</b>
<i>2573</i>&nbsp;				// Get the value, having applied any required color transforms
<b class="fc"><i>2574</i>&nbsp;				if (imageDisplay != null)</b>
<b class="fc"><i>2575</i>&nbsp;					s = imageDisplay.getTransformedValueAsString(img, xi, yi);</b>
<i>2576</i>&nbsp;			}
<i>2577</i>&nbsp;		}
<i>2578</i>&nbsp;		
<i>2579</i>&nbsp;		// Append z, t position if required
<b class="fc"><i>2580</i>&nbsp;		String zString = null;</b>
<b class="fc"><i>2581</i>&nbsp;		if (server.nZSlices() &gt; 1) {</b>
<b class="nc"><i>2582</i>&nbsp;			double zSpacing = server.getPixelCalibration().getZSpacingMicrons();</b>
<b class="nc"><i>2583</i>&nbsp;			if (!useCalibratedUnits || Double.isNaN(zSpacing))</b>
<b class="nc"><i>2584</i>&nbsp;				zString = &quot;z = &quot; + getZPosition();</b>
<i>2585</i>&nbsp;			else
<b class="nc"><i>2586</i>&nbsp;				zString = String.format(&quot;z = %.2f %s&quot;, getZPosition()*zSpacing, GeneralTools.micrometerSymbol());</b>
<i>2587</i>&nbsp;		}
<b class="fc"><i>2588</i>&nbsp;		String tString = null;</b>
<b class="fc"><i>2589</i>&nbsp;		if (server.nTimepoints() &gt; 1) {</b>
<i>2590</i>&nbsp;			// TODO: Consider use of TimeUnit
<i>2591</i>&nbsp;//			TimeUnit timeUnit = server.getTimeUnit();
<i>2592</i>&nbsp;//			if (!useMicrons || timeUnit == null)
<b class="nc"><i>2593</i>&nbsp;				tString = &quot;t = &quot; + getTPosition();</b>
<i>2594</i>&nbsp;//			else
<i>2595</i>&nbsp;//				tString = String.format(&quot;z = %.2f %s&quot;, getTPosition(), timeUnit.toString());
<i>2596</i>&nbsp;		}
<i>2597</i>&nbsp;
<i>2598</i>&nbsp;		String dimensionString;
<b class="fc"><i>2599</i>&nbsp;		if (tString == null &amp;&amp; zString == null)</b>
<b class="fc"><i>2600</i>&nbsp;			dimensionString = &quot;&quot;;</b>
<i>2601</i>&nbsp;		else {
<b class="nc"><i>2602</i>&nbsp;			dimensionString = &quot;\n&quot;;</b>
<b class="nc"><i>2603</i>&nbsp;			if (zString != null) {</b>
<b class="nc"><i>2604</i>&nbsp;				dimensionString += zString;</b>
<b class="nc"><i>2605</i>&nbsp;				if (tString != null)</b>
<b class="nc"><i>2606</i>&nbsp;					dimensionString += &quot;, &quot; + tString;</b>
<i>2607</i>&nbsp;			} else
<b class="nc"><i>2608</i>&nbsp;				dimensionString += tString;</b>
<i>2609</i>&nbsp;		}
<i>2610</i>&nbsp;
<b class="fc"><i>2611</i>&nbsp;		if (s != null)</b>
<b class="fc"><i>2612</i>&nbsp;			return String.format(&quot;%s%.2f, %.2f %s\n%s%s&quot;, prefix, xDisplay, yDisplay, units, s, dimensionString);</b>
<i>2613</i>&nbsp;		else
<b class="nc"><i>2614</i>&nbsp;			return String.format(&quot;%s%.2f, %.2f %s%s&quot;, prefix, xDisplay, yDisplay, units, dimensionString);</b>
<i>2615</i>&nbsp;		
<i>2616</i>&nbsp;		
<i>2617</i>&nbsp;//		if (s != null)
<i>2618</i>&nbsp;//			return String.format(&quot;&lt;html&gt;&lt;center&gt;%.2f, %.2f %s&lt;br&gt;%s&quot;, xDisplay, yDisplay, units, s);
<i>2619</i>&nbsp;//		else
<i>2620</i>&nbsp;//			return String.format(&quot;&lt;html&gt;&lt;center&gt;%.2f, %.2f %s&quot;, xDisplay, yDisplay, units);
<i>2621</i>&nbsp;	}
<i>2622</i>&nbsp;
<i>2623</i>&nbsp;	/**
<i>2624</i>&nbsp;	 * Get a string to summarize the pixel found below the most recent known mouse location, 
<i>2625</i>&nbsp;	 * or &quot;&quot; if the mouse is outside this viewer.
<i>2626</i>&nbsp;	 * 
<i>2627</i>&nbsp;	 * @param useCalibratedUnits If true, microns will be used rather than pixels (if known).
<i>2628</i>&nbsp;	 * @return
<i>2629</i>&nbsp;	 */
<i>2630</i>&nbsp;	protected String getFullLocationString(boolean useCalibratedUnits) {
<b class="fc"><i>2631</i>&nbsp;		if (componentContains(mouseX, mouseY)) {</b>
<b class="fc"><i>2632</i>&nbsp;			String classString = getObjectClassificationString(mouseX, mouseY).trim();</b>
<b class="fc"><i>2633</i>&nbsp;			String locationString = getLocationString(mouseX, mouseY, useCalibratedUnits);</b>
<b class="fc"><i>2634</i>&nbsp;			if (locationString == null || locationString.isBlank())</b>
<b class="fc"><i>2635</i>&nbsp;				return &quot;&quot;;</b>
<b class="fc"><i>2636</i>&nbsp;			if (classString != null &amp;&amp; !classString.isBlank())</b>
<b class="nc"><i>2637</i>&nbsp;				classString = classString + &quot;\n&quot;;</b>
<b class="fc"><i>2638</i>&nbsp;			return classString + locationString;</b>
<i>2639</i>&nbsp;		} else
<b class="nc"><i>2640</i>&nbsp;			return &quot;&quot;;</b>
<i>2641</i>&nbsp;	}
<i>2642</i>&nbsp;
<i>2643</i>&nbsp;	
<i>2644</i>&nbsp;	/**
<i>2645</i>&nbsp;	 * Get the object hierarchy for the current image data, or null if no image data is available.
<i>2646</i>&nbsp;	 * @return
<i>2647</i>&nbsp;	 */
<i>2648</i>&nbsp;	public PathObjectHierarchy getHierarchy() {
<b class="fc"><i>2649</i>&nbsp;		ImageData&lt;BufferedImage&gt; temp = imageDataProperty.get();</b>
<b class="fc"><i>2650</i>&nbsp;		return temp == null ? null : temp.getHierarchy();</b>
<i>2651</i>&nbsp;	}
<i>2652</i>&nbsp;
<i>2653</i>&nbsp;	/**
<i>2654</i>&nbsp;	 * Add a viewer listener.
<i>2655</i>&nbsp;	 * @param listener
<i>2656</i>&nbsp;	 */
<i>2657</i>&nbsp;	public void addViewerListener(QuPathViewerListener listener) {
<b class="fc"><i>2658</i>&nbsp;		listeners.add(listener);</b>
<b class="fc"><i>2659</i>&nbsp;	}</b>
<i>2660</i>&nbsp;
<i>2661</i>&nbsp;	/**
<i>2662</i>&nbsp;	 * Remove a viewer listener.
<i>2663</i>&nbsp;	 * @param listener
<i>2664</i>&nbsp;	 */
<i>2665</i>&nbsp;	public void removeViewerListener(QuPathViewerListener listener) {
<b class="nc"><i>2666</i>&nbsp;		listeners.remove(listener);</b>
<b class="nc"><i>2667</i>&nbsp;	}</b>
<i>2668</i>&nbsp;
<i>2669</i>&nbsp;
<i>2670</i>&nbsp;	/**
<i>2671</i>&nbsp;	 * Set the image pixel to display in the center of the viewer (using image pixel coordinates at the full-resolution)
<i>2672</i>&nbsp;	 * @param x
<i>2673</i>&nbsp;	 * @param y
<i>2674</i>&nbsp;	 */
<i>2675</i>&nbsp;	public void setCenterPixelLocation(double x, double y) {
<b class="fc"><i>2676</i>&nbsp;		if ((this.xCenter == x &amp;&amp; this.yCenter == y) || Double.isNaN(x + y))</b>
<b class="nc"><i>2677</i>&nbsp;			return;</b>
<i>2678</i>&nbsp;		
<i>2679</i>&nbsp;//		double dx = xCenter - x;
<i>2680</i>&nbsp;//		double dy = yCenter - y;
<i>2681</i>&nbsp;//		if (dx*dx + dy*dy &gt; 1000) {
<i>2682</i>&nbsp;//			System.err.println(&quot;Moving a lot&quot;);
<i>2683</i>&nbsp;//		}
<i>2684</i>&nbsp;
<b class="fc"><i>2685</i>&nbsp;		this.xCenter = x;</b>
<b class="fc"><i>2686</i>&nbsp;		this.yCenter = y;</b>
<b class="fc"><i>2687</i>&nbsp;		updateAffineTransform();</b>
<i>2688</i>&nbsp;
<i>2689</i>&nbsp;		// Flag that the location has been updated
<b class="fc"><i>2690</i>&nbsp;		locationUpdated = true;</b>
<b class="fc"><i>2691</i>&nbsp;		repaint();</b>
<b class="fc"><i>2692</i>&nbsp;	}</b>
<i>2693</i>&nbsp;
<i>2694</i>&nbsp;	
<i>2695</i>&nbsp;	/**
<i>2696</i>&nbsp;	 * Center the specified ROI in the viewer
<i>2697</i>&nbsp;	 * @param roi
<i>2698</i>&nbsp;	 */
<i>2699</i>&nbsp;	public void centerROI(ROI roi) {
<b class="nc"><i>2700</i>&nbsp;		if (roi == null)</b>
<b class="nc"><i>2701</i>&nbsp;			return;</b>
<b class="nc"><i>2702</i>&nbsp;		double x = roi.getCentroidX();</b>
<b class="nc"><i>2703</i>&nbsp;		double y = roi.getCentroidY();</b>
<b class="nc"><i>2704</i>&nbsp;		setZPosition(roi.getZ());</b>
<b class="nc"><i>2705</i>&nbsp;		setTPosition(roi.getT());</b>
<b class="nc"><i>2706</i>&nbsp;		setCenterPixelLocation(x, y);</b>
<b class="nc"><i>2707</i>&nbsp;	}</b>
<i>2708</i>&nbsp;
<i>2709</i>&nbsp;
<i>2710</i>&nbsp;
<i>2711</i>&nbsp;	protected void updateAffineTransform() {
<b class="fc"><i>2712</i>&nbsp;		if (!hasServer())</b>
<b class="fc"><i>2713</i>&nbsp;			return;</b>
<i>2714</i>&nbsp;
<b class="fc"><i>2715</i>&nbsp;		transform.setToIdentity();</b>
<b class="fc"><i>2716</i>&nbsp;		transform.translate(getWidth()*.5, getHeight()*.5);</b>
<b class="fc"><i>2717</i>&nbsp;		double downsample = getDownsampleFactor();</b>
<b class="fc"><i>2718</i>&nbsp;		transform.scale(1.0/downsample, 1.0/downsample);</b>
<b class="fc"><i>2719</i>&nbsp;		transform.translate(-xCenter, -yCenter);</b>
<b class="fc"><i>2720</i>&nbsp;		if (rotation != 0)</b>
<b class="nc"><i>2721</i>&nbsp;			transform.rotate(rotation, xCenter, yCenter);</b>
<i>2722</i>&nbsp;
<b class="fc"><i>2723</i>&nbsp;		transformInverse.setTransform(transform);</b>
<i>2724</i>&nbsp;		try {
<b class="fc"><i>2725</i>&nbsp;			transformInverse.invert();</b>
<b class="nc"><i>2726</i>&nbsp;		} catch (NoninvertibleTransformException e) {</b>
<b class="nc"><i>2727</i>&nbsp;			logger.warn(&quot;Transform not invertible!&quot;, e);</b>
<b class="fc"><i>2728</i>&nbsp;		}</b>
<b class="fc"><i>2729</i>&nbsp;	}</b>
<i>2730</i>&nbsp;	
<i>2731</i>&nbsp;//	
<i>2732</i>&nbsp;//	public AffineTransform getTransform() {
<i>2733</i>&nbsp;//		return new AffineTransform(transform);
<i>2734</i>&nbsp;//	}
<i>2735</i>&nbsp;//
<i>2736</i>&nbsp;//	public AffineTransform getInverseTransform() {
<i>2737</i>&nbsp;//		return new AffineTransform(transformInverse);
<i>2738</i>&nbsp;//	}
<i>2739</i>&nbsp;
<i>2740</i>&nbsp;
<i>2741</i>&nbsp;	/**
<i>2742</i>&nbsp;	 * Set the rotation; angle in radians.
<i>2743</i>&nbsp;	 * 
<i>2744</i>&nbsp;	 * @param theta
<i>2745</i>&nbsp;	 */
<i>2746</i>&nbsp;	public void setRotation(double theta) {
<b class="nc"><i>2747</i>&nbsp;		if (this.rotation == theta)</b>
<b class="nc"><i>2748</i>&nbsp;			return;</b>
<b class="nc"><i>2749</i>&nbsp;		this.rotation = theta;</b>
<b class="nc"><i>2750</i>&nbsp;		imageUpdated = true;</b>
<b class="nc"><i>2751</i>&nbsp;		updateAffineTransform();</b>
<b class="nc"><i>2752</i>&nbsp;		repaint();</b>
<b class="nc"><i>2753</i>&nbsp;	}</b>
<i>2754</i>&nbsp;
<i>2755</i>&nbsp;	/**
<i>2756</i>&nbsp;	 * Returns true if {@code viewer.getRotation() != 0}.
<i>2757</i>&nbsp;	 * @return
<i>2758</i>&nbsp;	 */
<i>2759</i>&nbsp;	public boolean isRotated() {
<b class="fc"><i>2760</i>&nbsp;		return getRotation() != 0;</b>
<i>2761</i>&nbsp;	}
<i>2762</i>&nbsp;
<i>2763</i>&nbsp;	/**
<i>2764</i>&nbsp;	 * Get the current rotation; angle in radians.
<i>2765</i>&nbsp;	 * @return
<i>2766</i>&nbsp;	 */
<i>2767</i>&nbsp;	public double getRotation() {
<b class="fc"><i>2768</i>&nbsp;		return rotation;</b>
<i>2769</i>&nbsp;	}
<i>2770</i>&nbsp;
<i>2771</i>&nbsp;	@Override
<i>2772</i>&nbsp;	public void tileAvailable(String serverPath, ImageRegion region, BufferedImage tile) {
<i>2773</i>&nbsp;		//		if (serverPath == null || serverPath.equals(getServerPath()))
<i>2774</i>&nbsp;//		System.out.println(region);
<i>2775</i>&nbsp;		
<b class="fc"><i>2776</i>&nbsp;		if (!hasServer())</b>
<b class="nc"><i>2777</i>&nbsp;			return;</b>
<i>2778</i>&nbsp;		
<i>2779</i>&nbsp;		// Check contains rather than equals to all for derived servers (e.g. for painting hierarchies)
<b class="fc"><i>2780</i>&nbsp;		if (serverPath == null || serverPath.contains(getServerPath()))</b>
<b class="fc"><i>2781</i>&nbsp;			repaintImageRegion(AwtTools.getBounds(region), true);//!serverPath.startsWith(PathHierarchyImageServer.DEFAULT_PREFIX));</b>
<i>2782</i>&nbsp;		
<i>2783</i>&nbsp;		//		imageUpdated = true;
<i>2784</i>&nbsp;		//		repaint();
<b class="fc"><i>2785</i>&nbsp;	}</b>
<i>2786</i>&nbsp;
<i>2787</i>&nbsp;
<i>2788</i>&nbsp;	/**
<i>2789</i>&nbsp;	 * Force the overlay displaying detections and annotations to be repainted.  Any cached versions will be thrown away, so this is useful when
<i>2790</i>&nbsp;	 * some aspect of the display has changed, e.g. objects colors or fill/outline status.  Due to the usefulness of caching for performance, it should
<i>2791</i>&nbsp;	 * not be called too often.
<i>2792</i>&nbsp;	 */
<i>2793</i>&nbsp;	public void forceOverlayUpdate() {
<b class="nc"><i>2794</i>&nbsp;		if (Platform.isFxApplicationThread())</b>
<b class="nc"><i>2795</i>&nbsp;			hierarchyOverlay.clearCachedOverlay();</b>
<i>2796</i>&nbsp;		else
<b class="nc"><i>2797</i>&nbsp;			Platform.runLater(() -&gt; hierarchyOverlay.clearCachedOverlay());</b>
<b class="nc"><i>2798</i>&nbsp;		repaint();</b>
<b class="nc"><i>2799</i>&nbsp;	}</b>
<i>2800</i>&nbsp;
<i>2801</i>&nbsp;
<i>2802</i>&nbsp;
<i>2803</i>&nbsp;	@Override
<i>2804</i>&nbsp;	public void hierarchyChanged(final PathObjectHierarchyEvent event) {
<i>2805</i>&nbsp;		// Measurement changes don&#39;t modify the hierarchy
<b class="nc"><i>2806</i>&nbsp;		if (event.isObjectMeasurementEvent())</b>
<b class="nc"><i>2807</i>&nbsp;			return;</b>
<i>2808</i>&nbsp;
<b class="nc"><i>2809</i>&nbsp;		if (Platform.isFxApplicationThread())</b>
<b class="nc"><i>2810</i>&nbsp;			handleHierarchyChange(event);</b>
<i>2811</i>&nbsp;		else
<b class="nc"><i>2812</i>&nbsp;			Platform.runLater(() -&gt; handleHierarchyChange(event));</b>
<b class="nc"><i>2813</i>&nbsp;	}</b>
<i>2814</i>&nbsp;
<i>2815</i>&nbsp;
<i>2816</i>&nbsp;	private void handleHierarchyChange(final PathObjectHierarchyEvent event) {
<b class="nc"><i>2817</i>&nbsp;		if (event != null)</b>
<b class="nc"><i>2818</i>&nbsp;			logger.trace(event.toString());</b>
<i>2819</i>&nbsp;		
<b class="nc"><i>2820</i>&nbsp;		if (!Platform.isFxApplicationThread()) {</b>
<b class="nc"><i>2821</i>&nbsp;			Platform.runLater(() -&gt; handleHierarchyChange(event));</b>
<b class="nc"><i>2822</i>&nbsp;			return;</b>
<i>2823</i>&nbsp;		}
<i>2824</i>&nbsp;		
<i>2825</i>&nbsp;		// Clear any cached regions of the overlay, if necessary
<i>2826</i>&nbsp;		// TODO: Make this update a bit less conservative - it isn&#39;t really needed if we don&#39;t modify detections?
<b class="nc"><i>2827</i>&nbsp;		if (event == null || event.isStructureChangeEvent())</b>
<b class="nc"><i>2828</i>&nbsp;			hierarchyOverlay.clearCachedOverlay();</b>
<i>2829</i>&nbsp;		else {
<b class="nc"><i>2830</i>&nbsp;			List&lt;PathObject&gt; pathObjects = event.getChangedObjects();</b>
<b class="nc"><i>2831</i>&nbsp;			List&lt;PathObject&gt; pathDetectionObjects = PathObjectTools.getObjectsOfClass(pathObjects, PathDetectionObject.class);</b>
<b class="nc"><i>2832</i>&nbsp;			if (pathDetectionObjects.size() &lt;= 50) {</b>
<i>2833</i>&nbsp;				// TODO: PUT THIS LISTENER INTO THE HIERARCHY OVERLAY ITSELF?  But then the order of events is uncertain... hierarchy would need to be able to call repaint as well
<i>2834</i>&nbsp;				// (or possibly post an event?)
<b class="nc"><i>2835</i>&nbsp;				for (PathObject temp : pathDetectionObjects) {</b>
<b class="nc"><i>2836</i>&nbsp;					if (temp.hasROI())</b>
<b class="nc"><i>2837</i>&nbsp;						hierarchyOverlay.clearCachedOverlayForRegion(ImageRegion.createInstance(temp.getROI()));</b>
<b class="nc"><i>2838</i>&nbsp;				}</b>
<i>2839</i>&nbsp;			} else {
<b class="nc"><i>2840</i>&nbsp;				hierarchyOverlay.clearCachedOverlay();</b>
<i>2841</i>&nbsp;			}
<i>2842</i>&nbsp;		}
<i>2843</i>&nbsp;//		hierarchyOverlay.clearCachedOverlay();
<i>2844</i>&nbsp;
<i>2845</i>&nbsp;		// Just in case, make sure the handles are updated in any ROIEditor
<b class="nc"><i>2846</i>&nbsp;		if (event != null &amp;&amp; !event.isChanging())</b>
<b class="nc"><i>2847</i>&nbsp;			updateRoiEditor();</b>
<i>2848</i>&nbsp;		// Request repaint
<b class="nc"><i>2849</i>&nbsp;		repaint();</b>
<b class="nc"><i>2850</i>&nbsp;	}</b>
<i>2851</i>&nbsp;
<i>2852</i>&nbsp;
<i>2853</i>&nbsp;
<i>2854</i>&nbsp;	@Override
<i>2855</i>&nbsp;	public void selectedPathObjectChanged(PathObject pathObjectSelected, PathObject previousObject, Collection&lt;PathObject&gt; allSelected) {
<i>2856</i>&nbsp;
<i>2857</i>&nbsp;//		// We only want to shift the object ROI to the center under certain conditions, otherwise the screen jerks annoyingly
<i>2858</i>&nbsp;//		if (!settingSelectedObject &amp;&amp; pathObjectSelected != previousObject &amp;&amp; !getZoomToFit() &amp;&amp; pathObjectSelected != null &amp;&amp; RoiTools.isShapeROI(pathObjectSelected.getROI())) {
<i>2859</i>&nbsp;//
<i>2860</i>&nbsp;//			// We want to center a TMA core if more than half of it is outside the window
<i>2861</i>&nbsp;//			boolean centerCore = false;
<i>2862</i>&nbsp;//			Shape shapeDisplayed = getDisplayedRegionShape();
<i>2863</i>&nbsp;//			ROI pathROI = pathObjectSelected.getROI();
<i>2864</i>&nbsp;//			if (centerCore || !shapeDisplayed.intersects(pathROI.getBoundsX(), pathROI.getBoundsY(), pathROI.getBoundsWidth(), pathROI.getBoundsHeight())) {
<i>2865</i>&nbsp;//				//			if (!getDisplayedRegionShape().intersects(pathObjectSelected.getROI().getBounds2D())) {
<i>2866</i>&nbsp;//				//			(!(pathObjectSelected instanceof PathDetectionObject &amp;&amp; getDisplayedRegionShape().intersects(pathObjectSelected.getROI().getBounds2D())))) {
<i>2867</i>&nbsp;//				double cx = pathObjectSelected.getROI().getCentroidX();
<i>2868</i>&nbsp;//				double cy = pathObjectSelected.getROI().getCentroidY();
<i>2869</i>&nbsp;//				setCenterPixelLocation(cx, cy);
<i>2870</i>&nbsp;//				//		logger.info(&quot;Centered to &quot; + cx + &quot;, &quot; + cy);
<i>2871</i>&nbsp;//			}
<i>2872</i>&nbsp;//		}
<b class="fc"><i>2873</i>&nbsp;		updateRoiEditor();</b>
<b class="fc"><i>2874</i>&nbsp;		for (QuPathViewerListener listener : new ArrayList&lt;QuPathViewerListener&gt;(listeners)) {</b>
<b class="fc"><i>2875</i>&nbsp;			listener.selectedObjectChanged(this, pathObjectSelected);</b>
<b class="fc"><i>2876</i>&nbsp;		}</b>
<i>2877</i>&nbsp;
<b class="fc"><i>2878</i>&nbsp;		if (Platform.isFxApplicationThread())</b>
<b class="fc"><i>2879</i>&nbsp;			hierarchyOverlay.resetBuffer();</b>
<i>2880</i>&nbsp;		else
<b class="nc"><i>2881</i>&nbsp;			Platform.runLater(() -&gt; hierarchyOverlay.resetBuffer());</b>
<b class="fc"><i>2882</i>&nbsp;		logger.trace(&quot;Selected path object changed from {} to {}&quot;, previousObject, pathObjectSelected);</b>
<i>2883</i>&nbsp;
<b class="fc"><i>2884</i>&nbsp;		repaint();</b>
<i>2885</i>&nbsp;//		repaintEntireImage();
<b class="fc"><i>2886</i>&nbsp;	}</b>
<i>2887</i>&nbsp;
<i>2888</i>&nbsp;	private void updateRoiEditor() {
<b class="fc"><i>2889</i>&nbsp;		PathObject pathObjectSelected = getSelectedObject();</b>
<b class="fc"><i>2890</i>&nbsp;		ROI previousROI = roiEditor.getROI();</b>
<b class="fc"><i>2891</i>&nbsp;		ROI newROI = pathObjectSelected != null &amp;&amp; pathObjectSelected.isEditable() ? pathObjectSelected.getROI() : null;</b>
<i>2892</i>&nbsp;
<b class="fc"><i>2893</i>&nbsp;		if (previousROI == newROI)</b>
<b class="fc"><i>2894</i>&nbsp;			roiEditor.ensureHandlesUpdated();</b>
<i>2895</i>&nbsp;		else
<b class="nc"><i>2896</i>&nbsp;			roiEditor.setROI(newROI);</b>
<i>2897</i>&nbsp;
<b class="fc"><i>2898</i>&nbsp;		repaint();		</b>
<b class="fc"><i>2899</i>&nbsp;	}</b>
<i>2900</i>&nbsp;
<i>2901</i>&nbsp;
<i>2902</i>&nbsp;	private synchronized String getServerPath() {
<b class="fc"><i>2903</i>&nbsp;		ImageServer&lt;BufferedImage&gt; server = getServer();</b>
<b class="fc"><i>2904</i>&nbsp;		return server == null ? null : server.getPath();</b>
<i>2905</i>&nbsp;	}
<i>2906</i>&nbsp;
<i>2907</i>&nbsp;	@Override
<i>2908</i>&nbsp;	public synchronized boolean requiresTileRegion(final String serverPath, final ImageRegion region) {
<i>2909</i>&nbsp;		//		String path = getServerPath();
<i>2910</i>&nbsp;		//		return path.equals(serverPath) &amp;&amp; (getDisplayedClipShape(null).intersects(region));
<i>2911</i>&nbsp;		//		if (region instanceof RegionRequest &amp;&amp; getDownsampleFactor() &lt; ((RegionRequest)region).getDownsample())
<i>2912</i>&nbsp;		//			return false;
<b class="nc"><i>2913</i>&nbsp;		if (serverPath.startsWith(PathHierarchyImageServer.DEFAULT_PREFIX) || serverPath.equals(getServerPath())) {</b>
<b class="nc"><i>2914</i>&nbsp;			return Math.abs(region.getZ() - getZPosition()) &lt;= 3 &amp;&amp; region.getT() == getTPosition() &amp;&amp; getDisplayedClipShape(null).intersects(AwtTools.getBounds(region));</b>
<i>2915</i>&nbsp;		}
<b class="nc"><i>2916</i>&nbsp;		return false;</b>
<i>2917</i>&nbsp;	}
<i>2918</i>&nbsp;	
<i>2919</i>&nbsp;	
<i>2920</i>&nbsp;	@Override
<i>2921</i>&nbsp;	public String toString() {
<b class="nc"><i>2922</i>&nbsp;		ImageData&lt;BufferedImage&gt; temp = imageDataProperty.get();</b>
<b class="nc"><i>2923</i>&nbsp;		if (temp != null)</b>
<b class="nc"><i>2924</i>&nbsp;			return getClass().getSimpleName() + &quot; - &quot; + temp.getServerPath();</b>
<b class="nc"><i>2925</i>&nbsp;		return getClass().getSimpleName() + &quot; - no server&quot;;</b>
<i>2926</i>&nbsp;	}
<i>2927</i>&nbsp;
<i>2928</i>&nbsp;
<i>2929</i>&nbsp;	/**
<i>2930</i>&nbsp;	 * Current z-position for the z-slice currently visible in the viewer.
<i>2931</i>&nbsp;	 * @return
<i>2932</i>&nbsp;	 */
<i>2933</i>&nbsp;	public IntegerProperty zPositionProperty() {
<b class="fc"><i>2934</i>&nbsp;		return zPosition;</b>
<i>2935</i>&nbsp;	}
<i>2936</i>&nbsp;	
<i>2937</i>&nbsp;	/**
<i>2938</i>&nbsp;	 * Current t-position for the timepoint currently visible in the viewer.
<i>2939</i>&nbsp;	 * @return
<i>2940</i>&nbsp;	 */
<i>2941</i>&nbsp;	public IntegerProperty tPositionProperty() {
<b class="fc"><i>2942</i>&nbsp;		return tPosition;</b>
<i>2943</i>&nbsp;	}
<i>2944</i>&nbsp;	
<i>2945</i>&nbsp;	
<i>2946</i>&nbsp;	
<i>2947</i>&nbsp;	
<i>2948</i>&nbsp;	
<i>2949</i>&nbsp;	/**
<i>2950</i>&nbsp;	 * Watch for spacebar pressing as an event filter, because we don&#39;t wanna miss a thing.
<i>2951</i>&nbsp;	 */
<b class="fc"><i>2952</i>&nbsp;	class KeyEventFilter implements EventHandler&lt;KeyEvent&gt; {</b>
<i>2953</i>&nbsp;
<i>2954</i>&nbsp;		@Override
<i>2955</i>&nbsp;		public void handle(KeyEvent event) {
<b class="nc"><i>2956</i>&nbsp;			KeyCode code = event.getCode();</b>
<i>2957</i>&nbsp;
<i>2958</i>&nbsp;			// Handle spacebar pressed (log state for later)
<b class="nc"><i>2959</i>&nbsp;			if (code == KeyCode.SPACE) {</b>
<b class="nc"><i>2960</i>&nbsp;				if (event.getEventType() == KeyEvent.KEY_PRESSED)</b>
<b class="nc"><i>2961</i>&nbsp;					setSpaceDown(true);</b>
<b class="nc"><i>2962</i>&nbsp;				else if (event.getEventType() == KeyEvent.KEY_RELEASED)</b>
<b class="nc"><i>2963</i>&nbsp;					setSpaceDown(false);</b>
<b class="nc"><i>2964</i>&nbsp;				return;</b>
<i>2965</i>&nbsp;			}
<b class="nc"><i>2966</i>&nbsp;		}</b>
<i>2967</i>&nbsp;		
<i>2968</i>&nbsp;	}
<i>2969</i>&nbsp;	
<i>2970</i>&nbsp;	
<i>2971</i>&nbsp;	/**
<i>2972</i>&nbsp;	 * Handle key press events that control viewer directly.
<i>2973</i>&nbsp;	 */
<b class="fc"><i>2974</i>&nbsp;	class KeyEventHandler implements EventHandler&lt;KeyEvent&gt; {</b>
<i>2975</i>&nbsp;
<b class="fc"><i>2976</i>&nbsp;		private long keyDownTime = Long.MIN_VALUE;</b>
<b class="fc"><i>2977</i>&nbsp;		private double scale = 1.0;</b>
<i>2978</i>&nbsp;
<i>2979</i>&nbsp;		@Override
<i>2980</i>&nbsp;		public void handle(KeyEvent event) {
<b class="nc"><i>2981</i>&nbsp;			KeyCode code = event.getCode();</b>
<i>2982</i>&nbsp;			
<i>2983</i>&nbsp;			// Handle backspace/delete to remove selected object
<b class="nc"><i>2984</i>&nbsp;			if (event.getEventType() == KeyEvent.KEY_RELEASED &amp;&amp; (code == KeyCode.BACK_SPACE || code == KeyCode.DELETE)) {</b>
<b class="nc"><i>2985</i>&nbsp;				if (getROIEditor().hasActiveHandle() || getROIEditor().isTranslating()) {</b>
<b class="nc"><i>2986</i>&nbsp;					logger.debug(&quot;Cannot delete object - ROI being edited&quot;);</b>
<b class="nc"><i>2987</i>&nbsp;					return;</b>
<i>2988</i>&nbsp;				}
<b class="nc"><i>2989</i>&nbsp;				var hierarchy = getHierarchy();</b>
<b class="nc"><i>2990</i>&nbsp;				if (hierarchy != null) {</b>
<b class="nc"><i>2991</i>&nbsp;					if (hierarchy.getSelectionModel().singleSelection()) {</b>
<b class="nc"><i>2992</i>&nbsp;						GuiTools.promptToRemoveSelectedObject(hierarchy.getSelectionModel().getSelectedObject(), hierarchy);</b>
<i>2993</i>&nbsp;					} else {
<b class="nc"><i>2994</i>&nbsp;						GuiTools.promptToClearAllSelectedObjects(getImageData());</b>
<i>2995</i>&nbsp;					}
<i>2996</i>&nbsp;//					setSelectedObject(null);
<i>2997</i>&nbsp;				}
<b class="nc"><i>2998</i>&nbsp;				event.consume();</b>
<b class="nc"><i>2999</i>&nbsp;				return;</b>
<i>3000</i>&nbsp;			}
<i>3001</i>&nbsp;
<b class="nc"><i>3002</i>&nbsp;			PathObjectHierarchy hierarchy = getHierarchy();</b>
<b class="nc"><i>3003</i>&nbsp;			if (hierarchy == null)</b>
<b class="nc"><i>3004</i>&nbsp;				return;</b>
<i>3005</i>&nbsp;
<i>3006</i>&nbsp;//			// Center selected object if Enter pressed (&#39;center on enter&#39;)
<i>3007</i>&nbsp;//			if (event.getEventType() == KeyEvent.KEY_RELEASED &amp;&amp; code == KeyCode.ENTER) {
<i>3008</i>&nbsp;//				PathObject selectedObject = getSelectedObject();
<i>3009</i>&nbsp;//				if (selectedObject != null &amp;&amp; selectedObject.hasROI())
<i>3010</i>&nbsp;//					setCenterPixelLocation(selectedObject.getROI().getCentroidX(), selectedObject.getROI().getCentroidY());
<i>3011</i>&nbsp;//				event.consume();
<i>3012</i>&nbsp;//				return;
<i>3013</i>&nbsp;//			}
<i>3014</i>&nbsp;
<i>3015</i>&nbsp;
<b class="nc"><i>3016</i>&nbsp;			if (!(code == KeyCode.LEFT || code == KeyCode.UP || code == KeyCode.RIGHT || code == KeyCode.DOWN))</b>
<b class="nc"><i>3017</i>&nbsp;				return;</b>
<i>3018</i>&nbsp;
<i>3019</i>&nbsp;			// Use arrow keys to navigate, either or directly or using a TMA grid
<b class="nc"><i>3020</i>&nbsp;			TMAGrid tmaGrid = hierarchy.getTMAGrid();</b>
<b class="nc"><i>3021</i>&nbsp;			List&lt;TMACoreObject&gt; cores = tmaGrid == null ? Collections.emptyList() : new ArrayList&lt;&gt;(tmaGrid.getTMACoreList());</b>
<b class="nc"><i>3022</i>&nbsp;			if (!event.isShiftDown() &amp;&amp; tmaGrid != null &amp;&amp; tmaGrid.nCores() &gt; 0) {</b>
<b class="nc"><i>3023</i>&nbsp;				if (event.getEventType() != KeyEvent.KEY_PRESSED)</b>
<b class="nc"><i>3024</i>&nbsp;					return;</b>
<b class="nc"><i>3025</i>&nbsp;				PathObject selected = hierarchy.getSelectionModel().getSelectedObject();</b>
<i>3026</i>&nbsp;				// Look up the hierarchy for a TMA core
<b class="nc"><i>3027</i>&nbsp;				while (selected != null &amp;&amp; !selected.isTMACore()) {</b>
<b class="nc"><i>3028</i>&nbsp;					selected = selected.getParent();</b>
<i>3029</i>&nbsp;				}
<b class="nc"><i>3030</i>&nbsp;				int ind = tmaGrid.getTMACoreList().indexOf(selected);</b>
<b class="nc"><i>3031</i>&nbsp;				int w = tmaGrid.getGridWidth();</b>
<b class="nc"><i>3032</i>&nbsp;				int h = tmaGrid.getGridHeight();</b>
<b class="nc"><i>3033</i>&nbsp;				if (ind &lt; 0) {</b>
<i>3034</i>&nbsp;					// Find the closest TMA core to the current position
<b class="nc"><i>3035</i>&nbsp;					double minDisplacementSq = Double.POSITIVE_INFINITY;</b>
<b class="nc"><i>3036</i>&nbsp;					int i = 0;</b>
<b class="nc"><i>3037</i>&nbsp;					for (TMACoreObject core : cores) {</b>
<b class="nc"><i>3038</i>&nbsp;						ROI coreROI = core.getROI();</b>
<b class="nc"><i>3039</i>&nbsp;						double dx = coreROI.getCentroidX() - getCenterPixelX();</b>
<b class="nc"><i>3040</i>&nbsp;						double dy = coreROI.getCentroidY() - getCenterPixelY();</b>
<b class="nc"><i>3041</i>&nbsp;						double displacementSq = dx*dx + dy*dy;</b>
<b class="nc"><i>3042</i>&nbsp;						if (displacementSq &lt; minDisplacementSq) {</b>
<b class="nc"><i>3043</i>&nbsp;							ind = i;</b>
<b class="nc"><i>3044</i>&nbsp;							minDisplacementSq = displacementSq;</b>
<i>3045</i>&nbsp;						}
<b class="nc"><i>3046</i>&nbsp;						i++;</b>
<b class="nc"><i>3047</i>&nbsp;					}</b>
<i>3048</i>&nbsp;				}
<i>3049</i>&nbsp;
<b class="nc"><i>3050</i>&nbsp;				switch (code) {</b>
<i>3051</i>&nbsp;				case LEFT:
<b class="nc"><i>3052</i>&nbsp;					if (ind &gt;= 0)</b>
<b class="nc"><i>3053</i>&nbsp;						ind--;</b>
<i>3054</i>&nbsp;					else
<b class="nc"><i>3055</i>&nbsp;						ind = 0;</b>
<b class="nc"><i>3056</i>&nbsp;					break;</b>
<i>3057</i>&nbsp;				case UP:
<b class="nc"><i>3058</i>&nbsp;					if (ind &gt;= 0)</b>
<b class="nc"><i>3059</i>&nbsp;						ind -= w;</b>
<i>3060</i>&nbsp;					else
<b class="nc"><i>3061</i>&nbsp;						ind = 0;</b>
<b class="nc"><i>3062</i>&nbsp;					break;</b>
<i>3063</i>&nbsp;				case RIGHT:
<b class="nc"><i>3064</i>&nbsp;					if (ind &gt;= 0)</b>
<b class="nc"><i>3065</i>&nbsp;						ind++;</b>
<i>3066</i>&nbsp;					else
<b class="nc"><i>3067</i>&nbsp;						ind = 0;</b>
<b class="nc"><i>3068</i>&nbsp;					break;</b>
<i>3069</i>&nbsp;				case DOWN:
<b class="nc"><i>3070</i>&nbsp;					if (ind &gt;= 0)</b>
<b class="nc"><i>3071</i>&nbsp;						ind += w;</b>
<i>3072</i>&nbsp;					else
<b class="nc"><i>3073</i>&nbsp;						ind = 0;</b>
<b class="nc"><i>3074</i>&nbsp;					break;</b>
<i>3075</i>&nbsp;				default:
<b class="nc"><i>3076</i>&nbsp;					return;</b>
<i>3077</i>&nbsp;				}
<i>3078</i>&nbsp;				// Set the selected object &amp; center the viewer
<b class="nc"><i>3079</i>&nbsp;				if (ind &gt;= 0 &amp;&amp; ind &lt; w*h) {</b>
<b class="nc"><i>3080</i>&nbsp;					PathObject selectedObject = cores.get(ind);</b>
<b class="nc"><i>3081</i>&nbsp;					hierarchy.getSelectionModel().setSelectedObject(selectedObject);</b>
<b class="nc"><i>3082</i>&nbsp;					if (selectedObject != null &amp;&amp; selectedObject.hasROI())</b>
<b class="nc"><i>3083</i>&nbsp;						centerROI(selectedObject.getROI());</b>
<i>3084</i>&nbsp;				}
<i>3085</i>&nbsp;				
<b class="nc"><i>3086</i>&nbsp;				event.consume();</b>
<i>3087</i>&nbsp;
<i>3088</i>&nbsp;				
<b class="nc"><i>3089</i>&nbsp;			} else if (event.getEventType() == KeyEvent.KEY_PRESSED) {</b>
<i>3090</i>&nbsp;
<i>3091</i>&nbsp;
<b class="nc"><i>3092</i>&nbsp;				if (event.isShiftDown()) {</b>
<b class="nc"><i>3093</i>&nbsp;					switch (code) {</b>
<i>3094</i>&nbsp;					case UP:
<b class="nc"><i>3095</i>&nbsp;						zoomIn(10);</b>
<b class="nc"><i>3096</i>&nbsp;						event.consume();</b>
<b class="nc"><i>3097</i>&nbsp;						return;</b>
<i>3098</i>&nbsp;					case DOWN:
<b class="nc"><i>3099</i>&nbsp;						zoomOut(10);</b>
<b class="nc"><i>3100</i>&nbsp;						event.consume();</b>
<b class="nc"><i>3101</i>&nbsp;						return;</b>
<i>3102</i>&nbsp;					default:
<i>3103</i>&nbsp;						break;
<i>3104</i>&nbsp;					}
<i>3105</i>&nbsp;				}
<i>3106</i>&nbsp;
<i>3107</i>&nbsp;
<b class="nc"><i>3108</i>&nbsp;				long currentTime = System.currentTimeMillis();</b>
<b class="nc"><i>3109</i>&nbsp;				if (keyDownTime == Long.MIN_VALUE)</b>
<b class="nc"><i>3110</i>&nbsp;					keyDownTime = currentTime;</b>
<i>3111</i>&nbsp;				// Take care of acceleration
<i>3112</i>&nbsp;				//				double dt = 0.1*currentTime - 0.1*keyDownTime;
<i>3113</i>&nbsp;				//				double scale = 5 * Math.pow(20 + dt, 0.5);
<i>3114</i>&nbsp;
<b class="nc"><i>3115</i>&nbsp;				scale = scale * 1.05;</b>
<b class="nc"><i>3116</i>&nbsp;				double d = getDownsampleFactor() * scale * 20;</b>
<b class="nc"><i>3117</i>&nbsp;				double dx = 0;</b>
<b class="nc"><i>3118</i>&nbsp;				double dy = 0;</b>
<b class="nc"><i>3119</i>&nbsp;				int nZSlices = hasServer() ? getServer().nZSlices() : 1;</b>
<b class="nc"><i>3120</i>&nbsp;				int nTimepoints = hasServer() ? getServer().nTimepoints() : 1;</b>
<b class="nc"><i>3121</i>&nbsp;				switch (code) {</b>
<i>3122</i>&nbsp;				case LEFT:
<b class="nc"><i>3123</i>&nbsp;					if (nTimepoints &gt; 1) {</b>
<b class="nc"><i>3124</i>&nbsp;						setTPosition(Math.max(nTimepoints-1, 0));</b>
<b class="nc"><i>3125</i>&nbsp;						event.consume();</b>
<b class="nc"><i>3126</i>&nbsp;						return;</b>
<i>3127</i>&nbsp;					}
<b class="nc"><i>3128</i>&nbsp;					dx = d;</b>
<b class="nc"><i>3129</i>&nbsp;					break;</b>
<i>3130</i>&nbsp;				case UP:
<b class="nc"><i>3131</i>&nbsp;					if (nZSlices &gt; 1) {</b>
<b class="nc"><i>3132</i>&nbsp;						setZPosition(Math.max(0, getZPosition() - 1));	</b>
<b class="nc"><i>3133</i>&nbsp;						event.consume();</b>
<b class="nc"><i>3134</i>&nbsp;						return;</b>
<i>3135</i>&nbsp;					}
<b class="nc"><i>3136</i>&nbsp;					dy = d;</b>
<b class="nc"><i>3137</i>&nbsp;					break;</b>
<i>3138</i>&nbsp;				case RIGHT:
<b class="nc"><i>3139</i>&nbsp;					if (nTimepoints &gt; 1) {</b>
<b class="nc"><i>3140</i>&nbsp;						setTPosition(Math.min(nTimepoints-1, getTPosition() + 1));						</b>
<b class="nc"><i>3141</i>&nbsp;						event.consume();</b>
<b class="nc"><i>3142</i>&nbsp;						return;</b>
<i>3143</i>&nbsp;					}
<b class="nc"><i>3144</i>&nbsp;					dx = -d;</b>
<b class="nc"><i>3145</i>&nbsp;					break;</b>
<i>3146</i>&nbsp;				case DOWN:
<b class="nc"><i>3147</i>&nbsp;					if (nZSlices &gt; 1) {</b>
<b class="nc"><i>3148</i>&nbsp;						setZPosition(Math.min(nZSlices-1, getZPosition() + 1));						</b>
<b class="nc"><i>3149</i>&nbsp;						event.consume();</b>
<b class="nc"><i>3150</i>&nbsp;						return;</b>
<i>3151</i>&nbsp;					}
<b class="nc"><i>3152</i>&nbsp;					dy = -d;</b>
<b class="nc"><i>3153</i>&nbsp;					break;</b>
<i>3154</i>&nbsp;				default:
<b class="nc"><i>3155</i>&nbsp;					return;</b>
<i>3156</i>&nbsp;				}
<i>3157</i>&nbsp;
<b class="nc"><i>3158</i>&nbsp;				requestStartMoving(dx, dy);</b>
<b class="nc"><i>3159</i>&nbsp;				event.consume();</b>
<i>3160</i>&nbsp;
<i>3161</i>&nbsp;
<b class="nc"><i>3162</i>&nbsp;			} else if (event.getEventType() == KeyEvent.KEY_RELEASED) {</b>
<b class="nc"><i>3163</i>&nbsp;				switch (code) {</b>
<i>3164</i>&nbsp;				case LEFT:
<i>3165</i>&nbsp;				case UP:
<i>3166</i>&nbsp;				case RIGHT:
<i>3167</i>&nbsp;				case DOWN:
<b class="nc"><i>3168</i>&nbsp;					mover.decelerate();</b>
<b class="nc"><i>3169</i>&nbsp;					setDoFasterRepaint(false);</b>
<b class="nc"><i>3170</i>&nbsp;					keyDownTime = Long.MIN_VALUE;</b>
<b class="nc"><i>3171</i>&nbsp;					scale = 1;</b>
<b class="nc"><i>3172</i>&nbsp;					event.consume();</b>
<b class="nc"><i>3173</i>&nbsp;					break;</b>
<i>3174</i>&nbsp;				default:
<b class="nc"><i>3175</i>&nbsp;					return;</b>
<i>3176</i>&nbsp;				}	
<i>3177</i>&nbsp;			}
<b class="nc"><i>3178</i>&nbsp;		}</b>
<i>3179</i>&nbsp;	}
<i>3180</i>&nbsp;	
<i>3181</i>&nbsp;	
<b class="fc"><i>3182</i>&nbsp;	private MoveTool.ViewerMover mover = new MoveTool.ViewerMover(this);</b>
<i>3183</i>&nbsp;	
<i>3184</i>&nbsp;	
<i>3185</i>&nbsp;	/**
<i>3186</i>&nbsp;	 * Request that the viewer stop any panning immediately.
<i>3187</i>&nbsp;	 * 
<i>3188</i>&nbsp;	 * @see #requestDecelerate
<i>3189</i>&nbsp;	 * @see #requestStartMoving
<i>3190</i>&nbsp;	 */
<i>3191</i>&nbsp;	public void requestStopMoving() {
<b class="nc"><i>3192</i>&nbsp;		mover.stopMoving();</b>
<b class="nc"><i>3193</i>&nbsp;	}</b>
<i>3194</i>&nbsp;	
<i>3195</i>&nbsp;	/**
<i>3196</i>&nbsp;	 * Request that a viewer decelerate any existing panning smoothly.
<i>3197</i>&nbsp;	 * 
<i>3198</i>&nbsp;	 * @see #requestStartMoving
<i>3199</i>&nbsp;	 * @see #requestStopMoving
<i>3200</i>&nbsp;	 */
<i>3201</i>&nbsp;	public void requestDecelerate() {
<b class="nc"><i>3202</i>&nbsp;		mover.decelerate();</b>
<b class="nc"><i>3203</i>&nbsp;	}</b>
<i>3204</i>&nbsp;	
<i>3205</i>&nbsp;	/**
<i>3206</i>&nbsp;	 * Request that the viewer start panning with a velocity determined by dx and dy.
<i>3207</i>&nbsp;	 * 
<i>3208</i>&nbsp;	 * &lt;p&gt;This can be used in combination with {@code requestDecelerate} to end a panning event more smoothly.
<i>3209</i>&nbsp;	 * 
<i>3210</i>&nbsp;	 * @param dx
<i>3211</i>&nbsp;	 * @param dy
<i>3212</i>&nbsp;	 * 
<i>3213</i>&nbsp;	 * @see #requestDecelerate
<i>3214</i>&nbsp;	 * @see #requestStopMoving
<i>3215</i>&nbsp;	 */
<i>3216</i>&nbsp;	public void requestStartMoving(final double dx, final double dy) {
<b class="nc"><i>3217</i>&nbsp;		mover.startMoving(dx, dy, true);</b>
<b class="nc"><i>3218</i>&nbsp;		this.setDoFasterRepaint(true);</b>
<b class="nc"><i>3219</i>&nbsp;	}</b>
<i>3220</i>&nbsp;
<i>3221</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2021-01-25 09:46</div>
</div>
</body>
</html>
