


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: OverlayOptions</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">qupath.lib.gui.viewer</a> ]
</div>

<h1>Coverage Summary for Class: OverlayOptions (qupath.lib.gui.viewer)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">OverlayOptions</td>
<td class="coverageStat">
  <span class="percent">
    47.4%
  </span>
  <span class="absValue">
    (27/ 57)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.5%
  </span>
  <span class="absValue">
    (61/ 134)
  </span>
</td>
</tr>
  <tr>
    <td class="name">OverlayOptions$DetectionDisplayMode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/ 5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    49.2%
  </span>
  <span class="absValue">
    (29/ 59)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    47.5%
  </span>
  <span class="absValue">
    (66/ 139)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*-
<i>2</i>&nbsp; * #%L
<i>3</i>&nbsp; * This file is part of QuPath.
<i>4</i>&nbsp; * %%
<i>5</i>&nbsp; * Copyright (C) 2014 - 2016 The Queen&#39;s University of Belfast, Northern Ireland
<i>6</i>&nbsp; * Contact: IP Management (ipmanagement@qub.ac.uk)
<i>7</i>&nbsp; * Copyright (C) 2018 - 2020 QuPath developers, The University of Edinburgh
<i>8</i>&nbsp; * %%
<i>9</i>&nbsp; * QuPath is free software: you can redistribute it and/or modify
<i>10</i>&nbsp; * it under the terms of the GNU General Public License as
<i>11</i>&nbsp; * published by the Free Software Foundation, either version 3 of the
<i>12</i>&nbsp; * License, or (at your option) any later version.
<i>13</i>&nbsp; * 
<i>14</i>&nbsp; * QuPath is distributed in the hope that it will be useful,
<i>15</i>&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
<i>16</i>&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<i>17</i>&nbsp; * GNU General Public License for more details.
<i>18</i>&nbsp; * 
<i>19</i>&nbsp; * You should have received a copy of the GNU General Public License 
<i>20</i>&nbsp; * along with QuPath.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
<i>21</i>&nbsp; * #L%
<i>22</i>&nbsp; */
<i>23</i>&nbsp;
<i>24</i>&nbsp;package qupath.lib.gui.viewer;
<i>25</i>&nbsp;
<i>26</i>&nbsp;import javafx.beans.InvalidationListener;
<i>27</i>&nbsp;import javafx.beans.property.BooleanProperty;
<i>28</i>&nbsp;import javafx.beans.property.FloatProperty;
<i>29</i>&nbsp;import javafx.beans.property.LongProperty;
<i>30</i>&nbsp;import javafx.beans.property.ObjectProperty;
<i>31</i>&nbsp;import javafx.beans.property.ReadOnlyLongProperty;
<i>32</i>&nbsp;import javafx.beans.property.SimpleBooleanProperty;
<i>33</i>&nbsp;import javafx.beans.property.SimpleFloatProperty;
<i>34</i>&nbsp;import javafx.beans.property.SimpleLongProperty;
<i>35</i>&nbsp;import javafx.beans.property.SimpleObjectProperty;
<i>36</i>&nbsp;import javafx.collections.FXCollections;
<i>37</i>&nbsp;import javafx.collections.ObservableSet;
<i>38</i>&nbsp;import qupath.lib.gui.prefs.PathPrefs;
<i>39</i>&nbsp;import qupath.lib.gui.tools.MeasurementMapper;
<i>40</i>&nbsp;import qupath.lib.objects.classes.PathClass;
<i>41</i>&nbsp;import qupath.lib.objects.classes.PathClassFactory;
<i>42</i>&nbsp;import qupath.lib.objects.classes.PathClassTools;
<i>43</i>&nbsp;
<i>44</i>&nbsp;/**
<i>45</i>&nbsp; * Default class for storing overlay display options.
<i>46</i>&nbsp; * 
<i>47</i>&nbsp; * @author Pete Bankhead
<i>48</i>&nbsp; * 
<i>49</i>&nbsp; */
<i>50</i>&nbsp;public class OverlayOptions {
<i>51</i>&nbsp;	
<i>52</i>&nbsp;	/**
<i>53</i>&nbsp;	 * Display modes for cells and other detections.
<i>54</i>&nbsp;	 */
<b class="fc"><i>55</i>&nbsp;	public enum DetectionDisplayMode {</b>
<i>56</i>&nbsp;		/**
<i>57</i>&nbsp;		 * Show only cell boundaries.
<i>58</i>&nbsp;		 */
<b class="fc"><i>59</i>&nbsp;		BOUNDARIES_ONLY,</b>
<i>60</i>&nbsp;		/**
<i>61</i>&nbsp;		 * Show only cell nuclei.
<i>62</i>&nbsp;		 */
<b class="fc"><i>63</i>&nbsp;		NUCLEI_ONLY,</b>
<i>64</i>&nbsp;		/**
<i>65</i>&nbsp;		 * Show both cell boundaries and cell nuclei, where available.
<i>66</i>&nbsp;		 */
<b class="fc"><i>67</i>&nbsp;		NUCLEI_AND_BOUNDARIES,</b>
<i>68</i>&nbsp;		/**
<i>69</i>&nbsp;		 * Show only detection centroids, not boundaries.
<i>70</i>&nbsp;		 */
<b class="fc"><i>71</i>&nbsp;		CENTROIDS</b>
<i>72</i>&nbsp;		};
<i>73</i>&nbsp;	
<b class="fc"><i>74</i>&nbsp;	private ObjectProperty&lt;MeasurementMapper&gt; measurementMapper = new SimpleObjectProperty&lt;&gt;();</b>
<b class="fc"><i>75</i>&nbsp;	private BooleanProperty showAnnotations = new SimpleBooleanProperty(true);</b>
<b class="fc"><i>76</i>&nbsp;	private BooleanProperty showNames = new SimpleBooleanProperty(true);</b>
<b class="fc"><i>77</i>&nbsp;	private BooleanProperty showTMAGrid = new SimpleBooleanProperty(true);</b>
<b class="fc"><i>78</i>&nbsp;	private BooleanProperty showDetections = new SimpleBooleanProperty(true);</b>
<b class="fc"><i>79</i>&nbsp;	private BooleanProperty showConnections = new SimpleBooleanProperty(true);</b>
<b class="fc"><i>80</i>&nbsp;	private BooleanProperty fillDetections = new SimpleBooleanProperty(false);</b>
<b class="fc"><i>81</i>&nbsp;	private BooleanProperty fillAnnotations = new SimpleBooleanProperty(false);</b>
<b class="fc"><i>82</i>&nbsp;	private BooleanProperty showTMACoreLabels = new SimpleBooleanProperty(false);</b>
<b class="fc"><i>83</i>&nbsp;	private BooleanProperty showGrid = new SimpleBooleanProperty(false);</b>
<b class="fc"><i>84</i>&nbsp;	private ObjectProperty&lt;GridLines&gt; gridLines = new SimpleObjectProperty&lt;&gt;(new GridLines());</b>
<i>85</i>&nbsp;
<b class="fc"><i>86</i>&nbsp;	private BooleanProperty showPixelClassification = new SimpleBooleanProperty(true);</b>
<b class="fc"><i>87</i>&nbsp;	private ObjectProperty&lt;RegionFilter&gt; pixelClassificationFilter = new SimpleObjectProperty&lt;&gt;(RegionFilter.StandardRegionFilters.EVERYWHERE);</b>
<i>88</i>&nbsp;
<b class="fc"><i>89</i>&nbsp;	private ObservableSet&lt;PathClass&gt; hiddenClasses = FXCollections.observableSet();</b>
<i>90</i>&nbsp;
<b class="fc"><i>91</i>&nbsp;	private ObjectProperty&lt;DetectionDisplayMode&gt; cellDisplayMode = new SimpleObjectProperty&lt;&gt;(DetectionDisplayMode.NUCLEI_AND_BOUNDARIES);</b>
<i>92</i>&nbsp;
<b class="fc"><i>93</i>&nbsp;	private FloatProperty opacity = new SimpleFloatProperty(1.0f);</b>
<i>94</i>&nbsp;	
<b class="fc"><i>95</i>&nbsp;	private LongProperty timestamp = new SimpleLongProperty(System.currentTimeMillis());</b>
<i>96</i>&nbsp;	
<i>97</i>&nbsp;//    public void addPropertyChangeListener(PropertyChangeListener listener) {
<i>98</i>&nbsp;//        this.pcs.addPropertyChangeListener(listener);
<i>99</i>&nbsp;//    }
<i>100</i>&nbsp;//
<i>101</i>&nbsp;//    public void removePropertyChangeListener(PropertyChangeListener listener) {
<i>102</i>&nbsp;//        this.pcs.removePropertyChangeListener(listener);
<i>103</i>&nbsp;//    }
<i>104</i>&nbsp;    
<i>105</i>&nbsp;	/**
<i>106</i>&nbsp;	 * Constructor, using default values.
<i>107</i>&nbsp;	 */
<b class="fc"><i>108</i>&nbsp;	public OverlayOptions() {</b>
<b class="fc"><i>109</i>&nbsp;		InvalidationListener timestamper = (var e) -&gt; updateTimestamp();</b>
<b class="fc"><i>110</i>&nbsp;		showAnnotations.addListener(timestamper);</b>
<b class="fc"><i>111</i>&nbsp;		showNames.addListener(timestamper);</b>
<b class="fc"><i>112</i>&nbsp;		showTMAGrid.addListener(timestamper);</b>
<b class="fc"><i>113</i>&nbsp;		showPixelClassification.addListener(timestamper);</b>
<b class="fc"><i>114</i>&nbsp;		showDetections.addListener(timestamper);</b>
<b class="fc"><i>115</i>&nbsp;		showConnections.addListener(timestamper);</b>
<b class="fc"><i>116</i>&nbsp;		fillDetections.addListener(timestamper);</b>
<b class="fc"><i>117</i>&nbsp;		fillAnnotations.addListener(timestamper);</b>
<b class="fc"><i>118</i>&nbsp;		showTMACoreLabels.addListener(timestamper);</b>
<b class="fc"><i>119</i>&nbsp;		showGrid.addListener(timestamper);</b>
<b class="fc"><i>120</i>&nbsp;		gridLines.addListener(timestamper);</b>
<b class="fc"><i>121</i>&nbsp;		hiddenClasses.addListener(timestamper);</b>
<b class="fc"><i>122</i>&nbsp;		cellDisplayMode.addListener(timestamper);</b>
<b class="fc"><i>123</i>&nbsp;		opacity.addListener(timestamper);</b>
<b class="fc"><i>124</i>&nbsp;	}</b>
<i>125</i>&nbsp;	
<i>126</i>&nbsp;	/**
<i>127</i>&nbsp;	 * Constructor, initializing values based on an existing {@link OverlayOptions} object.
<i>128</i>&nbsp;	 * @param options 
<i>129</i>&nbsp;	 */
<i>130</i>&nbsp;	public OverlayOptions(OverlayOptions options) {
<b class="nc"><i>131</i>&nbsp;		this();</b>
<b class="nc"><i>132</i>&nbsp;		this.cellDisplayMode.set(options.cellDisplayMode.get());</b>
<b class="nc"><i>133</i>&nbsp;		this.fillAnnotations.set(options.fillAnnotations.get());</b>
<b class="nc"><i>134</i>&nbsp;		this.fillDetections.set(options.fillDetections.get());</b>
<b class="nc"><i>135</i>&nbsp;		this.gridLines.set(options.gridLines.get());</b>
<b class="nc"><i>136</i>&nbsp;		this.hiddenClasses.addAll(options.hiddenClasses);</b>
<b class="nc"><i>137</i>&nbsp;		this.measurementMapper.set(options.measurementMapper.get());</b>
<b class="nc"><i>138</i>&nbsp;		this.opacity.set(options.opacity.get());</b>
<b class="nc"><i>139</i>&nbsp;		this.showAnnotations.set(options.showAnnotations.get());</b>
<b class="nc"><i>140</i>&nbsp;		this.showNames.set(options.showNames.get());</b>
<b class="nc"><i>141</i>&nbsp;		this.showConnections.set(options.showConnections.get());</b>
<b class="nc"><i>142</i>&nbsp;		this.showDetections.set(options.showDetections.get());</b>
<b class="nc"><i>143</i>&nbsp;		this.showGrid.set(options.showGrid.get());</b>
<b class="nc"><i>144</i>&nbsp;		this.showPixelClassification.set(options.showPixelClassification.get());</b>
<b class="nc"><i>145</i>&nbsp;		this.showTMACoreLabels.set(options.showTMACoreLabels.get());</b>
<b class="nc"><i>146</i>&nbsp;		this.showTMAGrid.set(options.showTMAGrid.get());</b>
<b class="nc"><i>147</i>&nbsp;		this.pixelClassificationFilter.set(options.pixelClassificationFilter.get());</b>
<b class="nc"><i>148</i>&nbsp;		this.timestamp.set(options.timestamp.get());</b>
<b class="nc"><i>149</i>&nbsp;	}</b>
<i>150</i>&nbsp;	
<i>151</i>&nbsp;	private void updateTimestamp() {
<b class="nc"><i>152</i>&nbsp;		this.timestamp.set(System.currentTimeMillis());</b>
<b class="nc"><i>153</i>&nbsp;	}</b>
<i>154</i>&nbsp;	
<i>155</i>&nbsp;	/**
<i>156</i>&nbsp;	 * Get a property representing the timestamp of the last recorded change for any property.
<i>157</i>&nbsp;	 * @return
<i>158</i>&nbsp;	 */
<i>159</i>&nbsp;	public ReadOnlyLongProperty lastChangeTimestamp() {
<b class="fc"><i>160</i>&nbsp;		return timestamp;</b>
<i>161</i>&nbsp;	}
<i>162</i>&nbsp;    
<i>163</i>&nbsp;	/**
<i>164</i>&nbsp;	 * Set global opacity for overlay drawing.
<i>165</i>&nbsp;	 * Individual overlays may have their own opacity settings, but these should be concatenated with the global opacity.
<i>166</i>&nbsp;	 * @param opacity opacity value between 0 (completely transparent) and 1 (completely opaque).
<i>167</i>&nbsp;	 */
<i>168</i>&nbsp;    public void setOpacity(float opacity) {
<b class="nc"><i>169</i>&nbsp;    	opacity = opacity &lt; 0 ? 0 : (opacity &gt; 1 ? 1 : opacity);</b>
<b class="nc"><i>170</i>&nbsp;    	this.opacity.set(opacity);</b>
<b class="nc"><i>171</i>&nbsp;    }</b>
<i>172</i>&nbsp;    
<i>173</i>&nbsp;    /**
<i>174</i>&nbsp;     * Get the global opacity for overlay drawing.
<i>175</i>&nbsp;     * @return opacity value between 0 (completely transparent) and 1 (completely opaque).
<i>176</i>&nbsp;     */
<i>177</i>&nbsp;    public float getOpacity() {
<b class="fc"><i>178</i>&nbsp;    	return opacity.get();</b>
<i>179</i>&nbsp;    }
<i>180</i>&nbsp;    
<i>181</i>&nbsp;    /**
<i>182</i>&nbsp;	 * Property representing the global opacity for overlay drawing.
<i>183</i>&nbsp;     * @return opacity property, which should accept values between 0 and 1.
<i>184</i>&nbsp;	 */
<i>185</i>&nbsp;    public FloatProperty opacityProperty() {
<b class="fc"><i>186</i>&nbsp;    	return opacity;</b>
<i>187</i>&nbsp;    }
<i>188</i>&nbsp;    
<i>189</i>&nbsp;    /**
<i>190</i>&nbsp;     * Get the current {@link DetectionDisplayMode}.
<i>191</i>&nbsp;     * @return the current display mode
<i>192</i>&nbsp;     */
<i>193</i>&nbsp;    public DetectionDisplayMode getDetectionDisplayMode() {
<b class="nc"><i>194</i>&nbsp;    	return cellDisplayMode.get();</b>
<i>195</i>&nbsp;    }
<i>196</i>&nbsp;    
<i>197</i>&nbsp;    /**
<i>198</i>&nbsp;     * Query the current {@link DetectionDisplayMode} to see if nuclei ROIs should be drawn.
<i>199</i>&nbsp;     * @return true if nuclei should be drawn, false otherwise
<i>200</i>&nbsp;     */
<i>201</i>&nbsp;    public boolean getShowCellNuclei() {
<b class="nc"><i>202</i>&nbsp;    	return cellDisplayMode.get() == DetectionDisplayMode.NUCLEI_AND_BOUNDARIES || cellDisplayMode.get() == DetectionDisplayMode.NUCLEI_ONLY;</b>
<i>203</i>&nbsp;    }
<i>204</i>&nbsp;
<i>205</i>&nbsp;    /**
<i>206</i>&nbsp;     * Query the current {@link DetectionDisplayMode} to see if cell boundary ROIs should be drawn.
<i>207</i>&nbsp;     * @return true if nuclei should be drawn, false otherwise
<i>208</i>&nbsp;     */
<i>209</i>&nbsp;    public boolean getShowCellBoundaries() {
<b class="nc"><i>210</i>&nbsp;    	return cellDisplayMode.get() == DetectionDisplayMode.NUCLEI_AND_BOUNDARIES || cellDisplayMode.get() == DetectionDisplayMode.BOUNDARIES_ONLY;</b>
<i>211</i>&nbsp;    }
<i>212</i>&nbsp;    
<i>213</i>&nbsp;    
<i>214</i>&nbsp;    /**
<i>215</i>&nbsp;     * Set the current {@link DetectionDisplayMode}.
<i>216</i>&nbsp;     * @param mode the requested mode to set
<i>217</i>&nbsp;     */
<i>218</i>&nbsp;    public void setDetectionDisplayMode(DetectionDisplayMode mode) {
<b class="nc"><i>219</i>&nbsp;    	this.cellDisplayMode.set(mode);</b>
<b class="nc"><i>220</i>&nbsp;    }</b>
<i>221</i>&nbsp;    
<i>222</i>&nbsp;    /**
<i>223</i>&nbsp;     * Property representing the current {@link DetectionDisplayMode}.
<i>224</i>&nbsp;     * @return
<i>225</i>&nbsp;     */
<i>226</i>&nbsp;    public ObjectProperty&lt;DetectionDisplayMode&gt; detectionDisplayModeProperty() {
<b class="fc"><i>227</i>&nbsp;    	return cellDisplayMode;</b>
<i>228</i>&nbsp;    }
<i>229</i>&nbsp;    
<i>230</i>&nbsp;    /**
<i>231</i>&nbsp;     * Get the requested stroke thickness to use when drawing ROIs that should be represented with &#39;thick&#39; lines (annotations, TMA cores).
<i>232</i>&nbsp;     * 
<i>233</i>&nbsp;     * @param downsample downsample at which the annotations should be drawn
<i>234</i>&nbsp;     * @return preferred stroke thickness to use
<i>235</i>&nbsp;     */
<i>236</i>&nbsp;    public float getThickStrokeWidth(double downsample) {
<b class="nc"><i>237</i>&nbsp;    	return (float)(PathPrefs.annotationStrokeThicknessProperty().get() * Math.max(1, downsample));</b>
<i>238</i>&nbsp;    }
<i>239</i>&nbsp;    
<i>240</i>&nbsp;    
<i>241</i>&nbsp;    
<i>242</i>&nbsp;    /**
<i>243</i>&nbsp;	 * Show the TMA grid on the image, if present.
<i>244</i>&nbsp;	 * 
<i>245</i>&nbsp;	 * @param show
<i>246</i>&nbsp;	 */
<i>247</i>&nbsp;	public void setShowTMAGrid(boolean show) {
<b class="nc"><i>248</i>&nbsp;		this.showTMAGrid.set(show);</b>
<b class="nc"><i>249</i>&nbsp;	}</b>
<i>250</i>&nbsp;	
<i>251</i>&nbsp;	/**
<i>252</i>&nbsp;	 * Show the annotations on the image.
<i>253</i>&nbsp;	 * 
<i>254</i>&nbsp;	 * @param show
<i>255</i>&nbsp;	 */
<i>256</i>&nbsp;	public void setShowAnnotations(boolean show) {
<b class="nc"><i>257</i>&nbsp;		this.showAnnotations.set(show);</b>
<b class="nc"><i>258</i>&nbsp;	}</b>
<i>259</i>&nbsp;	
<i>260</i>&nbsp;	/**
<i>261</i>&nbsp;	 * Show the object names on the image.
<i>262</i>&nbsp;	 * 
<i>263</i>&nbsp;	 * @param show
<i>264</i>&nbsp;	 */
<i>265</i>&nbsp;	public void setShowNames(boolean show) {
<b class="nc"><i>266</i>&nbsp;		this.showNames.set(show);</b>
<b class="nc"><i>267</i>&nbsp;	}</b>
<i>268</i>&nbsp;	
<i>269</i>&nbsp;	/**
<i>270</i>&nbsp;	 * Show the objects as an overlay on the image.
<i>271</i>&nbsp;	 * 
<i>272</i>&nbsp;	 * @param show
<i>273</i>&nbsp;	 */
<i>274</i>&nbsp;	public void setShowDetections(boolean show) {
<b class="nc"><i>275</i>&nbsp;		this.showDetections.set(show);</b>
<b class="nc"><i>276</i>&nbsp;	}</b>
<i>277</i>&nbsp;	
<i>278</i>&nbsp;	/**
<i>279</i>&nbsp;	 * Show pixel classification overlays.
<i>280</i>&nbsp;	 * 
<i>281</i>&nbsp;	 * @param show
<i>282</i>&nbsp;	 */
<i>283</i>&nbsp;	public void setShowPixelClassification(boolean show) {
<b class="nc"><i>284</i>&nbsp;		this.showPixelClassification.set(show);</b>
<b class="nc"><i>285</i>&nbsp;	}</b>
<i>286</i>&nbsp;	
<i>287</i>&nbsp;	/**
<i>288</i>&nbsp;	 * Show detection objects &#39;filled&#39; in viewers.
<i>289</i>&nbsp;	 * 
<i>290</i>&nbsp;	 * @param fill
<i>291</i>&nbsp;	 */
<i>292</i>&nbsp;	public void setFillDetections(boolean fill) {
<b class="nc"><i>293</i>&nbsp;		this.fillDetections.set(fill);</b>
<b class="nc"><i>294</i>&nbsp;	}</b>
<i>295</i>&nbsp;	
<i>296</i>&nbsp;	/**
<i>297</i>&nbsp;	 * Show annotation objects &#39;filled&#39; in viewers.
<i>298</i>&nbsp;	 * 
<i>299</i>&nbsp;	 * @param fill
<i>300</i>&nbsp;	 */
<i>301</i>&nbsp;	public void setFillAnnotations(boolean fill) {
<b class="nc"><i>302</i>&nbsp;		fillAnnotations.set(fill);</b>
<b class="nc"><i>303</i>&nbsp;	}</b>
<i>304</i>&nbsp;	
<i>305</i>&nbsp;	/**
<i>306</i>&nbsp;	 * Show connections between objects, if available.
<i>307</i>&nbsp;	 * 
<i>308</i>&nbsp;	 * @param show
<i>309</i>&nbsp;	 */
<i>310</i>&nbsp;	public void setShowConnections(boolean show) {
<b class="nc"><i>311</i>&nbsp;		showConnections.set(show);</b>
<b class="nc"><i>312</i>&nbsp;	}</b>
<i>313</i>&nbsp;	
<i>314</i>&nbsp;	/**
<i>315</i>&nbsp;	 * Show TMA core names on top of the image.
<i>316</i>&nbsp;	 * 
<i>317</i>&nbsp;	 * @param showTMALabels
<i>318</i>&nbsp;	 */
<i>319</i>&nbsp;	public void setShowTMACoreLabels(boolean showTMALabels) {
<b class="nc"><i>320</i>&nbsp;		showTMACoreLabels.set(showTMALabels);</b>
<b class="nc"><i>321</i>&nbsp;	}</b>
<i>322</i>&nbsp;	
<i>323</i>&nbsp;	/**
<i>324</i>&nbsp;	 * @return true if TMA core labels should be shown in viewers, false otherwise
<i>325</i>&nbsp;	 */
<i>326</i>&nbsp;	public boolean getShowTMACoreLabels() {
<b class="nc"><i>327</i>&nbsp;		return showTMACoreLabels.get();</b>
<i>328</i>&nbsp;	}
<i>329</i>&nbsp;	
<i>330</i>&nbsp;	/**
<i>331</i>&nbsp;	 * @return boolean property indicating whether TMA core labels should be shown in the viewer
<i>332</i>&nbsp;	 */
<i>333</i>&nbsp;	public BooleanProperty showTMACoreLabelsProperty() {
<b class="fc"><i>334</i>&nbsp;		return showTMACoreLabels;</b>
<i>335</i>&nbsp;	}
<i>336</i>&nbsp;	
<i>337</i>&nbsp;	/**
<i>338</i>&nbsp;	 * @return boolean property indicating whether collections between objects should be shown (e.g. after Delaunay triangulation)
<i>339</i>&nbsp;	 */
<i>340</i>&nbsp;	public BooleanProperty showConnectionsProperty() {
<b class="fc"><i>341</i>&nbsp;		return showConnections;</b>
<i>342</i>&nbsp;	}
<i>343</i>&nbsp;	
<i>344</i>&nbsp;	/**
<i>345</i>&nbsp;	 * @return true if the current active pixel classification should be shown, false otherwise
<i>346</i>&nbsp;	 */
<i>347</i>&nbsp;	public boolean getShowPixelClassification() {
<b class="fc"><i>348</i>&nbsp;		return showPixelClassification.get();</b>
<i>349</i>&nbsp;	}
<i>350</i>&nbsp;
<i>351</i>&nbsp;	/**
<i>352</i>&nbsp;	 * @return true if annotations should be displayed in viewers, false otherwise
<i>353</i>&nbsp;	 */
<i>354</i>&nbsp;	public boolean getShowAnnotations() {
<b class="fc"><i>355</i>&nbsp;		return showAnnotations.get();</b>
<i>356</i>&nbsp;	}
<i>357</i>&nbsp;	
<i>358</i>&nbsp;	/**
<i>359</i>&nbsp;	 * @return true if annotation names should be displayed in viewers, false otherwise
<i>360</i>&nbsp;	 */
<i>361</i>&nbsp;	public boolean getShowNames() {
<b class="fc"><i>362</i>&nbsp;		return showNames.get();</b>
<i>363</i>&nbsp;	}
<i>364</i>&nbsp;	
<i>365</i>&nbsp;	/**
<i>366</i>&nbsp;	 * @return true if any TMA grids should be displayed in viewers, false otherwise
<i>367</i>&nbsp;	 */
<i>368</i>&nbsp;	public boolean getShowTMAGrid() {
<b class="fc"><i>369</i>&nbsp;		return showTMAGrid.get();</b>
<i>370</i>&nbsp;	}
<i>371</i>&nbsp;	
<i>372</i>&nbsp;	/**
<i>373</i>&nbsp;	 * @return true if detections should be displayed in viewers, false otherwise
<i>374</i>&nbsp;	 */
<i>375</i>&nbsp;	public boolean getShowDetections() {
<b class="fc"><i>376</i>&nbsp;		return showDetections.get();</b>
<i>377</i>&nbsp;	}
<i>378</i>&nbsp;	
<i>379</i>&nbsp;	/**
<i>380</i>&nbsp;	 * @return true if any calculated connections between objects should be displayed in viewers, false otherwise
<i>381</i>&nbsp;	 */
<i>382</i>&nbsp;	public boolean getShowConnections() {
<b class="nc"><i>383</i>&nbsp;		return showConnections.get();</b>
<i>384</i>&nbsp;	}
<i>385</i>&nbsp;	
<i>386</i>&nbsp;	/**
<i>387</i>&nbsp;	 * @return true if detections should be displayed &#39;filled&#39; in viewers, false otherwise
<i>388</i>&nbsp;	 */
<i>389</i>&nbsp;	public boolean getFillDetections() {
<b class="fc"><i>390</i>&nbsp;		return fillDetections.get();</b>
<i>391</i>&nbsp;	}
<i>392</i>&nbsp;	
<i>393</i>&nbsp;	/**
<i>394</i>&nbsp;	 * @return true if annotations should be displayed &#39;filled&#39; in viewers, false otherwise
<i>395</i>&nbsp;	 */
<i>396</i>&nbsp;	public boolean getFillAnnotations() {
<b class="nc"><i>397</i>&nbsp;		return fillAnnotations.get();</b>
<i>398</i>&nbsp;	}
<i>399</i>&nbsp;	
<i>400</i>&nbsp;	/**
<i>401</i>&nbsp;	 * Set whether a counting grid should be shown in viewers
<i>402</i>&nbsp;	 * @param showGrid
<i>403</i>&nbsp;	 * @see #setGridLines(GridLines)
<i>404</i>&nbsp;	 */
<i>405</i>&nbsp;	public void setShowGrid(boolean showGrid) {
<b class="nc"><i>406</i>&nbsp;		this.showGrid.set(showGrid);</b>
<b class="nc"><i>407</i>&nbsp;	}</b>
<i>408</i>&nbsp;	
<i>409</i>&nbsp;	/**
<i>410</i>&nbsp;	 * @return true if a counting grid should be displayed in viewers, false otherwise
<i>411</i>&nbsp;	 * @see #getGridLines()
<i>412</i>&nbsp;	 */
<i>413</i>&nbsp;	public boolean getShowGrid() {
<b class="fc"><i>414</i>&nbsp;		return showGrid.get();</b>
<i>415</i>&nbsp;	}
<i>416</i>&nbsp;
<i>417</i>&nbsp;	/**
<i>418</i>&nbsp;	 * @return the {@link GridLines} object that defines how a counting grid may be show in viewers
<i>419</i>&nbsp;	 * @see #getShowGrid()
<i>420</i>&nbsp;	 */
<i>421</i>&nbsp;	public GridLines getGridLines() {
<b class="nc"><i>422</i>&nbsp;		return gridLines.get();</b>
<i>423</i>&nbsp;	}
<i>424</i>&nbsp;	
<i>425</i>&nbsp;	/**
<i>426</i>&nbsp;	 * Set the {@link GridLines} object that defines how a counting grid may be show in viewers
<i>427</i>&nbsp;	 * @param gridLines
<i>428</i>&nbsp;	 */
<i>429</i>&nbsp;	public void setGridLines(final GridLines gridLines) {
<b class="nc"><i>430</i>&nbsp;		this.gridLines.set(gridLines);</b>
<b class="nc"><i>431</i>&nbsp;	}</b>
<i>432</i>&nbsp;	
<i>433</i>&nbsp;	/**
<i>434</i>&nbsp;	 * @return an object property containing a {@link GridLines} object that defines how a counting grid may be show in viewers
<i>435</i>&nbsp;	 * @see #getShowGrid()
<i>436</i>&nbsp;	 */
<i>437</i>&nbsp;	public ObjectProperty&lt;GridLines&gt; gridLinesProperty() {
<b class="fc"><i>438</i>&nbsp;		return gridLines;</b>
<i>439</i>&nbsp;	}
<i>440</i>&nbsp;
<i>441</i>&nbsp;	/**
<i>442</i>&nbsp;	 * Set the {@link MeasurementMapper} that defines how detections should be color coded according to their measurement values in viewers
<i>443</i>&nbsp;	 * @param mapper
<i>444</i>&nbsp;	 */
<i>445</i>&nbsp;	public void setMeasurementMapper(MeasurementMapper mapper) {
<b class="nc"><i>446</i>&nbsp;		this.measurementMapper.set(mapper);</b>
<b class="nc"><i>447</i>&nbsp;	}</b>
<i>448</i>&nbsp;	
<i>449</i>&nbsp;	/**
<i>450</i>&nbsp;	 * @return the {@link MeasurementMapper} object that defines how detections should be color coded according to their measurement values in viewers
<i>451</i>&nbsp;	 */
<i>452</i>&nbsp;	public MeasurementMapper getMeasurementMapper() {
<b class="nc"><i>453</i>&nbsp;		return measurementMapper.get();</b>
<i>454</i>&nbsp;	}
<i>455</i>&nbsp;	
<i>456</i>&nbsp;	/**
<i>457</i>&nbsp;	 * @return object property containing the current {@link MeasurementMapper}, if one has been set, or null otherwise
<i>458</i>&nbsp;	 */
<i>459</i>&nbsp;	public ObjectProperty&lt;MeasurementMapper&gt; measurementMapperProperty() {
<b class="fc"><i>460</i>&nbsp;		return measurementMapper;</b>
<i>461</i>&nbsp;	}
<i>462</i>&nbsp;	
<i>463</i>&nbsp;	/**
<i>464</i>&nbsp;	 * Reset any {@link MeasurementMapper}, so that measurements are not used to determine object colors.
<i>465</i>&nbsp;	 */
<i>466</i>&nbsp;	public void resetMeasurementMapper() {
<b class="nc"><i>467</i>&nbsp;		setMeasurementMapper(null);</b>
<b class="nc"><i>468</i>&nbsp;	}</b>
<i>469</i>&nbsp;
<i>470</i>&nbsp;	/**
<i>471</i>&nbsp;	 * @return true if objects should be displayed regardless of classification (i.e. no classifications are &#39;hidden&#39;)
<i>472</i>&nbsp;	 * @see #hiddenClassesProperty()
<i>473</i>&nbsp;	 */
<i>474</i>&nbsp;	public boolean getAllPathClassesVisible() {
<b class="nc"><i>475</i>&nbsp;		return hiddenClasses.isEmpty();</b>
<i>476</i>&nbsp;	}
<i>477</i>&nbsp;	
<i>478</i>&nbsp;	/**
<i>479</i>&nbsp;	 * Query whether objects with a specified classification should be displayed or hidden.
<i>480</i>&nbsp;	 * @param pathClass the classification to query
<i>481</i>&nbsp;	 * @return true if objects with the classification should be displayed, false if they should be hidden
<i>482</i>&nbsp;	 */
<i>483</i>&nbsp;	public boolean isPathClassHidden(final PathClass pathClass) {
<b class="fc"><i>484</i>&nbsp;		if (hiddenClasses.isEmpty())</b>
<b class="fc"><i>485</i>&nbsp;			return false;</b>
<b class="nc"><i>486</i>&nbsp;		if (pathClass == null || pathClass == PathClassFactory.getPathClassUnclassified())</b>
<b class="nc"><i>487</i>&nbsp;			return hiddenClasses.contains(null) || hiddenClasses.contains(PathClassFactory.getPathClassUnclassified());</b>
<b class="nc"><i>488</i>&nbsp;		return hiddenClasses.contains(pathClass) || </b>
<b class="nc"><i>489</i>&nbsp;				((PathClassTools.isPositiveOrGradedIntensityClass(pathClass) || PathClassTools.isNegativeClass(pathClass)) &amp;&amp; pathClass.isDerivedClass() &amp;&amp; isPathClassHidden(pathClass.getParentClass()));</b>
<i>490</i>&nbsp;	}
<i>491</i>&nbsp;
<i>492</i>&nbsp;	/**
<i>493</i>&nbsp;	 * Request that objects with a particular PathClass not be displayed.
<i>494</i>&nbsp;	 * This may be null, indicating that all unclassified objects should be hidden.
<i>495</i>&nbsp;	 * 
<i>496</i>&nbsp;	 * @param pathClass
<i>497</i>&nbsp;	 * @param hidden
<i>498</i>&nbsp;	 */
<i>499</i>&nbsp;	public void setPathClassHidden(final PathClass pathClass, final boolean hidden) {
<b class="nc"><i>500</i>&nbsp;		if (hidden)</b>
<b class="nc"><i>501</i>&nbsp;			hiddenClasses.add(pathClass);</b>
<i>502</i>&nbsp;		else
<b class="nc"><i>503</i>&nbsp;			hiddenClasses.remove(pathClass);</b>
<b class="nc"><i>504</i>&nbsp;	}</b>
<i>505</i>&nbsp;	
<i>506</i>&nbsp;	/**
<i>507</i>&nbsp;	 * @return an observable set containing classifications for which the corresponding objects should not be displayed
<i>508</i>&nbsp;	 */
<i>509</i>&nbsp;	public ObservableSet&lt;PathClass&gt; hiddenClassesProperty() {
<b class="fc"><i>510</i>&nbsp;		return hiddenClasses;</b>
<i>511</i>&nbsp;	}
<i>512</i>&nbsp;	
<i>513</i>&nbsp;	
<i>514</i>&nbsp;	/**
<i>515</i>&nbsp;	 * @return the boolean property indicating whether annotations should be displayed
<i>516</i>&nbsp;	 */
<i>517</i>&nbsp;	public BooleanProperty showAnnotationsProperty() {
<b class="fc"><i>518</i>&nbsp;		return showAnnotations;</b>
<i>519</i>&nbsp;	}
<i>520</i>&nbsp;	
<i>521</i>&nbsp;	/**
<i>522</i>&nbsp;	 * @return the boolean property indicating whether object labels should be displayed
<i>523</i>&nbsp;	 */
<i>524</i>&nbsp;	public BooleanProperty showNamesProperty() {
<b class="fc"><i>525</i>&nbsp;		return showNames;</b>
<i>526</i>&nbsp;	}
<i>527</i>&nbsp;	
<i>528</i>&nbsp;	/**
<i>529</i>&nbsp;	 * @return the boolean property indicating whether any current TMA grid should be displayed
<i>530</i>&nbsp;	 */
<i>531</i>&nbsp;	public BooleanProperty showTMAGridProperty() {
<b class="fc"><i>532</i>&nbsp;		return showTMAGrid;</b>
<i>533</i>&nbsp;	}
<i>534</i>&nbsp;	
<i>535</i>&nbsp;	/**
<i>536</i>&nbsp;	 * @return the boolean property indicating whether any active pixel classification should be displayed
<i>537</i>&nbsp;	 */
<i>538</i>&nbsp;	public BooleanProperty showPixelClassificationProperty() {
<b class="fc"><i>539</i>&nbsp;		return showPixelClassification;</b>
<i>540</i>&nbsp;	}
<i>541</i>&nbsp;	
<i>542</i>&nbsp;	/**
<i>543</i>&nbsp;	 * @return the filter used to determine whether a pixel classification should be computed for a specified region
<i>544</i>&nbsp;	 */
<i>545</i>&nbsp;	public ObjectProperty&lt;RegionFilter&gt; pixelClassificationFilterRegionProperty() {
<b class="fc"><i>546</i>&nbsp;		return pixelClassificationFilter;</b>
<i>547</i>&nbsp;	}
<i>548</i>&nbsp;	
<i>549</i>&nbsp;	/**
<i>550</i>&nbsp;	 * Control where pixel classifications should be calculated during live prediction
<i>551</i>&nbsp;	 * @param region
<i>552</i>&nbsp;	 */
<i>553</i>&nbsp;	public void setPixelClassificationRegionFilter(RegionFilter region) {
<b class="nc"><i>554</i>&nbsp;		pixelClassificationFilter.set(region);</b>
<b class="nc"><i>555</i>&nbsp;	}</b>
<i>556</i>&nbsp;	
<i>557</i>&nbsp;	/**
<i>558</i>&nbsp;	 * @return a filter used to determine whether a pixel classification should be computed for a specified region
<i>559</i>&nbsp;	 */
<i>560</i>&nbsp;	public RegionFilter getPixelClassificationRegionFilter() {
<b class="nc"><i>561</i>&nbsp;		return pixelClassificationFilter.get();</b>
<i>562</i>&nbsp;	}
<i>563</i>&nbsp;
<i>564</i>&nbsp;	/**
<i>565</i>&nbsp;	 * @return the boolean property indicating whether detections should be displayed
<i>566</i>&nbsp;	 */
<i>567</i>&nbsp;	public BooleanProperty showDetectionsProperty() {
<b class="fc"><i>568</i>&nbsp;		return showDetections;</b>
<i>569</i>&nbsp;	}
<i>570</i>&nbsp;
<i>571</i>&nbsp;	/**
<i>572</i>&nbsp;	 * @return the boolean property indicating whether detections should be displayed &#39;filled&#39;
<i>573</i>&nbsp;	 */
<i>574</i>&nbsp;	public BooleanProperty fillDetectionsProperty() {
<b class="fc"><i>575</i>&nbsp;		return fillDetections;</b>
<i>576</i>&nbsp;	}
<i>577</i>&nbsp;
<i>578</i>&nbsp;	/**
<i>579</i>&nbsp;	 * @return the boolean property indicating whether annotations should be displayed &#39;filled&#39;
<i>580</i>&nbsp;	 */
<i>581</i>&nbsp;	public BooleanProperty fillAnnotationsProperty() {
<b class="fc"><i>582</i>&nbsp;		return fillAnnotations;</b>
<i>583</i>&nbsp;	}
<i>584</i>&nbsp;
<i>585</i>&nbsp;	/**
<i>586</i>&nbsp;	 * @return the boolean property indicating whether a counting grid should be shown over the viewer
<i>587</i>&nbsp;	 */
<i>588</i>&nbsp;	public BooleanProperty showGridProperty() {
<b class="fc"><i>589</i>&nbsp;		return showGrid;</b>
<i>590</i>&nbsp;	}	
<i>591</i>&nbsp;	
<i>592</i>&nbsp;	
<i>593</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2021-01-25 09:46</div>
</div>
</body>
</html>
