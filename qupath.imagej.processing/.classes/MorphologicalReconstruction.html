


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: MorphologicalReconstruction</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">qupath.imagej.processing</a> ]
</div>

<h1>Coverage Summary for Class: MorphologicalReconstruction (qupath.imagej.processing)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MorphologicalReconstruction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 210)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MorphologicalReconstruction$IntDequeue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 24)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 234)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*-
<i>2</i>&nbsp; * #%L
<i>3</i>&nbsp; * This file is part of QuPath.
<i>4</i>&nbsp; * %%
<i>5</i>&nbsp; * Copyright (C) 2014 - 2016 The Queen&#39;s University of Belfast, Northern Ireland
<i>6</i>&nbsp; * Contact: IP Management (ipmanagement@qub.ac.uk)
<i>7</i>&nbsp; * Copyright (C) 2018 - 2020 QuPath developers, The University of Edinburgh
<i>8</i>&nbsp; * %%
<i>9</i>&nbsp; * QuPath is free software: you can redistribute it and/or modify
<i>10</i>&nbsp; * it under the terms of the GNU General Public License as
<i>11</i>&nbsp; * published by the Free Software Foundation, either version 3 of the
<i>12</i>&nbsp; * License, or (at your option) any later version.
<i>13</i>&nbsp; * 
<i>14</i>&nbsp; * QuPath is distributed in the hope that it will be useful,
<i>15</i>&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
<i>16</i>&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<i>17</i>&nbsp; * GNU General Public License for more details.
<i>18</i>&nbsp; * 
<i>19</i>&nbsp; * You should have received a copy of the GNU General Public License 
<i>20</i>&nbsp; * along with QuPath.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
<i>21</i>&nbsp; * #L%
<i>22</i>&nbsp; */
<i>23</i>&nbsp;
<i>24</i>&nbsp;package qupath.imagej.processing;
<i>25</i>&nbsp;
<i>26</i>&nbsp;import ij.gui.Roi;
<i>27</i>&nbsp;import ij.plugin.filter.RankFilters;
<i>28</i>&nbsp;import ij.process.Blitter;
<i>29</i>&nbsp;import ij.process.ByteProcessor;
<i>30</i>&nbsp;import ij.process.FloatProcessor;
<i>31</i>&nbsp;import ij.process.FloodFiller;
<i>32</i>&nbsp;import ij.process.ImageProcessor;
<i>33</i>&nbsp;import ij.process.ImageStatistics;
<i>34</i>&nbsp;
<i>35</i>&nbsp;import java.awt.Rectangle;
<i>36</i>&nbsp;import java.util.Arrays;
<i>37</i>&nbsp;
<i>38</i>&nbsp;
<i>39</i>&nbsp;/**
<i>40</i>&nbsp; * Implementation of morphological reconstruction for ImageJ.
<i>41</i>&nbsp; * 
<i>42</i>&nbsp; * @author Pete Bankhead
<i>43</i>&nbsp; *
<i>44</i>&nbsp; */
<b class="nc"><i>45</i>&nbsp;public class MorphologicalReconstruction {</b>
<i>46</i>&nbsp;	/*
<i>47</i>&nbsp;	 * Morphological reconstruction using 8-connectivity &amp; a hybrid method.
<i>48</i>&nbsp;	 * 
<i>49</i>&nbsp;	 * For algorithm details, see:
<i>50</i>&nbsp;	 *   Vincent, L. (1993).
<i>51</i>&nbsp;	 *   	Morphological Grayscale Reconstruction in Image Analysis: Applications and Efficient Algorithms.
<i>52</i>&nbsp;	 * 	    IEEE Transactions on Image Processing
<i>53</i>&nbsp;	 * 
<i>54</i>&nbsp;	 * Overall, this appears to be about 20% faster than MorphologicalReconstruction using Point objects (rather than a primitive int array).
<i>55</i>&nbsp;	 * 
<i>56</i>&nbsp;	 */
<i>57</i>&nbsp;	
<i>58</i>&nbsp;	
<i>59</i>&nbsp;	
<i>60</i>&nbsp;	/**
<i>61</i>&nbsp;	 * Alternative morphological reconstruction (based on ImageJ&#39;s FloodFiller) suitable for binary images only.
<i>62</i>&nbsp;	 * @param bpMarker
<i>63</i>&nbsp;	 * @param bpMask
<i>64</i>&nbsp;	 * @param permitMaskChanges
<i>65</i>&nbsp;	 * @return
<i>66</i>&nbsp;	 */
<i>67</i>&nbsp;	public static ByteProcessor binaryReconstruction(ByteProcessor bpMarker, ByteProcessor bpMask, boolean permitMaskChanges) {
<b class="nc"><i>68</i>&nbsp;		if (!permitMaskChanges) {</b>
<b class="nc"><i>69</i>&nbsp;			bpMask = (ByteProcessor)bpMask.duplicate();</b>
<b class="nc"><i>70</i>&nbsp;			bpMarker = (ByteProcessor)bpMarker.duplicate();</b>
<i>71</i>&nbsp;		}
<b class="nc"><i>72</i>&nbsp;		FloodFiller ff = new FloodFiller(bpMask);</b>
<b class="nc"><i>73</i>&nbsp;		bpMask.setValue(127);</b>
<b class="nc"><i>74</i>&nbsp;		int width = bpMarker.getWidth();</b>
<b class="nc"><i>75</i>&nbsp;		byte[] pxMarker = (byte[])bpMarker.getPixels();</b>
<b class="nc"><i>76</i>&nbsp;		byte[] pxMask = (byte[])bpMask.getPixels();</b>
<b class="nc"><i>77</i>&nbsp;		for (int i = 0; i &lt; pxMarker.length; i++) {</b>
<b class="nc"><i>78</i>&nbsp;			if (pxMarker[i] == (byte)255 &amp;&amp; pxMask[i] != (byte)127)</b>
<b class="nc"><i>79</i>&nbsp;				ff.fill(i % width, i / width);</b>
<i>80</i>&nbsp;		}
<b class="nc"><i>81</i>&nbsp;		Arrays.fill(pxMarker, (byte)0);</b>
<b class="nc"><i>82</i>&nbsp;		for (int i = 0; i &lt; pxMask.length; i++) {</b>
<b class="nc"><i>83</i>&nbsp;			if (pxMask[i] == (byte)127)</b>
<b class="nc"><i>84</i>&nbsp;				pxMarker[i] = (byte)255;</b>
<i>85</i>&nbsp;		}
<b class="nc"><i>86</i>&nbsp;		return bpMarker;</b>
<i>87</i>&nbsp;	}
<i>88</i>&nbsp;	
<i>89</i>&nbsp;	
<i>90</i>&nbsp;	
<i>91</i>&nbsp;	private static int dilateAndCompare(final ImageProcessor ipMarker, final ImageProcessor ipMask, final boolean reverse, final IntDequeue queue) {
<i>92</i>&nbsp;		int inc, hStart, vStart, hEnd, vEnd;
<b class="nc"><i>93</i>&nbsp;		Rectangle rect = ipMarker.getRoi();</b>
<b class="nc"><i>94</i>&nbsp;		if (reverse) {</b>
<b class="nc"><i>95</i>&nbsp;			inc = -1;</b>
<b class="nc"><i>96</i>&nbsp;			hStart = rect.x + rect.width - 1;</b>
<b class="nc"><i>97</i>&nbsp;			vStart = rect.y + rect.height - 1;</b>
<b class="nc"><i>98</i>&nbsp;			hEnd = rect.x - 1;</b>
<b class="nc"><i>99</i>&nbsp;			vEnd = rect.y - 1;</b>
<i>100</i>&nbsp;		} else {
<b class="nc"><i>101</i>&nbsp;			inc = 1;</b>
<b class="nc"><i>102</i>&nbsp;			hStart = rect.x;</b>
<b class="nc"><i>103</i>&nbsp;			vStart = rect.y;</b>
<b class="nc"><i>104</i>&nbsp;			hEnd = rect.x + rect.width;</b>
<b class="nc"><i>105</i>&nbsp;			vEnd = rect.y + rect.height;</b>
<i>106</i>&nbsp;		}
<b class="nc"><i>107</i>&nbsp;		final boolean populateQueue = queue != null;</b>
<b class="nc"><i>108</i>&nbsp;		final int width = ipMarker.getWidth();</b>
<i>109</i>&nbsp;		
<i>110</i>&nbsp;		// Apply horizontal propagating dilation
<b class="nc"><i>111</i>&nbsp;		int changes = 0;</b>
<i>112</i>&nbsp;		// valPrevious is the last processed value, valP1-3 are those from the previous row
<i>113</i>&nbsp;		float valPrevious, valP1, valP2, valP3, valCurrent;
<b class="nc"><i>114</i>&nbsp;		boolean firstRow = true;</b>
<b class="nc"><i>115</i>&nbsp;		for (int y = vStart; y != vEnd; y += inc) {</b>
<i>116</i>&nbsp;			// Initialize previous 4 neighbours
<b class="nc"><i>117</i>&nbsp;			valPrevious = ipMarker.getf(hStart, y);</b>
<b class="nc"><i>118</i>&nbsp;			if (firstRow) {</b>
<b class="nc"><i>119</i>&nbsp;				valP1 = valPrevious;</b>
<b class="nc"><i>120</i>&nbsp;				valP2 = valPrevious;</b>
<b class="nc"><i>121</i>&nbsp;				valP3 = valPrevious;</b>
<i>122</i>&nbsp;			} else {
<b class="nc"><i>123</i>&nbsp;				valP2 = ipMarker.getf(hStart, y-inc);</b>
<b class="nc"><i>124</i>&nbsp;				valP1 = valP2;</b>
<i>125</i>&nbsp;			}
<i>126</i>&nbsp;
<b class="nc"><i>127</i>&nbsp;			boolean firstColumn = true;</b>
<i>128</i>&nbsp;
<b class="nc"><i>129</i>&nbsp;			for (int x = hStart; x != hEnd; x += inc) {</b>
<i>130</i>&nbsp;				// Get the current value from the marker image
<b class="nc"><i>131</i>&nbsp;				valCurrent = ipMarker.getf(x, y);</b>
<i>132</i>&nbsp;				
<b class="nc"><i>133</i>&nbsp;				if (firstRow) {</b>
<b class="nc"><i>134</i>&nbsp;					valP1 = valCurrent;</b>
<b class="nc"><i>135</i>&nbsp;					valP2 = valCurrent;</b>
<b class="nc"><i>136</i>&nbsp;					valP3 = valCurrent;</b>
<b class="nc"><i>137</i>&nbsp;				} else if (x+inc != hEnd)</b>
<b class="nc"><i>138</i>&nbsp;					valP3 = ipMarker.getf(x+inc, y-inc);</b>
<i>139</i>&nbsp;				else
<b class="nc"><i>140</i>&nbsp;					valP3 = valCurrent;</b>
<i>141</i>&nbsp;				
<i>142</i>&nbsp;				// Get the neighbourhood maximum
<i>143</i>&nbsp;//				float valNeighbourMax = Math.max(Math.max(valP1, valP2), Math.max(valP3, valPrevious));
<b class="nc"><i>144</i>&nbsp;				float valNeighbourMax = (valP1 &gt;= valP2) ? valP1 : valP2;</b>
<b class="nc"><i>145</i>&nbsp;				valNeighbourMax = (valNeighbourMax &gt;= valP3) ? valNeighbourMax : valP3;</b>
<b class="nc"><i>146</i>&nbsp;				valNeighbourMax = (valNeighbourMax &gt;= valPrevious) ? valNeighbourMax : valPrevious;</b>
<i>147</i>&nbsp;				
<i>148</i>&nbsp;				// If the current value is less than the neighbourhood maximum, try to update it while remaining under the mask
<b class="nc"><i>149</i>&nbsp;				if (valCurrent &lt; valNeighbourMax) {</b>
<b class="nc"><i>150</i>&nbsp;					float valMask = ipMask.getf(x, y);</b>
<i>151</i>&nbsp;//					float valNew = Math.min(valMask, valNeighbourMax);
<i>152</i>&nbsp;					// Get the minimum
<b class="nc"><i>153</i>&nbsp;					float valNew = (valNeighbourMax &gt;= valMask) ? valMask : valNeighbourMax;</b>
<b class="nc"><i>154</i>&nbsp;					if (valNew &gt; valCurrent) {</b>
<b class="nc"><i>155</i>&nbsp;						valCurrent = valNew;</b>
<b class="nc"><i>156</i>&nbsp;						ipMarker.setf(x, y, valCurrent);</b>
<b class="nc"><i>157</i>&nbsp;						changes++;</b>
<i>158</i>&nbsp;					}
<i>159</i>&nbsp;				}
<i>160</i>&nbsp;				
<i>161</i>&nbsp;				// If there are neighbours with lower values than we have just updated, and we have a queue,
<i>162</i>&nbsp;				// test whether to add the neighbours to the queue
<b class="nc"><i>163</i>&nbsp;				if (populateQueue) {</b>
<b class="nc"><i>164</i>&nbsp;					boolean addToQueue = false;</b>
<b class="nc"><i>165</i>&nbsp;					if (valPrevious &lt; valCurrent &amp;&amp; valPrevious &lt; ipMask.getf(x-inc, y)) {</b>
<b class="nc"><i>166</i>&nbsp;						addToQueue = true;</b>
<i>167</i>&nbsp;					}
<b class="nc"><i>168</i>&nbsp;					else if (!firstRow) {</b>
<b class="nc"><i>169</i>&nbsp;						if (!firstColumn &amp;&amp; valP1 &lt; valCurrent &amp;&amp; valP1 &lt; ipMask.getf(x-inc, y-inc)) {</b>
<b class="nc"><i>170</i>&nbsp;							addToQueue = true;</b>
<i>171</i>&nbsp;						}
<b class="nc"><i>172</i>&nbsp;						else if (valP2 &lt; valCurrent &amp;&amp; valP2 &lt; ipMask.getf(x, y-inc)) {</b>
<b class="nc"><i>173</i>&nbsp;							addToQueue = true;</b>
<i>174</i>&nbsp;						}
<b class="nc"><i>175</i>&nbsp;						else if (valP3 &lt; valCurrent &amp;&amp; valP3 &lt; ipMask.getf(x+inc, y-inc)) {</b>
<b class="nc"><i>176</i>&nbsp;							addToQueue = true;</b>
<i>177</i>&nbsp;						}
<i>178</i>&nbsp;					}
<b class="nc"><i>179</i>&nbsp;					if (addToQueue) {</b>
<b class="nc"><i>180</i>&nbsp;						queue.add(y*width + x);</b>
<i>181</i>&nbsp;					}
<i>182</i>&nbsp;				}
<i>183</i>&nbsp;				
<i>184</i>&nbsp;				// Update previous neighbours
<b class="nc"><i>185</i>&nbsp;				valPrevious = valCurrent;</b>
<b class="nc"><i>186</i>&nbsp;				valP1 = valP2;</b>
<b class="nc"><i>187</i>&nbsp;				valP2 = valP3;</b>
<b class="nc"><i>188</i>&nbsp;				firstColumn = false;</b>
<i>189</i>&nbsp;			}
<b class="nc"><i>190</i>&nbsp;			firstRow = false;</b>
<i>191</i>&nbsp;		}
<b class="nc"><i>192</i>&nbsp;		return changes;</b>
<i>193</i>&nbsp;	}
<i>194</i>&nbsp;	
<i>195</i>&nbsp;	private static void processPoint(final ImageProcessor ipMarker, final ImageProcessor ipMask, final int ind, final float val, final IntDequeue queue) {
<b class="nc"><i>196</i>&nbsp;		final float valTempMarker = ipMarker.getf(ind);</b>
<b class="nc"><i>197</i>&nbsp;		if (valTempMarker &lt; val) {</b>
<b class="nc"><i>198</i>&nbsp;			final float valTempMask = ipMask.getf(ind);</b>
<b class="nc"><i>199</i>&nbsp;			if (valTempMarker &lt; valTempMask) {</b>
<i>200</i>&nbsp;//				ipMarker.setf(x, y, Math.min(val, valTempMask));
<b class="nc"><i>201</i>&nbsp;				ipMarker.setf(ind, valTempMask &lt;= val ? valTempMask : val);</b>
<b class="nc"><i>202</i>&nbsp;				queue.add(ind);</b>
<i>203</i>&nbsp;			}
<i>204</i>&nbsp;		}
<i>205</i>&nbsp;	}
<i>206</i>&nbsp;	
<i>207</i>&nbsp;	
<i>208</i>&nbsp;	private static boolean processQueue(final ImageProcessor ipMarker, final ImageProcessor ipMask, final IntDequeue queue) {
<b class="nc"><i>209</i>&nbsp;		final Rectangle rect = ipMarker.getRoi();</b>
<b class="nc"><i>210</i>&nbsp;		final int x1 = rect.x;</b>
<b class="nc"><i>211</i>&nbsp;		final int y1 = rect.y;</b>
<b class="nc"><i>212</i>&nbsp;		final int x2 = x1 + rect.width;</b>
<b class="nc"><i>213</i>&nbsp;		final int y2 = y1 + rect.height;</b>
<i>214</i>&nbsp;		
<b class="nc"><i>215</i>&nbsp;		long counter = 0;</b>
<b class="nc"><i>216</i>&nbsp;		final int width = ipMarker.getWidth();</b>
<i>217</i>&nbsp;		
<b class="nc"><i>218</i>&nbsp;		final Thread currentThread = Thread.currentThread();</b>
<i>219</i>&nbsp;		
<b class="nc"><i>220</i>&nbsp;		while (!queue.isEmpty()) {</b>
<b class="nc"><i>221</i>&nbsp;			counter++;</b>
<i>222</i>&nbsp;
<i>223</i>&nbsp;			// If we were interrupted, stop
<b class="nc"><i>224</i>&nbsp;			if (counter % 2500 == 0 &amp;&amp; currentThread.isInterrupted())</b>
<b class="nc"><i>225</i>&nbsp;				return false;</b>
<i>226</i>&nbsp;			
<b class="nc"><i>227</i>&nbsp;			final int ind = queue.remove();</b>
<b class="nc"><i>228</i>&nbsp;			final int x = ind % width;</b>
<b class="nc"><i>229</i>&nbsp;			final int y = ind / width;</b>
<i>230</i>&nbsp;			
<i>231</i>&nbsp;			// Test 8-neighbours
<b class="nc"><i>232</i>&nbsp;			final float val = ipMarker.getf(ind);</b>
<i>233</i>&nbsp;			
<i>234</i>&nbsp;//			for (int yy = Math.max(y-1, y1); yy &lt; Math.min(y+2, y2); yy++) {
<i>235</i>&nbsp;//				for (int xx = Math.max(x-1, x1); xx &lt; Math.min(x+2, x2); xx++) {
<i>236</i>&nbsp;//					if (xx != x || yy != y)
<i>237</i>&nbsp;//						processPoint(ipMarker, ipMask, yy*width+xx, val, queue);
<i>238</i>&nbsp;//				}
<i>239</i>&nbsp;//			}
<i>240</i>&nbsp;			
<b class="nc"><i>241</i>&nbsp;			if (x &gt; x1) {</b>
<b class="nc"><i>242</i>&nbsp;				processPoint(ipMarker, ipMask, ind-1, val, queue);</b>
<b class="nc"><i>243</i>&nbsp;				if (y &gt; y1)</b>
<b class="nc"><i>244</i>&nbsp;					processPoint(ipMarker, ipMask, ind-width-1, val, queue);</b>
<b class="nc"><i>245</i>&nbsp;				if (y &lt; y2-1)</b>
<b class="nc"><i>246</i>&nbsp;					processPoint(ipMarker, ipMask, ind+width-1, val, queue);</b>
<i>247</i>&nbsp;			}
<b class="nc"><i>248</i>&nbsp;			if (x &lt; x2-1) {</b>
<b class="nc"><i>249</i>&nbsp;				processPoint(ipMarker, ipMask, ind+1, val, queue);</b>
<b class="nc"><i>250</i>&nbsp;				if (y &gt; y1)</b>
<b class="nc"><i>251</i>&nbsp;					processPoint(ipMarker, ipMask, ind-width+1, val, queue);</b>
<b class="nc"><i>252</i>&nbsp;				if (y &lt; y2-1)</b>
<b class="nc"><i>253</i>&nbsp;					processPoint(ipMarker, ipMask, ind+width+1, val, queue);</b>
<i>254</i>&nbsp;			}
<b class="nc"><i>255</i>&nbsp;			if (y &gt; y1)</b>
<b class="nc"><i>256</i>&nbsp;				processPoint(ipMarker, ipMask, ind-width, val, queue);</b>
<b class="nc"><i>257</i>&nbsp;			if (y &lt; y2-1)</b>
<b class="nc"><i>258</i>&nbsp;				processPoint(ipMarker, ipMask, ind+width, val, queue);</b>
<b class="nc"><i>259</i>&nbsp;		}</b>
<i>260</i>&nbsp;		
<b class="nc"><i>261</i>&nbsp;		return true;</b>
<i>262</i>&nbsp;	}
<i>263</i>&nbsp;	
<i>264</i>&nbsp;	/**
<i>265</i>&nbsp;	 * Apply morphological operation using marker and mask images. The marker image is changed.
<i>266</i>&nbsp;	 * @param ipMarker
<i>267</i>&nbsp;	 * @param ipMask
<i>268</i>&nbsp;	 * @return
<i>269</i>&nbsp;	 */
<i>270</i>&nbsp;	public static boolean morphologicalReconstruction(final ImageProcessor ipMarker, final ImageProcessor ipMask) {
<i>271</i>&nbsp;		// Really we just need one round of forward propagation, followed by one round of backward
<i>272</i>&nbsp;		// propagation filling in the queue... but working with the queue is slow, so it is better to
<i>273</i>&nbsp;		// repeat propagation steps so long as they are changing a sufficiently high proportion of the pixels
<i>274</i>&nbsp;		// at each step (here, 10%)
<i>275</i>&nbsp;		
<i>276</i>&nbsp;//		long startTime = System.currentTimeMillis();
<b class="nc"><i>277</i>&nbsp;		final int nPixels = ipMarker.getWidth() * ipMarker.getHeight();</b>
<i>278</i>&nbsp;		// Apply forward propagation, counting the number of pixels that changed
<b class="nc"><i>279</i>&nbsp;		int nChanges = dilateAndCompare(ipMarker, ipMask, false, null);</b>
<i>280</i>&nbsp;		// For as long as &gt; ?% pixels change, continue propagations
<i>281</i>&nbsp;//		int counter = 0;
<b class="nc"><i>282</i>&nbsp;		while (nChanges/(double)nPixels &gt; 0.1) {</b>
<i>283</i>&nbsp;//			System.out.println(String.format(&quot;Changes as propagation iteration %d: %.2f%%&quot;, counter++, 100.*nChanges/nPixels));
<i>284</i>&nbsp;			// Apply backwards propagation
<b class="nc"><i>285</i>&nbsp;			dilateAndCompare(ipMarker, ipMask, true, null);</b>
<i>286</i>&nbsp;			// Apply forward propagation again
<b class="nc"><i>287</i>&nbsp;			nChanges = dilateAndCompare(ipMarker, ipMask, false, null);			</b>
<i>288</i>&nbsp;		}
<i>289</i>&nbsp;//		System.out.println(String.format(&quot;Changes as propagation iteration %d: %.2f%%&quot;, counter++, 100.*nChanges/nPixels));
<i>290</i>&nbsp;		// Apply backwards propagation, filling the queue
<b class="nc"><i>291</i>&nbsp;		final IntDequeue queue = new IntDequeue(nPixels/4);</b>
<b class="nc"><i>292</i>&nbsp;		dilateAndCompare(ipMarker, ipMask, true, queue);</b>
<i>293</i>&nbsp;//		long endTime = System.currentTimeMillis();
<i>294</i>&nbsp;//		System.out.println(&quot;Queue setup time: &quot; + (endTime - startTime)/1000.);
<i>295</i>&nbsp;		
<i>296</i>&nbsp;//		startTime = System.currentTimeMillis();
<b class="nc"><i>297</i>&nbsp;		processQueue(ipMarker, ipMask, queue);</b>
<i>298</i>&nbsp;//		endTime = System.currentTimeMillis();
<i>299</i>&nbsp;//		System.out.println(&quot;Queue process time: &quot; + (endTime - startTime)/1000.);
<i>300</i>&nbsp;		// Process pixels in the queue (FIFO)
<b class="nc"><i>301</i>&nbsp;		return processQueue(ipMarker, ipMask, queue);</b>
<i>302</i>&nbsp;	}
<i>303</i>&nbsp;	
<i>304</i>&nbsp;//	// More conventional approach...
<i>305</i>&nbsp;//	public static boolean morphologicalReconstruction(ImageProcessor ipMarker, ImageProcessor ipMask) {
<i>306</i>&nbsp;//		// Apply forward propagation
<i>307</i>&nbsp;//		dilateAndCompare(ipMarker, ipMask, false, null);
<i>308</i>&nbsp;//		// Apply backwards propagation, filling the queue
<i>309</i>&nbsp;//		IntDequeue queue = new IntDequeue(ipMarker.getWidth()*ipMarker.getHeight()/4);
<i>310</i>&nbsp;//		dilateAndCompare(ipMarker, ipMask, true, queue);
<i>311</i>&nbsp;//		// Process pixels in the queue (FIFO)
<i>312</i>&nbsp;//		return processQueue(ipMarker, ipMask, queue);
<i>313</i>&nbsp;//	}
<i>314</i>&nbsp;	
<i>315</i>&nbsp;	
<i>316</i>&nbsp;	/**
<i>317</i>&nbsp;	 * Check that marker and mask images have the same size, and ensure that marker pixels are &amp;lt;= mask pixels, 
<i>318</i>&nbsp;	 * making this if necessary.
<i>319</i>&nbsp;	 * @param ipMarker
<i>320</i>&nbsp;	 * @param ipMask
<i>321</i>&nbsp;	 * @return
<i>322</i>&nbsp;	 */
<i>323</i>&nbsp;	public static boolean validateMarkerMask(ImageProcessor ipMarker, ImageProcessor ipMask) {
<b class="nc"><i>324</i>&nbsp;		if (ipMarker.getWidth() != ipMask.getWidth() || ipMarker.getHeight() != ipMask.getHeight())</b>
<b class="nc"><i>325</i>&nbsp;			return false;</b>
<b class="nc"><i>326</i>&nbsp;		ipMarker.copyBits(ipMask, 0, 0, Blitter.MIN);</b>
<b class="nc"><i>327</i>&nbsp;		return true;</b>
<i>328</i>&nbsp;	}
<i>329</i>&nbsp;	
<i>330</i>&nbsp;	/**
<i>331</i>&nbsp;	 * Apply opening by reconstruction, with the specified minimum filter radius.
<i>332</i>&nbsp;	 * @param ip
<i>333</i>&nbsp;	 * @param radius
<i>334</i>&nbsp;	 * @return
<i>335</i>&nbsp;	 */
<i>336</i>&nbsp;	public static ImageProcessor openingByReconstruction(final ImageProcessor ip, final double radius) {
<i>337</i>&nbsp;		// Apply (initial) morphological opening
<b class="nc"><i>338</i>&nbsp;		final RankFilters rf = new RankFilters();</b>
<b class="nc"><i>339</i>&nbsp;		final ImageProcessor ipReconstructed = ip.duplicate();</b>
<b class="nc"><i>340</i>&nbsp;		ipReconstructed.setRoi(ip.getRoi());</b>
<b class="nc"><i>341</i>&nbsp;		rf.rank(ipReconstructed, radius, RankFilters.MIN);</b>
<i>342</i>&nbsp;//		if (ip.getRoi() == null)
<i>343</i>&nbsp;//			rf.rank(ipReconstructed, radius, RankFilters.MAX);
<i>344</i>&nbsp;		// Dilate opened image constrained by original image as a mask
<b class="nc"><i>345</i>&nbsp;		if (morphologicalReconstruction(ipReconstructed, ip))</b>
<b class="nc"><i>346</i>&nbsp;			return ipReconstructed;</b>
<b class="nc"><i>347</i>&nbsp;		return null;</b>
<i>348</i>&nbsp;	}
<i>349</i>&nbsp;	
<i>350</i>&nbsp;//	public static boolean morphologicalReconstruction(ImageProcessor ipMarker, ImageProcessor ipMask) {
<i>351</i>&nbsp;//		// Apply forward propagation
<i>352</i>&nbsp;//		long t1 = System.currentTimeMillis();
<i>353</i>&nbsp;//		dilateAndCompare(ipMarker, ipMask, false, null);
<i>354</i>&nbsp;//		long t2 = System.currentTimeMillis();
<i>355</i>&nbsp;//		// Apply backwards propagation, filling the queue
<i>356</i>&nbsp;//		Queue&lt;Point&gt; queue = new ArrayDeque&lt;&gt;();
<i>357</i>&nbsp;//		dilateAndCompare(ipMarker, ipMask, true, queue);
<i>358</i>&nbsp;//		long t3 = System.currentTimeMillis();
<i>359</i>&nbsp;//		// Process pixels in the queue (FIFO)
<i>360</i>&nbsp;//		boolean result = processQueue(ipMarker, ipMask, queue);
<i>361</i>&nbsp;//		long t4 = System.currentTimeMillis();
<i>362</i>&nbsp;//		IJ.log(&quot;ORIGINAL&quot;);
<i>363</i>&nbsp;//		IJ.log(&quot;Time 1: &quot; + (t2-t1));
<i>364</i>&nbsp;//		IJ.log(&quot;Time 2: &quot; + (t3-t2));
<i>365</i>&nbsp;//		IJ.log(&quot;Time queue: &quot; + (t4-t3));
<i>366</i>&nbsp;//		return result;
<i>367</i>&nbsp;//	}
<i>368</i>&nbsp;	
<i>369</i>&nbsp;//	private static void invertReproducibly(ImageProcessor ip) {
<i>370</i>&nbsp;//		if (ip == null)
<i>371</i>&nbsp;//			return;
<i>372</i>&nbsp;//		if (ip instanceof FloatProcessor)
<i>373</i>&nbsp;//			ip.multiply(-1.0);
<i>374</i>&nbsp;//		else if (ip instanceof ByteProcessor)
<i>375</i>&nbsp;//			ip.invert();
<i>376</i>&nbsp;//		else if (ip instanceof ShortProcessor) {
<i>377</i>&nbsp;//			int max = (int)Math.pow(2, 16)-1;
<i>378</i>&nbsp;//			for (int i = 0; i &lt; ip.getWidth() * ip.getHeight(); i++)
<i>379</i>&nbsp;//				ip.setf(i, max - ip.getf(i));
<i>380</i>&nbsp;//		}
<i>381</i>&nbsp;//	}
<i>382</i>&nbsp;	
<i>383</i>&nbsp;	/**
<i>384</i>&nbsp;	 * Apply a morphological closing by reconstruction.
<i>385</i>&nbsp;	 * @param ip {@link ImageProcessor} to process
<i>386</i>&nbsp;	 * @param radius minimum filter radius
<i>387</i>&nbsp;	 * @return processed image
<i>388</i>&nbsp;	 */
<i>389</i>&nbsp;	public static ImageProcessor closingByReconstruction(final ImageProcessor ip, final double radius) {
<b class="nc"><i>390</i>&nbsp;		final ImageProcessor ipDuplicate = ip.duplicate();</b>
<i>391</i>&nbsp;//		invertReproducibly(ipDuplicate);
<b class="nc"><i>392</i>&nbsp;		ipDuplicate.invert();</b>
<b class="nc"><i>393</i>&nbsp;		final ImageProcessor ipReconstructed = openingByReconstruction(ipDuplicate, radius);</b>
<b class="nc"><i>394</i>&nbsp;		if (ipReconstructed != null)</b>
<b class="nc"><i>395</i>&nbsp;			ipReconstructed.invert();</b>
<i>396</i>&nbsp;//		invertReproducibly(ipReconstructed);
<b class="nc"><i>397</i>&nbsp;		return ipReconstructed;</b>
<i>398</i>&nbsp;	}
<i>399</i>&nbsp;	
<i>400</i>&nbsp;	/**
<i>401</i>&nbsp;	 * Ensure that a FloatProcessor only has region minima within a specified Roi, using morphological reconstruction.
<i>402</i>&nbsp;	 * 
<i>403</i>&nbsp;	 * @param fp
<i>404</i>&nbsp;	 * @param roi
<i>405</i>&nbsp;	 */
<i>406</i>&nbsp;	public static void imposeMinima(final FloatProcessor fp, final Roi roi) {
<b class="nc"><i>407</i>&nbsp;		final ImageProcessor fpOrig = fp.duplicate();</b>
<i>408</i>&nbsp;
<i>409</i>&nbsp;//		ImageStatistics stats = fp.getStatistics();
<i>410</i>&nbsp;		
<b class="nc"><i>411</i>&nbsp;		fp.setValue(Float.NEGATIVE_INFINITY);</b>
<b class="nc"><i>412</i>&nbsp;		fp.fill(roi);</b>
<b class="nc"><i>413</i>&nbsp;		RoiLabeling.fillOutside(fp, roi, Float.POSITIVE_INFINITY);</b>
<i>414</i>&nbsp;
<b class="nc"><i>415</i>&nbsp;		fpOrig.copyBits(fp, 0, 0, Blitter.MIN);</b>
<i>416</i>&nbsp;
<b class="nc"><i>417</i>&nbsp;		fpOrig.multiply(-1);</b>
<b class="nc"><i>418</i>&nbsp;		fp.multiply(-1);</b>
<b class="nc"><i>419</i>&nbsp;		morphologicalReconstruction(fp, fpOrig);</b>
<b class="nc"><i>420</i>&nbsp;		fp.multiply(-1);</b>
<i>421</i>&nbsp;	}
<i>422</i>&nbsp;	
<i>423</i>&nbsp;	/**
<i>424</i>&nbsp;	 * Ensure that a FloatProcessor only has region maxima within a specified Roi, using morphological reconstruction.
<i>425</i>&nbsp;	 * 
<i>426</i>&nbsp;	 * @param fp
<i>427</i>&nbsp;	 * @param roi
<i>428</i>&nbsp;	 */
<i>429</i>&nbsp;	public static void imposeMaxima(FloatProcessor fp, Roi roi) {
<b class="nc"><i>430</i>&nbsp;		final ImageProcessor fpOrig = fp.duplicate();</b>
<b class="nc"><i>431</i>&nbsp;		final ImageStatistics stats = fp.getStatistics();</b>
<i>432</i>&nbsp;		
<b class="nc"><i>433</i>&nbsp;		fp.setValue(Float.POSITIVE_INFINITY);</b>
<b class="nc"><i>434</i>&nbsp;		fp.fill(roi);</b>
<b class="nc"><i>435</i>&nbsp;		RoiLabeling.fillOutside(fp, roi, Float.NEGATIVE_INFINITY);</b>
<i>436</i>&nbsp;
<b class="nc"><i>437</i>&nbsp;		fpOrig.copyBits(fp, 0, 0, Blitter.MAX);</b>
<i>438</i>&nbsp;
<b class="nc"><i>439</i>&nbsp;		morphologicalReconstruction(fp, fpOrig);</b>
<i>440</i>&nbsp;		
<b class="nc"><i>441</i>&nbsp;		fp.setValue(stats.max);</b>
<b class="nc"><i>442</i>&nbsp;		fp.fill(roi);</b>
<i>443</i>&nbsp;	}
<i>444</i>&nbsp;	
<i>445</i>&nbsp;	/**
<i>446</i>&nbsp;	 * Ensure that a FloatProcessor only has region maxima within a specified mask, using morphological reconstruction.
<i>447</i>&nbsp;	 * 
<i>448</i>&nbsp;	 * @param fp
<i>449</i>&nbsp;	 * @param ipMask
<i>450</i>&nbsp;	 */
<i>451</i>&nbsp;	public static void imposeMaxima(final FloatProcessor fp, final ImageProcessor ipMask) {
<b class="nc"><i>452</i>&nbsp;		final ImageProcessor fpOrig = fp.duplicate();</b>
<b class="nc"><i>453</i>&nbsp;		final ImageStatistics stats = fp.getStatistics();</b>
<i>454</i>&nbsp;		
<b class="nc"><i>455</i>&nbsp;		final int w = fp.getWidth();</b>
<b class="nc"><i>456</i>&nbsp;		final int h = fp.getHeight();</b>
<b class="nc"><i>457</i>&nbsp;		for (int i = 0; i &lt; w * h; i++) {</b>
<b class="nc"><i>458</i>&nbsp;			if (ipMask.getf(i) == 0)</b>
<b class="nc"><i>459</i>&nbsp;				fp.setf(i, Float.NEGATIVE_INFINITY);</b>
<i>460</i>&nbsp;			else
<b class="nc"><i>461</i>&nbsp;				fp.setf(i, Float.POSITIVE_INFINITY);</b>
<i>462</i>&nbsp;		}
<b class="nc"><i>463</i>&nbsp;		fpOrig.copyBits(fp, 0, 0, Blitter.MAX);</b>
<i>464</i>&nbsp;
<b class="nc"><i>465</i>&nbsp;		morphologicalReconstruction(fp, fpOrig);</b>
<i>466</i>&nbsp;
<b class="nc"><i>467</i>&nbsp;		for (int i = 0; i &lt; w * h; i++) {</b>
<b class="nc"><i>468</i>&nbsp;			if (ipMask.getf(i) != 0)</b>
<b class="nc"><i>469</i>&nbsp;				fp.setf(i, (float)stats.max);</b>
<i>470</i>&nbsp;		}
<i>471</i>&nbsp;	}
<i>472</i>&nbsp;	
<i>473</i>&nbsp;	
<i>474</i>&nbsp;//	public static void imposeMinima(FloatProcessor fp, Roi roi) {
<i>475</i>&nbsp;//		ImageProcessor fpOrig = fp.duplicate();
<i>476</i>&nbsp;//
<i>477</i>&nbsp;//		ImageStatistics stats = fp.getStatistics();
<i>478</i>&nbsp;//		
<i>479</i>&nbsp;//		fp.setValue(Float.NEGATIVE_INFINITY);
<i>480</i>&nbsp;//		fp.fill(roi);
<i>481</i>&nbsp;//		ROILabeling.fillOutside(fp, roi, Float.POSITIVE_INFINITY);
<i>482</i>&nbsp;//
<i>483</i>&nbsp;//		ImageProcessor fp1 = fpOrig.duplicate();
<i>484</i>&nbsp;//		fp1.add(0.001 * (stats.max - stats.min));
<i>485</i>&nbsp;//		fp1.copyBits(fp, 0, 0, Blitter.MIN);
<i>486</i>&nbsp;//
<i>487</i>&nbsp;//		fp1.multiply(-1);
<i>488</i>&nbsp;//		fp.multiply(-1);
<i>489</i>&nbsp;//		morphologicalReconstruction(fp, fp1);
<i>490</i>&nbsp;//		fp.multiply(-1);
<i>491</i>&nbsp;//	}
<i>492</i>&nbsp;//	
<i>493</i>&nbsp;//	public static void imposeMaxima(FloatProcessor fp, Roi roi) {
<i>494</i>&nbsp;//		ImageProcessor fpOrig = fp.duplicate();
<i>495</i>&nbsp;//
<i>496</i>&nbsp;//		ImageStatistics stats = fp.getStatistics();
<i>497</i>&nbsp;//		
<i>498</i>&nbsp;//		fp.setValue(Float.POSITIVE_INFINITY);
<i>499</i>&nbsp;//		fp.fill(roi);
<i>500</i>&nbsp;//		ROILabeling.fillOutside(fp, roi, Float.NEGATIVE_INFINITY);
<i>501</i>&nbsp;//
<i>502</i>&nbsp;//		ImageProcessor fp1 = fpOrig.duplicate();
<i>503</i>&nbsp;//		fp1.subtract(0.001 * (stats.max - stats.min));
<i>504</i>&nbsp;//		fp1.copyBits(fp, 0, 0, Blitter.MAX);
<i>505</i>&nbsp;//
<i>506</i>&nbsp;//		morphologicalReconstruction(fp, fp1);
<i>507</i>&nbsp;//		
<i>508</i>&nbsp;////		fp.setValue(stats.max);
<i>509</i>&nbsp;////		fp.fill(roi);
<i>510</i>&nbsp;//	}
<i>511</i>&nbsp;
<i>512</i>&nbsp;	
<i>513</i>&nbsp;	
<i>514</i>&nbsp;	private static class IntDequeue {
<i>515</i>&nbsp;		
<i>516</i>&nbsp;		final private static int MAX_EXPANSION = 1024*10;
<i>517</i>&nbsp;		
<i>518</i>&nbsp;		private int[] array;
<b class="nc"><i>519</i>&nbsp;		private int head = 0; // Points to location of first element in queue</b>
<b class="nc"><i>520</i>&nbsp;		private int tail = 0; // Points to location of *next* insert</b>
<i>521</i>&nbsp;		
<b class="nc"><i>522</i>&nbsp;		private IntDequeue(int capacity) {</b>
<i>523</i>&nbsp;//			IJ.log(&quot;Using INT DEQUE!&quot;);
<b class="nc"><i>524</i>&nbsp;			array = new int[capacity];</b>
<b class="nc"><i>525</i>&nbsp;			head = 0;</b>
<b class="nc"><i>526</i>&nbsp;			tail = 0;</b>
<i>527</i>&nbsp;		}
<i>528</i>&nbsp;		
<i>529</i>&nbsp;		public boolean isEmpty() {
<b class="nc"><i>530</i>&nbsp;			return tail == head;</b>
<i>531</i>&nbsp;		}
<i>532</i>&nbsp;		
<i>533</i>&nbsp;		/**
<i>534</i>&nbsp;		 * Performs no check that the output will be valid (caller should use isEmpty first to check this)
<i>535</i>&nbsp;		 * @return
<i>536</i>&nbsp;		 */
<i>537</i>&nbsp;		private int remove() {
<i>538</i>&nbsp;//			return array[head++];
<b class="nc"><i>539</i>&nbsp;			head++;</b>
<b class="nc"><i>540</i>&nbsp;			return array[head-1];</b>
<i>541</i>&nbsp;		}
<i>542</i>&nbsp;		
<i>543</i>&nbsp;		private void add(int val) {
<i>544</i>&nbsp;			// Do a normal add if we can
<b class="nc"><i>545</i>&nbsp;			if (tail &lt; array.length) {</b>
<b class="nc"><i>546</i>&nbsp;				array[tail] = val;</b>
<b class="nc"><i>547</i>&nbsp;				tail++;</b>
<i>548</i>&nbsp;				return;
<i>549</i>&nbsp;			}
<i>550</i>&nbsp;			// Shift everything back if that&#39;s an option
<b class="nc"><i>551</i>&nbsp;			if (head != 0) {</b>
<i>552</i>&nbsp;//				IJ.log(&quot;Shifting with head at &quot; + head);
<b class="nc"><i>553</i>&nbsp;				if (tail &gt; head)</b>
<b class="nc"><i>554</i>&nbsp;					System.arraycopy(array, head, array, 0, tail-head);</b>
<b class="nc"><i>555</i>&nbsp;				tail -= head;</b>
<b class="nc"><i>556</i>&nbsp;				head = 0;</b>
<b class="nc"><i>557</i>&nbsp;				array[tail] = val;</b>
<b class="nc"><i>558</i>&nbsp;				tail++;</b>
<i>559</i>&nbsp;				return;
<i>560</i>&nbsp;			}
<i>561</i>&nbsp;			// We need to expand the array
<b class="nc"><i>562</i>&nbsp;			int[] array2 = new int[Math.max(array.length*2, MAX_EXPANSION)];</b>
<b class="nc"><i>563</i>&nbsp;			System.arraycopy(array, 0, array2, 0, array.length);</b>
<b class="nc"><i>564</i>&nbsp;			array = array2;</b>
<b class="nc"><i>565</i>&nbsp;			array[tail] = val;</b>
<b class="nc"><i>566</i>&nbsp;			tail++;</b>
<i>567</i>&nbsp;//			IJ.log(&quot;Expanding IntDeque to length &quot; + array.length);
<i>568</i>&nbsp;//			System.out.println(&quot;Expanding IntDeque to length &quot; + array.length);
<i>569</i>&nbsp;		}
<i>570</i>&nbsp;		
<i>571</i>&nbsp;	}
<i>572</i>&nbsp;
<i>573</i>&nbsp;
<i>574</i>&nbsp;	/**
<i>575</i>&nbsp;	 * Replace all potential local maxima - as determined by effectively comparing the image with itself after
<i>576</i>&nbsp;	 * applying a 3x3 maximum filter - with the lowest possible value via {@code setf(x, y, Float.NEGATIVE_INFINITY)}.
<i>577</i>&nbsp;	 * &lt;p&gt;
<i>578</i>&nbsp;	 * These can then be filled in by morphological reconstruction on the way to finding &#39;true&#39; maxima.
<i>579</i>&nbsp;	 * 
<i>580</i>&nbsp;	 * @param ip
<i>581</i>&nbsp;	 * @param threshold
<i>582</i>&nbsp;	 * @param x1
<i>583</i>&nbsp;	 * @param x2
<i>584</i>&nbsp;	 * @param y1
<i>585</i>&nbsp;	 * @param y2
<i>586</i>&nbsp;	 * @return
<i>587</i>&nbsp;	 */
<i>588</i>&nbsp;	static ImageProcessor getMaximaLabels(ImageProcessor ip, float threshold, int x1, int x2, int y1, int y2) {
<b class="nc"><i>589</i>&nbsp;		float minVal = (ip instanceof FloatProcessor) ? Float.NEGATIVE_INFINITY : 0;</b>
<b class="nc"><i>590</i>&nbsp;		ImageProcessor ip2 = ip.duplicate();</b>
<b class="nc"><i>591</i>&nbsp;		for (int y = y1+1; y &lt; y2-1; y++) {</b>
<b class="nc"><i>592</i>&nbsp;			float val = ip.getf(x1, y);</b>
<b class="nc"><i>593</i>&nbsp;			float nextVal = ip.getf(x1+1, y);</b>
<b class="nc"><i>594</i>&nbsp;			for (int x = x1+1; x &lt; x2-1; x++) {</b>
<b class="nc"><i>595</i>&nbsp;				float lastVal = val;</b>
<b class="nc"><i>596</i>&nbsp;				val = nextVal;</b>
<b class="nc"><i>597</i>&nbsp;				nextVal = ip.getf(x+1, y);</b>
<b class="nc"><i>598</i>&nbsp;				if (val &lt; threshold || val &lt; lastVal || val &lt; nextVal)</b>
<b class="nc"><i>599</i>&nbsp;					continue;</b>
<i>600</i>&nbsp;				// We have a value &gt;= its horizontal neighbours... now test the verticals
<b class="nc"><i>601</i>&nbsp;				if (val &gt;= ip.getf(x-1, y-1) &amp;&amp; val &gt;= ip.getf(x, y-1) &amp;&amp; val &gt;= ip.getf(x+1, y-1) &amp;&amp; </b>
<b class="nc"><i>602</i>&nbsp;						val &gt;= ip.getf(x-1, y+1) &amp;&amp; val &gt;= ip.getf(x, y+1) &amp;&amp; val &gt;= ip.getf(x+1, y+1))</b>
<b class="nc"><i>603</i>&nbsp;					ip2.setf(x, y, minVal);</b>
<i>604</i>&nbsp;			}
<i>605</i>&nbsp;		}
<b class="nc"><i>606</i>&nbsp;		ip2.setRoi(ip.getRoi());</b>
<b class="nc"><i>607</i>&nbsp;		return ip2;</b>
<i>608</i>&nbsp;	}
<i>609</i>&nbsp;
<i>610</i>&nbsp;
<i>611</i>&nbsp;
<i>612</i>&nbsp;	/**
<i>613</i>&nbsp;		 * Find regional maxima using morphological reconstruction.
<i>614</i>&nbsp;		 * @param ip input image
<i>615</i>&nbsp;		 * @param threshold the extent to which a maximum must be greater than its surroundings
<i>616</i>&nbsp;		 * @param outputBinary if true, the output is a binary image
<i>617</i>&nbsp;		 * @return
<i>618</i>&nbsp;		 */
<i>619</i>&nbsp;		public static ImageProcessor findRegionalMaxima(ImageProcessor ip, float threshold, boolean outputBinary) {
<i>620</i>&nbsp;	//		float minVal = (ip instanceof FloatProcessor) ? Float.NEGATIVE_INFINITY : 0;
<i>621</i>&nbsp;	
<b class="nc"><i>622</i>&nbsp;			Rectangle bounds = ip.getRoi();</b>
<i>623</i>&nbsp;			int x1, x2, y1, y2;
<b class="nc"><i>624</i>&nbsp;			if (bounds == null) {</b>
<b class="nc"><i>625</i>&nbsp;				x1 = 0;</b>
<b class="nc"><i>626</i>&nbsp;				x2 = ip.getWidth();</b>
<b class="nc"><i>627</i>&nbsp;				y1 = 0;</b>
<b class="nc"><i>628</i>&nbsp;				y2 = ip.getHeight();</b>
<i>629</i>&nbsp;			} else {
<b class="nc"><i>630</i>&nbsp;				x1 = bounds.x;</b>
<b class="nc"><i>631</i>&nbsp;				x2 = bounds.x + bounds.width;</b>
<b class="nc"><i>632</i>&nbsp;				y1 = bounds.y;</b>
<b class="nc"><i>633</i>&nbsp;				y2 = bounds.y + bounds.height;</b>
<i>634</i>&nbsp;			}
<i>635</i>&nbsp;			
<i>636</i>&nbsp;			
<i>637</i>&nbsp;	//		long startTime = System.currentTimeMillis();
<b class="nc"><i>638</i>&nbsp;			ImageProcessor ip2 = getMaximaLabels(ip, threshold, x1, x2, y1, y2);</b>
<i>639</i>&nbsp;			
<i>640</i>&nbsp;	
<b class="nc"><i>641</i>&nbsp;			morphologicalReconstruction(ip2, ip);</b>
<i>642</i>&nbsp;			
<i>643</i>&nbsp;			
<i>644</i>&nbsp;			// Determine the height of the maxima
<i>645</i>&nbsp;			ImageProcessor ipOutput;
<b class="nc"><i>646</i>&nbsp;			if (outputBinary)</b>
<b class="nc"><i>647</i>&nbsp;				ipOutput = SimpleThresholding.greaterThan(ip, ip2);</b>
<i>648</i>&nbsp;			else {
<b class="nc"><i>649</i>&nbsp;				ip2.copyBits(ip, 0, 0, Blitter.DIFFERENCE);</b>
<b class="nc"><i>650</i>&nbsp;				ipOutput = ip2;</b>
<i>651</i>&nbsp;			}
<i>652</i>&nbsp;			
<i>653</i>&nbsp;	//		// Apply a mask, if there is one
<i>654</i>&nbsp;	//		byte[] mask = ip.getMaskArray();
<i>655</i>&nbsp;	//		if (mask != null) {
<i>656</i>&nbsp;	//			for (int i = 0; i &lt; mask.length; i++)
<i>657</i>&nbsp;	//				if (mask[i] == 0)
<i>658</i>&nbsp;	//					ipOutput.set(i, 0);
<i>659</i>&nbsp;	//		}
<b class="nc"><i>660</i>&nbsp;			return ipOutput;</b>
<i>661</i>&nbsp;		}
<i>662</i>&nbsp;
<i>663</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2021-01-25 09:46</div>
</div>
</body>
</html>
